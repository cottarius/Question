INSERT INTO questions (question, answer, theme, is_impotent)
VALUES ('Что представляют собой дженерики в Java?', 'Дженерики – это параметризованные типы.\n\n
С их помощью можно объявлять классы, интерфейсы и методы, в которых тип данных указан в виде параметра.\n\n
Используя дженерики, можно создать единственный класс, который будет автоматически работать с разными типами данных.\n\n
Эта информация доступна только на этапе компиляции и стирается в runtime, и в байт код попадет только информация о том, что в программе есть некий список List<Object> list вместо List<String> list, например.\n\n
Появились в версии 1.5 ', 'CORE2_COLLECTIONS', false),
       ('Какова цель использования дженериков?', 'Для строгой типизации и проверки на этапе компиляции.\n\n
Дженерики позволяют передавать тип объекта компилятору в форме <тип>. Таким образом, компилятор может выполнить все необходимые действия по проверке типов во время компиляции, обеспечивая безопасность по приведению типов во время выполнения.', 'CORE2_COLLECTIONS', false),
       ('Что такое сырые типы (raw type)?', 'Сырые типы — это типы без указания типа в фигурных скобках ( List list = new ArrayList<>() ), они использовались до появления дженериков.\n
Не указывая их, под капотом используется Object. ', 'CORE2_COLLECTIONS', false),
       ('Что такое стирание типов?', 'Стирание типов в Java - это процесс удаления информации о типах во время компиляции, позволяющий байт-коду выполняться на разных платформах с различными типами данных. Оно повышает переносимость, улучшает производительность и поддерживает обобщения.
', 'CORE2_COLLECTIONS', false),
       ('Как работают вайлдкарды в контексте дженериков?', 'Маске (wildcard) можно задать ограничения (Преодолеть инвариантность дженериков):\n\n
-“? extends T” (для получения в методе)  - объект, который наследуется от Т, либо сам Т – ковариантность.\n
Если контейнер объявлен ? extends T, то можно только читать значения. В список нельзя ничего добавить, кроме null.\n\n
-“? super T” (для отдачи в методе) - любой объект подтипа Т, включая Т – контравариантность.\n Нельзя прочитать элемент из контейнера с wildcard ? super, кроме объекта класса Object\n\n
При использовании ? мы сообщаем компилятору, чтобы он игнорировал информацию о типе, т.е. <?> - неограниченный символ подстановки. <?> означает то же что и <? extends Object>, т.е. принимает всё. Это можно обойти, создав обобщенный метод, объявленный с переменной типа T.', 'CORE2_COLLECTIONS', false),
       ('Объясните принцип PECS в контексте дженериков.', 'Producer Extends Consumer Super\n\n
wildcard подстановочный знак:\n
 Если мы объявили wildcard с extends, то это producer. Он только «производит», предоставляет элемент из контейнера, а сам ничего не принимает.\n\n
 Если же мы объявили wildcard с super — то это consumer. Он только принимает, а предоставить ничего не может.\n\n
Иначе говоря:\n
Если вы только получаете объекты из дженерик-коллекции - это producer и надо использвовать extends.\n
Если вы только кладете объекты в коллекцию - это consumer и надо использовать super.\n
Если вы делаете оба эти действия, то не надо использовать ни super, ни extends.', 'CORE2_COLLECTIONS', false),
       ('Что означает термин "коллекция" в Java?', 'Коллекция – это объект, который содержит набор объектов одного типа. Каждый из этих объектов в коллекции называется элементом.', 'CORE2_COLLECTIONS', false),
       ('Расскажите про иерархию коллекций в Java.', 'Иерархия коллекций в Java выглядит следующим образом:\n\n
1. Collection (интерфейс)\n
    a. List (интерфейс)\n
        * ArrayList\n
        * LinkedList\n
        * Vector\n
        * ...\n\n
    b. Set (интерфейс)\n
        * HashSet\n
        * TreeSet\n
        * LinkedHashSet\n
        * ...\n\n
    c. Queue (интерфейс)\n
        * PriorityQueue\n
        * ArrayDeque\n
        * ...\n\n
    d. Map (интерфейс)\n
        * HashMap\n
        * TreeMap\n
        * LinkedHashMap\n
        * ...\n\n
Collection - это базовый интерфейс для всех коллекций в Java. Он предоставляет методы для добавления, удаления и поиска элементов.\n\n
List - это упорядоченная коллекция, которая позволяет дубликаты и обеспечивает доступ к элементам по индексу.\n\n
Set - это неупорядоченная коллекция, которая не допускает дубликатов.\n\n
Queue - это упорядоченная коллекция, которая следует принципу FIFO (первым пришел - первым вышел).\n\n
Map - это коллекция пар ключ-значение, которая предоставляет методы для получения значения по ключу.\n\n
Каждая коллекция имеет свои уникальные особенности и области применения. Выбор подходящей коллекции зависит от требований конкретного приложения.', 'CORE2_COLLECTIONS', true),
       ('Почему Map не является подтипом Collection, в отличие от List и Set?', 'Коллекция (List и Set) представляет собой совокупность некоторых элементов (обычно экземпляров одного класса).Map -это совокупность пар "ключ"-"значение".\n\n
У map нет итерабл, не понятно по чему проводить итерацию', 'CORE2_COLLECTIONS', true),
       ('Какие различия между java.util.Collection и java.util.Collections?', 'Класс java.util.Collections содержит исключительно статические методы для работы с коллекциями. \n
В них входят методы, реализующие полиморфные алгоритмы (такие алгоритмы, использование которых возможно с разными видами структур данных), "оболочки", возвращающие новую коллекцию с инкапсулированной указанной структурой данных и некоторые другие методы.\n\n
java.util.Collection - это корневой интерфейс Java Collections Framework. Этот интерфейс в основном применяется там, где требуется высокий уровень абстракции, например, в классе java.util.Collections.', 'CORE2_COLLECTIONS', false),
       ('Как отличается итератор с fail-fast итератора с fail-safe поведением? Приведите примеры.', 'Итератор fail-safe не вызывает исключений при изменении структуры коллекции, потому что работает с её клоном.\n
Пример fail-safe - CopyOnWriteArrayList (он создал отдельную копию )и итератор (keySet коллекции ConcurrentHashMap - не создает отдельную копию).\n\n
Итератор fail-fast генерирует исключение ConcurrentModificationException, если коллекция меняется во время итерации, но работает быстрее.\n
Пример fail-fast - Vector и Hashtable.', 'CORE2_COLLECTIONS', false),
       ('В чем разница между Enumeration и Iterator?', 'Iterator имеет больше методов работы с коллекциями и был специально введен в java2, вместо Enumeration(interface). Рекоммендуется юзать Iterator.\n\n
Оба интерфейса предназначены для обхода коллекции, но есть различия:\n
-с помощью Enumeration нельзя удалять элементы;\n
-в Iterator исправлены имена методов для повышения читаемости кода (Enumeration.hasMoreElements() соответствует Iterator.hasNext(), Enumeration.nextElement() соответствует Iterator.next() и т.д);\n
-Enumeration присутствуют в устаревших классах, таких как Vector/Stack, тогда как Iterator есть во всех современных коллекциях.', 'CORE2_COLLECTIONS', false),
       ('Как связаны между собой интерфейсы Iterable, Iterator и "for-each"?', 'Интерфейс Iterable имеет метод - iterator(), с типом возвращаемого значения - интерфейс Iterator.\n
Экземпляры классов, реализующих интерфейс Iterable, могут использоваться в цикле foreach.', 'CORE2_COLLECTIONS', false),
       ('Можно ли удалить элемент, итерируясь по ArrayList? Какая исключительная ситуация может возникнуть?', 'Можно, но нужно использовать iterator.remove().\n
Иначе при прохождении по ArrayList в цикле for сразу после удаления элемента будет ConcurrentModificationException.', 'CORE2_COLLECTIONS', false),
       ('Как ведет себя коллекция при использовании метода iterator.remove()?', 'Этот метод удаляет текущий элемент. Важный момент заключается в том, что сначала этот элемент необходимо получить с помощью метода next(), если мы вызовем метод remove() до метода next(), то мы получим IllegalStateException.', 'CORE2_COLLECTIONS', false),
       ('Какие существуют реализации интерфейса Map в Java?', '- TreeMap - реализация интерфейса Map, основанная на сбалансированных бинарных деревьях. Это обеспечивает быстрое выполнение операций, связанных с сортировкой элементов в Map.\n\n
- LinkedHashMap - реализация интерфейса Map, которая хранит пары ключ-значение в порядке добавления элементов в Map. Он также может сохранять порядок доступа к элементам.\n\n
- ConcurrentHashMap - это потокобезопасная реализация интерфейса Map, которая позволяет безопасно использовать Map в многопоточном окружении.\n\n
- EnumMap - реализация интерфейса Map, которая использует перечисления в качестве ключей. Она гарантирует, что только определенные значения могут быть использованы в качестве ключей, что делает ее полезной при работе с ограниченным набором ключей.\n\n
- WeakHashMap - реализация интерфейса Map, которая хранит ключи в виде ссылок на объекты. При этом если на объект-ключ больше нет ссылок, то он будет автоматически удален из Map.\n\n
- IdentityHashMap - реализация интерфейса Map, которая использует оператор "==" для сравнения ключей вместо метода equals(). Он может быть полезен при работе с ключами, которые могут иметь одинаковое значение, но различные ссылки.', 'CORE2_COLLECTIONS', false),
       ('Как устроена HashMap, и какова сложность ее основных операций (до Java 8 и после)? Объясните принцип корзин.', 'HashMap – внутри состоит из корзин и списка элементов, на которые ссылаются корзины.\n
Корзины – массив\n\n
Элементы(Node) – связанный список ( Принцип связи в корзинах основан на linkedlist), то есть каждый элемент списка имеет указатель на следующий элемент. Перавая идет проверка на null\n\n
При добавлении нового элемента, хэш-код ключа определяет корзину для элемента с помощью hashFunction(), который принимает hashCode ключа и возвращает номер корзины. В корзине есть ссылка на связанный список, в который будет положен наш объект. Идет проверка, есть ли элементы в этом списке. Если нету, то корзина получает ссылку нового элемента, если есть, то происходит прохождение по списку элементов и сравнивание элементов в списке. Проверяется равенство hashcode. Зная о коллизии, проводится еще сравнивание ключей методом equals.\n\n
Если оба равны: идет перезапись\n
Если не равен equals: добавляется элемент в конец списка\n\n
HashMap имеет поле loadFactor. Оно может быть задано через конструктор. По умолчанию - 0.75. Его произведение на количество корзин дает нам необходимое число объектов которое нужно добавить чтобы состоялось удвоение количества корзин.\n\n
Например если у нас мапка с 16-ю(default) корзинами, а loadFactor равняется 0.75, то расширение произойдет когда мы добавим 16 * 0.75 = 12 объектов.\n\n
После удвоения все объекты будут перераспределены с учетом нового количества корзин\n
Если индексы равны хэщ-коды равный ключи равны то происходит перезапись элемента\n
Метод get()  - проверка по хэш коду после проверка на equals\n
При коллизии и хранении в 1 бакете огромного LinkedList скорость будет О(n) до Java 8 после в сбаласированное красно-черное дерево и скокрость O(log2(n))', 'CORE2_COLLECTIONS', true),
       ('Как устроена TreeMap, и какова сложность ее основных операций?', 'Класс TreeMap<K, V> представляет отображение в виде дерева.\n Он наследуется от класса AbstractMap и реализует интерфейс NavigableMap, а следовательно, также и интерфейс SortedMap.\n Поэтому в отличие от коллекции HashMap в TreeMap все объекты автоматически сортируются по возрастанию их ключей.\n Если ключи одинаковые то происходит перезапись.\n Treemap - не сонхронизированная коллекция. Возможность работы с null-ключом - Можно, если используется компаратор, разрешающий null', 'CORE2_COLLECTIONS', false),
       ('Как ведет себя HashMap, если пытаться добавить в нее два элемента с одинаковыми hashCode(), но с различающимися equals()?', 'По значению hashCode() вычисляется индекс ячейки массива, в список которой этот элемент будет добавлен.\n Перед добавлением осуществляется проверка на наличие элементов в этой ячейке.\n Если элементы с таким hashCode() уже присутствует, но их equals() методы не равны, то элемент будет добавлен в конец списка.', 'CORE2_COLLECTIONS', true),
       ('Как поведет себя HashMap, если ключ, у которого определены некорректно equals и hashCode, будет добавлен?', 'Объект скорее всего добавится, но обратно мы не сможем получить его.', 'CORE2_COLLECTIONS', true),
       ('Возможно ли, что HashMap превратится в список, даже если ключи имеют разные hashCode()?', 'Это возможно в случае, если метод, определяющий номер корзины будет возвращать одинаковые значения.', 'CORE2_COLLECTIONS', true),
       ('Почему нельзя использовать byte[] в качестве ключа в HashMap?', 'Хэш-код массива не зависит от хранимых в нем элементов, а присваивается при создании массива (метод вычисления хэш-кода массива не переопределен и вычисляется по стандартному Object.hashCode() на основании адреса массива).\n\n Также у массивов не переопределен equals и выполняется сравнение указателей.\n Это приводит к тому, что обратиться к сохраненному с ключом-массивом элементу не получится при использовании другого массива такого же размера и с такими же элементами, доступ можно осуществить лишь в одном случае — при использовании той же самой ссылки на массив, что использовалась для сохранения элемента.', 'CORE2_COLLECTIONS', true),
       ('Сможет ли работать HashMap, если все добавляемые ключи будут иметь одинаковый hashCode()?', 'Да, будет, но в этом случае HashMap вырождается в связный список и теряет свои преимущества.', 'CORE2_COLLECTIONS', true),
       ('Каково худшее время выполнения метода get(key) для ключа, отсутствующего в HashMap?', 'O(N). Худший случай - это поиск ключа в таблице, вырожденной в список, перебор ключей которой занимает линейно пропорциональное время количеству хранимых элементов.', 'CORE2_COLLECTIONS', true),
       ('Каково худшее время выполнения метода get(key) для ключа, присутствующего в HashMap?', 'O(N) - линейное', 'CORE2_COLLECTIONS', true),
       ('Что такое rehashing?', 'Rehashing в Java - это процесс изменения размера хэш-таблицы и перераспределения ее элементов для повышения производительности и предотвращения коллизий.\n\n
Когда хэш-таблица становится слишком заполненной, производительность поиска и вставки снижается. Rehashing решает эту проблему путем создания новой хэш-таблицы большего размера и перераспределения всех существующих элементов в новую таблицу.\n\n
В Java rehashing выполняется автоматически, когда заполняемость хэш-таблицы превышает определенный порог (по умолчанию 0,75). Во время rehashing все элементы удаляются из старой таблицы, хэш-функция применяется к каждому элементу для получения нового индекса, и элементы вставляются в новую таблицу с этим индексом.\n\n
Rehashing является важной операцией для поддержания производительности хэш-таблиц и предотвращения деградации производительности из-за коллизий.', 'CORE2_COLLECTIONS', true),
       ('При каких условиях список в бакете перерождается в красно-черное дерево?', 'Список в бакете перерождается в красно-черное дерево в Java, когда количество элементов в бакете превышает определенный порог (по умолчанию 8).', 'CORE2_COLLECTIONS', true),
       ('Как Set отличается от Map?', 'Основные отличия:\n\n
* Уникальность: Set хранит только уникальные элементы, в то время как Map допускает дубликаты ключей.\n\n
* Порядок: Set неупорядочен, а Map не гарантирует порядка итерации по парам ключ-значение.\n\n
* Значения: Set хранит только сами элементы, в то время как Map хранит пары ключ-значение, где значение может быть любого типа.\n\n
* Поиск: Поиск элемента в Set осуществляется по его значению, в то время как в Map поиск осуществляется по ключу.\n\n
В целом, Set используется для хранения набора уникальных элементов, а Map используется для хранения данных в виде пар ключ-значение, где ключ служит для идентификации соответствующего значения.', 'CORE2_COLLECTIONS', false),
       ('Как Set отличается от List?', 'Set не добавляет новых методов, только вносит изменения в унаследованные.\n\n
В частности, метод add() добавляет элемент в коллекцию и возвращает true, если не было такого элемента.\n\n
Разрешено наличие только одной ссылки типа null. Set не имеет дубликатов List имеет', 'CORE2_COLLECTIONS', false),
       ('Объясните интерфейс Set в Java.', 'Интерфейс Set расширяет интерфейс Collection. \n\n
Set не добавляет новых методов, только вносит изменения унаследованные.\n\n
Set - неупорядоченный набор неповторяющихся элементов\n\n
В частности, метод add() добавляет элемент в коллекцию и возвращает true, если не было такого элемента.\n\n
Разрешено наличие только одной ссылки типа null.', 'CORE2_COLLECTIONS', false),
       ('Расскажите о реализациях интерфейса Set.', 'В HashSet порядок добавления элементов будет непредсказуемым - используется хэширование для ускорения выборки.\n\n
В TreeSet объекты хранятся отсортированными по возрастанию из-за применения к/ч дерева.\n\n
LinkedHashSet хранит элементы в порядке добавления.', 'CORE2_COLLECTIONS', false),
       ('Каковы отличия между TreeSet и HashSet?', 'HashSet быстрее, чем TreeSet .\n\n
В HashSet элементы в случайном порядке, в TreeSet в отсортированном.\n\n
HashSet обеспечивает постоянную производительность - О(1) - для большинства операций, таких как add () , remove () и contains () , по сравнению с временем log(n), предлагаемым TreeSet.', 'CORE2_COLLECTIONS', false),
       ('В чем разница между LinkedHashSet и HashSet?', 'Основное различие в том, что LinkedHashSet сохраняет порядок вставки элементов, а HashSet - нет.\n В основе LinkedHashSet лежит LinkedHashMap вместо HashMap. Благодаря этому порядок элементов при обходе коллекции является идентичным порядку добавления элементов', 'CORE2_COLLECTIONS', false),
       ('Как изменится TreeSet, если добавлять элементы в него по возрастанию?', 'TreeSet все равно в каком порядке вы добавляете в него элементы, так как в основе TreeSet лежит красно-черное дерево, которое умеет само себя балансировать и хранить элементы по возрастанию. ', 'CORE2_COLLECTIONS', false),
       ('Как устроен HashSet, и какова сложность его основных операций? Объясните принцип корзин.', 'HashSet в Java представляет собой коллекцию, которая хранит уникальные элементы и не допускает дублирования значений. Он основан на принципе хэширования, где каждый элемент добавляется в хэш-таблицу под уникальным индексом.\n\n
Принцип корзин (Bucket Principle) заключается в том, что элементы в HashSet хранятся в массиве (или массивах) под некоторыми индексами, которые обычно вычисляются с использованием хеш-функции. Если два или более элемента имеют одинаковый хеш-код, то они будут храниться в одной и той же "корзине", то есть в одном и том же массиве. При этом, внутри "корзины" может быть использована другая структура данных (например, связанный список), чтобы хранить коллизии - случаи, когда разные элементы имеют одинаковый хеш-код.\n\n
Основные операции HashSet и их сложность:\n
- add(element) - добавление элемента: O(1) (в среднем)\n
- contains(element) - проверка наличия элемента: O(1) (в среднем)\n
- remove(element) - удаление элемента: O(1) (в среднем)', 'CORE2_COLLECTIONS', false),
       ('Как устроен LinkedHashSet, и какова сложность его основных операций?', 'LinkedHashSet в Java является комбинацией HashSet и LinkedHashMap. Он представляет собой коллекцию, которая хранит уникальные элементы, сохраняя порядок вставки. LinkedHashSet использует хэш-таблицу для хранения уникальных элементов и двусвязанный список для сохранения порядка вставки.\n\n Основные операции LinkedHashSet и их сложность:\n
- add(element) - добавление элемента: O(1) (в среднем)\n
- contains(element) - проверка наличия элемента: O(1) (в среднем)\n
- remove(element) - удаление элемента: O(1) (в среднем)', 'CORE2_COLLECTIONS', false),
       ('Как устроен TreeSet, и какова сложность его основных операций?', 'TreeSet в Java представляет собой коллекцию элементов, отсортированных в соответствии с их значением. Внутри TreeSet используется красно-черное дерево (Red-Black Tree) для хранения элементов. Каждый узел дерева содержит ссылки на левого и правого потомков, а также указатель на родителя, значение элемента, и цвет узла.\n\n
Сложность основных операций в TreeSet:\n
1. Добавление элемента в TreeSet (add): O(log n).\n
2. Удаление элемента из TreeSet (remove): O(log n).\n
3. Поиск элемента в TreeSet (contains): O(log n)', 'CORE2_COLLECTIONS', false),
       ('Объясните интерфейс List в Java.', 'Контейнеры List хранит элементы в порядке добавления.\n Интерфейс List дополняет Collection несколькими методами, обеспечивающими вставку и удаление элементов в середине списка.\n Позволяет хранить дубликаты и null.\n Каждый элемент имеет индекс.\n Это позволяет получить (get) элемент по индексу или задать значением для определённого индекса (set).\n Методы коллекций add, addAll, remove позволяют указать индекс, с которого необходимо их выполнять.\n Кроме того, у List есть своя версия итератора, которая называется ListIterator.\n Этот итератор знает про индекс элемента, поэтому он умеет итерироваться не только вперёд, но и назад.\n Его даже можно создать от определённого места в коллекции.\n Скорость LinkedList - O(n)\n LinkedList — это связанный (Linked) список (List).\n Каждая запись в связанном списке представлена в виде Entry, которая хранит сами данные, а так же ссылку на следующую (next) и предыдущую (previous) Entry.\n Таким образом LinkedList реализует "Последовательный доступ" (Sequential Access).', 'CORE2_COLLECTIONS', false),
       ('Как устроен ArrayList, и какова сложность его основных операций?', 'ArrayList хранит элементы в динамическом массиве. Элементы ArrayList могут быть абсолютно любых типов в том числе и null.\n\n
**Основное преимущество** такой коллекции над массивом – это **расширяемость** – увеличение длины при надобности.\n\n
Если в этом массиве заканчивается место, то создаётся второй массив побольше, куда копируются все элементы из первого.\n\n
При добавлении элемента в середину ArrayList, все элементы справа от него копируются на 1 позицию вправо, а затем в пустую ячейку добавляется новый элемент.\n\n
По возможности, избегайте операций вставки в середину коллекции. Ведь системе приходится заново пересчитывать индексы элементов.\n\n
При удалении элемента из середины, все элементы справа от него копируются на 1 позицию влево. Сам массив не укорачивается (можно укоротить через trimToSize()).\n\n
Особенности\n
- Быстрый доступ к элементам по индексу за время O(1);\n
- Доступ к элементам по значению за линейное время O(n);\n
- Медленный, когда вставляются и удаляются элементы из «середины» списка;\n
- Позволяет хранить любые значения в том числе и null;\n
- Не синхронизирован.', 'CORE2_COLLECTIONS', true),
       ('Что лучше использовать ArrayList или LinkedList?', 'ArrayList подходит для работы с коллекцией, доступной только для чтения, а LinkedList подходит для работы с коллекцией, допускающей различные модификации данных, такие как добавление и удаление.', 'CORE2_COLLECTIONS', true),
       ('Оцените объем памяти, необходимый для хранения одного примитива типа byte в LinkedList.', 'в x32 JVM около 32 байтов выделяется для хранения одного значения типа byte в LinkedList.\n
Для 64-битной JVM каждая ссылка занимает 64 бита (8 байт).', 'CORE2_COLLECTIONS', false),
       ('Оцените объем памяти, необходимый для хранения одного примитива типа byte в ArrayList.', 'ArrayList основан на массиве. Каждый элемент массива хранит примитивный тип данных - byte, размер которого 1 байт.
 ', 'CORE2_COLLECTIONS', false),
       ('Что такое Queue в Java?', 'Очереди представляют структуру данных, работающую по принципу FIFO (first in - first out).\n\n
У всех классов, которые реализуют данный интерфейс, будет метод `offer` для добавления в очередь, метод `poll` для извлечения элемента из головы очереди, и методы `peek` и `element`, позволяющие просто получить элемент из головы очереди.', 'CORE2_COLLECTIONS', false),
       ('Что представляет собой Deque, и в чем разница между Deque и Queue?', 'представляет собой двухстороннюю очередь, которая может использоваться как стек или очередь. Другими словами, вы можете добавлять и удалять элементы как с начала, так и с конца очереди. Эта структура данных поддерживает все операции, которые поддерживает Queue, а также операции добавления/удаления элементов в/из начала и конца очереди: addFirst(), addLast(), removeFirst(), removeLast(), getFirst() и getLast().\n\n
Таким образом, основным отличием между Queue и Deque является то, что Deque предоставляет более широкий набор операций, позволяющих добавлять и удалять элементы как в начале, так и в конце очереди. В то же время, Queue ориентирована на работу только со структурой данных, работающей по принципу FIFO, тогда как Deque может использоваться для реализации как стека, так и очереди.', 'CORE2_COLLECTIONS', false),
       ('Приведите пример реализации Deque в Java.', 'ArrayDeque. Также один из примеров реализации - это Линкед лист.', 'CORE2_COLLECTIONS', false),
       ('Какую коллекцию можно использовать для реализации FIFO?', 'Queue (PriorityQueue)', 'CORE2_COLLECTIONS', false),
       ('Какую коллекцию можно использовать для реализации LIFO?', 'Stack, ArrayDeque', 'CORE2_COLLECTIONS', false),
       ('Начальная емкость коллекций?', '- ArrayList - 10 элементов.** Новая емкость рассчитывается как (старая емкость * 3) / 2 + 1.\n\n - LinkedList - 0\n\n
- HashMap, HashSet, LinkedHashSet, TreeSet, ArrayDeque - 16 элементов. Коэффициент загрузки 0.75
- PriorityQueue - 11 элементов. Коэффициент загрузки 0.75', 'CORE2_COLLECTIONS', true),
       ('Что такое функциональный интерфейс, и как он используется в Java?', 'Это интерфейс, который содержит только 1 абстрактный метод.\n
Интерфейс может включать сколько угодно default (и static) методов и при этом оставаться функциональным, потому что default методы - не абстрактные.', 'CORE2_COLLECTIONS', false),
       ('Для чего предназначена аннотация @FunctionalInterface?', 'Аннотация @FunctionalInterface в Java используется для обозначения интерфейса, который имеет только один абстрактный метод. Это позволяет компилятору проверять, что интерфейс действительно является функциональным интерфейсом, и генерировать более эффективный байт-код для лямбда-выражений и ссылок на методы, реализующих этот интерфейс.', 'CORE2_COLLECTIONS', false),
       ('Какие встроенные функциональные интерфейсы вы знаете?', 'Predicate<T> - реализуется функция, получающая на вход экземпляр класса T и возвращающая на выходе значение типа boolean\n\n
Consumer<T> - реализуется функция, которая получает на вход экземпляр класса T, производит с ним некоторое действие и ничего не возвращает\n\n
Function<T,R> - реализуется функция, получающая на вход экземпляр класса T и возвращающая на выходе экземпляр класса R\n\n
Supplier<T> - реализуется функция, ничего не принимающая на вход, но возвращающая на выход результат класса T\n\n
UnaryOperator<T> - принимает в качестве параметра объект типа T, выполняет над ними операции и возвращает результат операций в виде объекта типа T\n\n
BinaryOperator<T, Т> - реализуется функция, получающая на вход два экземпляра класса T и возвращающая на выходе экземпляр класса T', 'CORE2_COLLECTIONS', false),
       ('Что такое ссылка на метод в контексте лямбда-выражений?', 'Ссылка на статический метод - имя_класса::имя_метода\n\n
Ссылка на нестатический метод конкретного объекта - имя_экземпляра::имя_методаимя_класса::имя_метода\n\n
Ссылка на конструктор - ClassName::new\n\n
Ссылка на метод - это сокращенный синтаксис выражения лямбда, который выполняет только один метод. Это позволяет нам ссылаться на конструкторы или методы, не выполняя их. ', 'CORE2_COLLECTIONS', false),
       ('Что представляет собой лямбда-выражение, и чем его можно заменить?', 'Лямбда-выражение — это анонимная функция в программировании, которая может быть использована вместо объявления и вызова отдельной функции. Оно представляет собой короткую запись для определения функции без необходимости объявления ее имени и типа', 'CORE2_COLLECTIONS', false),
       ('Что такое Stream API, и для чего используются стримы?', 'Stream API — это новый способ работать со структурами данных в функциональном стиле. Stream (поток) API (описание способов, которыми одна компьютерная программа может взаимодействовать с другой программой) — это по своей сути поток данных\n\n
С появлением Java 8 Stream API позволило программистам писать существенно короче то, что раньше занимало много строк кода, а именно — упростить работу с наборами данных, в частности, упростить операции фильтрации, сортировки и другие манипуляции с данными. Если у вас промежуточных операций нет, часто можно и нужно обойтись без стрима, иначе код будет сложнее чем без потока.', 'CORE2_COLLECTIONS', false),
       ('Почему Stream называется ленивым?', 'Из-за того, что пока не будет вызвана последняя операция над стримом, с ним не будет происходить никаких действий. Т.е. промежуточные операции выполняются лениво.', 'CORE2_COLLECTIONS', false),
       ('Какие способы создания стрима вы знаете?', '1. Из массива Arrays.stream()\n
2. Из набора значений Stream.of()\n
3. Из файла File.lines()\n
4. Из коллекции "collection".stream()\n
5. Из строки "string".chars()\n
6. С помощью Stream.builder()\n
7. С помощью Stream.iterate(оператор) (бесконечный)\n
8. С помощью Stream.generate(саплаер) (бесконечный)', 'CORE2_COLLECTIONS', false),
       ('Как можно создать стрим из коллекции?', 'Вызвать метод stream()', 'CORE2_COLLECTIONS', false),
       ('Какие промежуточные операции со стримами вы знаете?', '1. filter - фильтрует записи и возвращает только соответствующие условию\n
2. skip - пропускает определенное кол-во первых элементов\n
3. distinct - удаляет дубликаты элементов\n
4. map - преобразует каждый элемент стрима\n
5. peek - возвращает тот же стрим, но применяет функцию к каждому элементу стрима\n
6. limit - ограничивает стрим кол-вом первых элементов\n
7. sorted - сортирует значения в натуральном порядке или по компоратору\n
8. mapToInt/Long/double - возвращает стрим из числовых примитивов\n
9. flatMap (ToInt..) - создает из одного элемента несколько\n
10. mapToObj - переводит числовой стрим в объектный', 'CORE2_COLLECTIONS', true),
       ('В чем разница между методами map() и flatMap() в стримах?', 'Тем что map() применяет функцию к каждому элементу, а flatMap() разбивает каждый элемент на стримы (от 0 до бесконечности) и затем объединяет их', 'CORE2_COLLECTIONS', false),
       ('Какие терминальные операции со стримами вы знаете?', '1. findAny - возвращает любой подходящий элемент;\n
2. findFirst - возвращает первый элемент;\n
3. collect - позволяет вернуть результат в виде структуры данных (коллекции);\n
4. count - возвращает число элементов;\n
5. anyMatch - возвращает true в случае выполнения условия для хотя бы одного элемента\n
6. noneMatch - возвращает true в случае невыполнения условия для каждого элемента\n
7. allMatch - возвращает true в случае выполнения условия для каждого элемента\n
8. min - минимальный элемент по компоратору;\n
9. max - максимальный элемент по компоратору;\n
10. forEach - применяет функцию к каждому элементу, порядок не гарантирован;\n
11. forEachOrdered - применяет функцию к каждому элементу с гарантированным порядком\n
12. toArray - возвращает массив значений\n
13. reduce - выполняет агрегатные функции и возвращает один результат\n
14. sum - сумма всех чисел (только для числовых стримов)\n
15. avarage - среднее арифметическое (только для числовых стримов)', 'CORE2_COLLECTIONS', true),
       ('Объясните метод collect() в контексте стримов.', 'Позволяет получить результат в виде коллекции, принимает на вход коллектор.', 'CORE2_COLLECTIONS', false),
       ('Объясните метод reduce() в контексте стримов.', 'позволяет выполнять агрегатные функции и возвращать один результат.\n
Результат применения бинарного оператора к каждой паре элементов стрима, пока не останется один элемент.\n
Позволяет выполнять агрегатные функции на всей коллекцией и возвращать один результат', 'CORE2_COLLECTIONS', false),
       ('Расскажите о классе Collectors и его методах в контексте стримов.', 'Нужен для того, чтобы упаковывать стримы в коллекции:\n
toList() - преобразует поток в список — List<T>\n
toSet() - преобразует поток в список — Set<T>\n
toMap() - преобразует поток в список — Map<K, V>\n
Используются в методе collect().', 'CORE2_COLLECTIONS', false),
       ('Что такое параллельная обработка в Java 8?', 'Чтобы сделать обычный последовательный поток параллельным, надо вызвать у объекта Stream метод parallel(внутри потока). А обратный метод - sequential(). Кроме того, можно также использовать блокирующий метод parallelStream() интерфейса Collection для создания параллельного потока из коллекции. В то же время если рабочая машина не является многоядерной, то поток будет выполняться как последовательный.\n\n
Работает на фреймворке fork/join(под капотом).Кроме того, можно также использовать метод parallelStream() (над стримами потока) интерфейса Collection для создания параллельного потока из коллекции. - сразу создается параллельнй стрим', 'CORE2_COLLECTIONS', false),
       ('Что представляют собой IntStream и DoubleStream?', 'В Java 8 создание Stream-ов примитивов напрямую невозможно, из-за дженериков. Но разработчики сделали 3 Stream-а примитивов : IntStream, LongStream, DoubleStream. Работает быстрее, чем стрим с классами-обертками.\n
Поддерживают дополнительные терминальный методы sum(), average(), mapToObj()', 'CORE2_COLLECTIONS', false),
       ('Какие нововведения появились в Java 8?', '1. Полноценная поддержка лямбда-вражений\n
2. Ссылки на методы :: \n
3. Функциональные интерфейсы\n
4. default методы в интефейсах\n
5. Потоки для работы с коллекциями\n
6. Новое api для работы с датами \n
7. Nashorn движок JavaScript, разрабатываемый полностью на Java компанией Oracle.\n
8. Кодировщик/декодировщик.\n
9. Новые методы для Map - PutIfAbsent(), СomputeIfAbsent()\СomputeIfPresent(), Remove(), GetOrDefault(), Merge()\n
10. Metaspace пришла на замену PermGen', 'CORE2_COLLECTIONS', false),
       ('Какие новые классы для работы с датами появились в Java 8?', 'LocalDate , LocalTime, LocalDateTime, ZonedDateTime, Period, Duration', 'CORE2_COLLECTIONS', false),
       ('Что представляет собой класс Optional в Java?', 'Optional - новый класс в пакете java.util, является контейнером (оберткой) для значений которая также может безопасно содержать null.\n Благодаря опциональным типам можно забыть про проверки на null и NullPointerException.', 'CORE2_COLLECTIONS', false),
       ('Какой класс появился в Java 8 для кодирования и декодирования данных?', 'public static class Base64.Encoder /public static class Base64.Decoder', 'CORE2_COLLECTIONS', false),
       ('Как создать кодировщик и декодировщик Base64 в Java?', 'Используя метод getDecoder() класса Base64 он возвращает декодировщик Base64.Decoder, который декодирует данные с помощью схемы кодирования base64.\n
Используя метод getEncoder() класса Base64 он возвращает кодировщик Base64.Encoder, который кодирует данные с помощью схемы кодирования base64.', 'CORE2_COLLECTIONS', false),
       ('Какие дополнительные методы для работы с ассоциативными массивами (maps) появились в Java 8?', '1. forEach() — позволяет выполнять заданное действие для каждой пары ключ-значение в мапе.\n
2. replace(key, oldValue, newValue) — заменяет значение oldValue на newValue для заданного ключа key, только если oldValue соответствует текущему значению ключа.\n
3. replaceAll() — заменяет каждое значение в мапе, используя определённую функцию.\n
4. compute() — позволяет вычислить новое значение для заданного ключа и заменить старое значение новым вычисленным значением.\n
5. computeIfAbsent() — позволяет вычислить новое значение для заданного ключа, только если заданный ключ отсутствует в мапе.\n
6. computeIfPresent() — позволяет вычислить новое значение для заданного ключа, только если заданный ключ присутствует в мапе.\n
7. merge() — выполняет объединение двух мап с определённой функцией, когда ключ встречается в двух мапах.', 'CORE2_COLLECTIONS', false),
       ('Что такое LocalDateTime в контексте дат и времени?', 'LocalDateTime объединяет вместе LocaleDate и LocalTime, содержит дату и время в календарной системе ISO-8601 без привязки к часовому поясу. Время хранится с точностью до наносекунды. Содержит множество удобных методов, таких как plusMinutes, plusHours, isAfter, toSecondOfDay и т.д.', 'CORE2_COLLECTIONS', false),
       ('Что представляет собой ZonedDateTime в контексте дат и времени?', 'java.time.ZonedDateTime — аналог java.util.Calendar, класс с самым полным объемом информации о временном контексте в календарной системе ISO-8601. Включает объект ZoneId - временную зону(в ZoneId 599 зон), поэтому все операции с временными сдвигами этот класс проводит с её учётом.', 'CORE2_COLLECTIONS', false),
       ('Что такое Instant?', 'Вместо часов, минут и секунд, он оперирует секундами, миллисекундами и наносекундами.\n\n
Этот класс хранит в себе два поля:\n
- количество секунд, прошедшее с 1 января 1970 года\n
- количество наносекунд\n\n
Класс считает время в Unix-time: от начала 1970 года.\n
Можно даже сказать, что класс Instant — это упрощенная версия класса Date: оставили только то, что нужно программистам.', 'CORE2_COLLECTIONS', false),
       ('В чем отличие Instant от LocalDateTime?', 'Instant — это мгновенная точка на временной шкале. Она представляет собой момент времени, который не зависит от часового пояса. Instant измеряется в наносекундах от начала эпохи Unix (1970-01-01T00:00:00Z). Это обычно используется в технических целях, например, для метки времени при трассировке событий или измерении продолжительности событий.\n\n
LocalDateTime - это комбинация даты и времени без информации о часовом поясе. Он представляет собой дату и время с точностью до наносекунд, но без учета часового пояса. Это обычно используется для представления даты и времени в человеко-читаемом формате.\n\n
Таким образом, при выборе между Instant и LocalDateTime, следует обратить внимание на следующие моменты:\n
Если в приложении требуется работать с метками времени и измерять время с высокой точностью, то лучше использовать Instant.\n
Если же в приложении требуется работать с датами и временем в формате, удобном для человека, и часовой пояс не важен, то подойдет LocalDateTime.', 'CORE2_COLLECTIONS', false);
