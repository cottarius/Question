INSERT INTO quiz_questions (question, correct_answer, wrong_answer, wrong_answer_2, wrong_answer_3)
VALUES
    ('Что такое ООП', 'Парадигма программирования, основанная на объектах, инкапсуляции, наследовании и полиморфизме', 'Стиль программирования без классов', 'Методология работы с базами данных', 'Язык низкого уровня'),
    ('Какие преимущества у ООП', 'Инкапсуляция, наследование, полиморфизм', 'Упрощает параллельные вычисления', 'Увеличивает производительность кода', 'Не требует компиляции'),
    ('Какие недостатки у ООП', 'Более сложная архитектура и потенциальная избыточность', 'Невозможность повторного использования кода', 'Ограниченная поддержка многопоточности', 'Отсутствие абстракций'),
    ('Назовите основные принципы ООП', 'Инкапсуляция, наследование, полиморфизм, абстракция', 'Композиция, модульность, интерфейсы', 'Функциональное программирование', 'Процедурный стиль'),
    ('Что такое инкапсуляция?', 'Скрытие внутренней реализации объекта', 'Объединение нескольких классов', 'Механизм создания новых объектов', 'Преобразование типов данных'),
    ('Что такое наследование?', 'Возможность одного класса наследовать свойства другого', 'Создание экземпляров класса', 'Перегрузка методов в одном классе', 'Работа с исключениями'),
    ('Что такое полиморфизм?', 'Возможность объектов принимать разные формы', 'Использование примитивных типов', 'Связь между статическими полями', 'Работа с массивами'),
    ('Что такое ассоциация', 'Связь между двумя или более классами', 'Создание временного объекта', 'Наследование от абстрактного класса', 'Сериализация данных'),
    ('Что такое композиция', 'Тип ассоциации, при котором один объект управляет жизнью другого', 'Использование final-полей', 'Создание дженериков', 'Использование статических методов'),
    ('Что такое агрегация', 'Слабая форма композиции, где объекты могут существовать независимо', 'Создание интерфейсов', 'Использование коллекций', 'Связь через наследование'),
    ('Расскажите про раннее и позднее связывание.', 'Раннее — определяется на этапе компиляции, позднее — во время выполнения', 'Раннее — только для статических методов', 'Позднее используется в интерфейсах', 'Раннее не поддерживается JVM'),
    ('SOLID', 'Принципы проектирования: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion', 'Модель работы с многопоточностью', 'Набор шаблонов проектирования', 'Техники оптимизации памяти'),
    ('Какая основная идея языка?', 'Кроссплатформенность и безопасность', 'Оптимизация производительности', 'Поддержка низкоуровневого программирования', 'Максимальная простота синтаксиса'),
    ('За счет чего обеспечивается кроссплатформенность?', 'Байт-кода и JVM', 'Использования JIT-компилятора', 'Сборщика мусора', 'Строгой типизации'),
    ('Какие преимущества у java?', 'Автоматическое управление памятью, богатая библиотека, безопасность', 'Высокая скорость выполнения', 'Отсутствие необходимости компиляции', 'Низкое потребление ресурсов'),
    ('Какие недостатки у java?', 'Высокое потребление памяти, относительно низкая скорость выполнения', 'Отсутствие графического интерфейса', 'Не поддерживает множественное наследование', 'Невозможно использовать в embedded системах'),
    ('Что такое JDK? Что в него входит?', 'JRE + инструменты разработчика: javac, jar, javadoc и др.', 'Только виртуальная машина JVM', 'Только среда выполнения', 'Компилятор C++'),
    ('Что такое JRE? Что в него входит?', 'JVM + библиотеки классов Java', 'Только JDK', 'Только JIT-компилятор', 'Только сборщик мусора'),
    ('Что такое исключения?', 'Механизм обработки ошибок времени выполнения', 'События операционной системы', 'Специальные виды переменных', 'Асинхронные сигналы'),
    ('Что такое JVM?', 'Виртуальная машина, выполняющая Java-байт-код', 'Среда разработки', 'Система управления БД', 'Компилятор Java в машинный код'),
    ('Что такое byte code?', 'Промежуточный код, исполняемый JVM', 'Исходный код на Java', 'Машинный код для процессора', 'Код после JIT-оптимизации'),
    ('Что такое загрузчик классов (classloader)?', 'Подсистема JVM, загружающая классы в runtime', 'Компилятор исходного кода', 'Средство отладки', 'Менеджер памяти JVM'),
    ('Что такое JIT?', 'Компилятор, переводящий байт-код в машинный код во время выполнения', 'Система управления потоками', 'Сборщик мусора', 'Формат хранения данных'),
    ('Что такое сборщик мусора? (Garbage collector)', 'Автоматическое освобождение неиспользуемой памяти', 'Ручное управление памятью', 'Очистка кэша процессора', 'Управление стеком вызовов'),
    ('Виды ссылок в Java', 'Strong, Soft, Weak, Phantom', 'Public, Private, Protected, Default', 'Direct, Indirect, Circular, Null', 'Local, Global, Static, Final'),
    ('Stack и Heap', 'Stack — для локальных переменных, Heap — для объектов', 'Stack — для объектов, Heap — для примитивов', 'Stack — временный файл, Heap — ОЗУ', 'Heap — очередь, Stack — дерево'),
    ('Какие виды классов есть в java?', 'Обычные, абстрактные, финальные, статические (вложенные)', 'Только обычные и интерфейсы', 'Динамические и статические (top-level)', 'Виртуальные и реальные'),
    ('Какие примитивные типы данных есть в Java? Вопрос чтобы отсеить дурака', 'byte, short, int, long, float, double, char, boolean', 'array, string, object', 'list, map, set', 'date, time, datetime'),
    ('Что такое char?', 'Тип данных для хранения одного символа Unicode', 'Целое число без знака', 'Строка из одного символа', 'Булево значение'),
    ('Сколько памяти занимает boolean?', '1 байт (реализация зависит от JVM)', '1 бит', '4 байта', 'Не определено стандартом'),
    ('Что такое классы-обертки?', 'Классы, представляющие примитивные типы в виде объектов', 'Типы данных для работы с файлами', 'Интерфейсы для коллекций', 'Синглтон-классы'),
    ('Что такое автоупаковка и автораспаковка?', 'Автоматическое преобразование между примитивами и обёртками', 'Преобразование строк в числа', 'Работа с generics', 'Механизм сериализации'),
    ('Что такое явное и неявное приведение типов? В каких случаях в java нужно использовать явное приведение?', 'Неявное — автоматически, явное — при потере точности', 'Неявное только для строк', 'Явное всегда требуется для чисел', 'Неявное невозможно в Java'),
    ('Что такое пул интов?', 'Кэшированные значения Integer от -128 до 127', 'Пул примитивных массивов', 'Контейнер для int[]', 'Очередь задач с приоритетом'),
    ('Какие нюансы у строк в Java?', 'Неизменяемость, пул строк, безопасность', 'Поддерживают изменение через методы', 'Создаются без new по умолчанию', 'Могут быть null в switch'),
    ('Что такое пул строк?', 'Область памяти для хранения уникальных строк', 'Стандартная очередь строк', 'Хранилище временных строк', 'Буфер символов'),
    ('Почему не рекомендуется изменять строки в цикле? Что рекомендуется использовать?', 'Постоянное создание новых объектов; StringBuilder', 'Высокая скорость операций', 'Нельзя использовать в многопоточной среде', 'StringBuilder требует много памяти'),
    ('Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?', 'Сузить уровень доступа нельзя, но можно вернуть подтип', 'Можно сузить доступ', 'Всегда должен быть один уровень доступа', 'Тип возврата должен быть тот же'),
    ('"Есть класс Point{int x, y;}. Почему хэш-код в виде 31 * x + y предпочтительнее чем x + y?"', 'Уменьшает коллизии из-за перестановок', 'Это оптимизация для float', 'Для лучшей читаемости кода', 'Это требование JavaBeans'),
    ('Почему строки не рекомендуется использовать для хранения паролей?', 'Неизменны, остаются в памяти долго', 'Занимают много места', 'Медленно работают', 'Не поддерживают шифрование'),
    ('Почему String неизменяемый и финализированный класс?', 'Для безопасности и кэширования', 'Для поддержки многопоточности', 'По историческим причинам', 'Для работы с JNI'),
    ('Почему строка является популярным ключом в HashMap в Java?', 'Неизменна и хорошо реализует hashCode()', 'Поддерживает null', 'Лениво вычисляется', 'Не может содержать спецсимволы'),
    ('Что делает метод intern() в классе String?', 'Добавляет строку в пул или возвращает существующую', 'Шифрует строку', 'Удаляет пробелы', 'Сериализует строку'),
    ('Можно ли использовать строки в конструкции switch?', 'Да, начиная с Java 7', 'Нет, только enum', 'Только в Java 17+', 'Только final переменные'),
    ('"Какая основная разница между String, StringBuffer, StringBuilder?"', 'String — неизменна, StringBuffer — потокобезопасный, StringBuilder — быстрый', 'String — потокобезопасный', 'StringBuffer — неизменен', 'StringBuilder не поддерживает append'),
    ('Существуют ли в java многомерные массивы?', 'Да, это массивы массивов', 'Нет, только одномерные', 'Только двумерные', 'Поддерживаются с Java 8+'),
    ('Какими значениями инициируются переменные по умолчанию?', '0, false, null', 'null для всех типов', 'Произвольные значения', 'true для boolean'),
    ('Что такое сигнатура метода?', 'Имя метода и список параметров', 'Возвращаемое значение и имя', 'Модификатор доступа и тип', 'Аннотации и параметры'),
    ('Расскажите про метод main', 'public static void main(String[] args)', 'private static void main()', 'public void main()', 'public static int main()'),
    ('"Каким образом переменные передаются в методы, по значению или по ссылке? Очень важный вопрос, часто используется для проверки на дурака"', 'По значению, включая ссылки на объекты', 'По ссылке для объектов', 'По ссылке для примитивов', 'По значению только для примитивов'),
    ('Расскажите про вложенные классы. В каких случаях они применяются?', 'Для логической группировки классов, повышения инкапсуляции', 'Только для создания UI', 'Используются исключительно в интерфейсах', 'Не поддерживают доступ к внешним переменным'),
    ('- Что такое «локальный класс»? Каковы его особенности?', 'Объявлен внутри метода, имеет доступ к final-переменным', 'Может быть объявлен в любом месте кода', 'Поддерживает статические поля', 'Имеет модификатор public по умолчанию'),
    ('Что такое «анонимные классы»? Где они применяются?', 'Классы без имени, часто используются для реализации слушателей событий', 'Используются только в GUI', 'Требуют обязательного наследования от класса Object', 'Могут содержать только один метод'),
    ('- Каким образом из вложенного класса получить доступ к полю внешнего класса?', 'Через ссылку на внешний класс, например OuterClass.this.field', 'Через static-метод', 'Через reflection', 'Невозможно без дополнительных параметров'),
    ('Что такое перечисления (enum)?', 'Тип данных, представляющий набор именованных констант', 'Специальный вид примитивного типа', 'Альтернатива массивам', 'Классы с одним методом'),
    ('Что такое дефолтные методы интерфейсов? Для чего они нужны?', 'Позволяют добавлять реализацию по умолчанию в интерфейсы', 'Для работы с generics', 'Для замены абстрактных классов', 'Для создания финальных методов'),
    ('Как проблема ромбовидного наследования решена в java?', 'Правило: при совпадении default-методов нужно явно указать реализацию', 'Запрещено множественное наследование', 'Используется композиция вместо наследования', 'Проблема не решена'),
    ('Что такое конструктор по умолчанию?', 'Без параметров, генерируется автоматически если не задан других', 'Статический конструктор', 'Финальный метод', 'Метод с возвращаемым типом void'),
    ('Могут ли быть приватные конструкторы? Для чего они нужны?', 'Да, для ограничения создания экземпляров, например в Singleton', 'Нет, запрещено синтаксисом', 'Только для статических классов', 'Только для вызова через reflection'),
    ('Расскажите про классы-загрузчики и про динамическую загрузку классов.', 'ClassLoader и метод Class.forName()', 'JIT-компилятор', 'Сборщик мусора', 'Reflection API'),
    ('"Чем отличаются конструкторы по-умолчанию, конструктор копирования и конструктор с параметрами?"', 'По количеству и наличию параметров', 'По возвращаемому типу', 'По модификаторам доступа', 'По аннотациям'),
    ('Какие модификаторы доступа есть в Java? Какие применимы к классам?', 'public, protected, private, default; к классам — public и default', 'public, internal, private', 'protected, private, sealed', 'private, package-private, module-private'),
    ('Что означает модификатор static?', 'Принадлежит классу, а не экземпляру', 'Не может быть изменён', 'Ограничивает доступ из других пакетов', 'Указывает на потокобезопасность'),
    ('Может ли статический метод быть переопределён или перегружен', 'Перегружен может, переопределён — нет', 'Переопределён может', 'Только в абстрактных классах', 'Только в интерфейсах'),
    ('Могут ли нестатические методы перегружать статические?', 'Нет, это разные категории', 'Да, если совпадают параметры', 'Только в подклассах', 'Только с аннотацией @Override'),
    ('Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы (throws и тп)?', 'Можно сузить уровень доступа, добавить throws подтипов', 'Можно расширить уровень доступа', 'Можно изменить имя метода', 'Можно изменить возвращаемый тип произвольно'),
    ('Могут ли классы быть статическими?', 'Да, только вложенные', 'Да, все классы по умолчанию статические', 'Нет, только методы', 'Только абстрактные классы'),
    ('Что означает модификатор final? К чему он может быть применим?', 'Неизменность: к переменным, методам, классам', 'Только к примитивам', 'Только к коллекциям', 'Только к полям'),
    ('Что такое абстрактные классы? Чем они отличаются от обычных?', 'Не могут быть инстанцированы, могут содержать абстрактные методы', 'Это интерфейсы с реализацией', 'Это финальные классы', 'Это классы без методов'),
    ('Может ли быть абстрактный класс без абстрактных методов?', 'Да, для предотвращения создания экземпляров', 'Нет, это синтаксическая ошибка', 'Только в JDK < 8', 'Только в интерфейсах'),
    ('Могут ли быть конструкторы у абстрактных классов? Для чего они нужны?', 'Да, для инициализации полей при наследовании', 'Нет, запрещено синтаксисом', 'Только если есть метод main()', 'Только в статических классах'),
    ('Что такое интерфейсы? Какие модификаторы по умолчанию имеют поля и методы интерфейсов?', 'Поля: public static final; методы: public abstract', 'Поля: private; методы: protected', 'Поля: public; методы: default', 'Поля: static; методы: final'),
    ('"Чем интерфейсы отличаются от абстрактных классов? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?"', 'Интерфейсы — множественное поведение, абстрактные классы — общая реализация', 'Интерфейсы медленнее', 'Абстрактные классы не поддерживают наследование', 'Интерфейсы требуют меньше памяти'),
    ('Может ли один интерфейс наследоваться от другого? От двух других?', 'Да, в Java разрешено множественное наследование интерфейсов', 'Нет, только одно наследование', 'Только через композицию', 'Только с дефолтными методами'),
    ('Как решается проблема ромбовидного наследования при наследовании интерфейсов при наличии default методов?', 'Разработчик должен явно указать реализацию метода', 'JVM автоматически выбирает первую реализацию', 'Проблема не решена', 'Используется механизм исключений'),
    ('Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?', 'Сначала родительский конструктор, затем дочерний, потом блоки', 'Сначала дочерний, потом родительский', 'Без учета иерархии', 'Блоки выполняются до всех конструкторов'),
    ('Зачем нужны и какие бывают блоки инициализации?', 'Для инициализации полей, статические и нестатические', 'Только для статических данных', 'Для работы с многопоточностью', 'Для сериализации объектов'),
    ('Для чего в Java используются статические блоки инициализации?', 'Для инициализации статических полей', 'Для создания новых экземпляров', 'Для работы с коллекциями', 'Для обработки исключений'),
    ('"Что произойдет, если в блоке инициализации возникнет исключительная ситуация?"', 'Выбросится ExceptionInInitializerError', 'Игнорируется', 'Вызовется finally', 'Остановится JVM'),
    ('Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?', 'ExceptionInInitializerError', 'NullPointerException', 'ClassNotFoundException', 'IOException'),
    ('Что такое класс Object?', 'Базовый класс для всех объектов в Java', 'Класс для примитивов', 'Класс для работы с файлами', 'Класс для коллекций'),
    ('Какие методы есть у класса Object (перечислить все)? Что они делают?', 'equals(), hashCode(), toString(), getClass(), notify(), wait(), finalize()', 'only equals() and hashCode()', 'many stream methods', 'only static methods'),
    ('Расскажите про equals и hashcode', 'equals сравнивает объекты, hashCode используется для хэширования', 'equals работает быстрее hashCode', 'hashCode всегда уникален', 'equals может работать без hashCode'),
    ('"Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode()?"', 'Изменяемые поля лучше не использовать', 'Любые поля можно использовать', 'Только статические поля', 'Только примитивные типы'),
    ('Могут ли у разных объектов быть одинаковые hashCode()?', 'Да, коллизии возможны', 'Нет, всегда уникальны', 'Только у String', 'Только у чисел'),
    ('Чем a.getClass().equals(A.class) отличается от a instanceOf A.class', 'getClass() проверяет точный тип, instanceOf — иерархию', 'getClass() работает быстрее', 'instanceOf нельзя переопределить', 'getClass() не поддерживает null'),
    ('Каким образом реализованы методы hashCode() и equals() в классе Object?', 'hashCode() — адрес в памяти, equals() — ссылочное сравнение', 'hashCode() — случайное число', 'equals() по содержимому', 'hashCode() не поддерживает null'),
    ('Зачем нужен equals(). Чем он отличается от операции ==?', 'equals() сравнивает логическое равенство, == — ссылки', 'equals() медленнее', '== всегда true для String', 'equals() не поддерживает null'),
    ('Правила переопределения equals()', 'Рефлексивность, симметричность, транзитивность, согласованность, не-null', 'Можно менять параметры', 'Всегда должен возвращать true', 'Не должен вызываться'),
    ('"Что будет, если переопределить equals() не переопределяя hashCode()? Какие могут возникнуть проблемы?"', 'Объекты будут некорректно работать в HashMap', 'equals() перестанет работать', 'Производительность улучшится', 'Ошибка компиляции'),
    ('Какой контракт между hashCode() и equals()?', 'Если equals true, то hashCode должны совпадать', 'hashCode может быть любым', 'hashCode всегда уникален', 'equals не зависит от hashCode'),
    ('Для чего нужен метод hashCode()?', 'Для эффективного хранения в хэш-коллекциях', 'Для работы с потоками', 'Для сериализации', 'Для определения размера объекта'),
    ('Правила переопределения метода hashcode()', 'Должен быть согласован с equals(), стабильным и равномерно распределять значения', 'Можно возвращать 0', 'Может изменяться со временем', 'Должен быть случайным'),
    ('Почему нельзя реализовать hashcode() который будет гарантированно уникальным для каждого объекта?', 'Ограничения памяти и диапазона int', 'Мало памяти', 'Java не позволяет', 'Это противоречит спецификации'),
    ('Опишите иерархию исключений', 'Throwable -> Error / Exception -> RuntimeException', 'Throwable -> IOException / SQLException', 'Throwable -> Checked / Unchecked', 'Throwable -> Fatal / NonFatal'),
    ('Расскажите про обрабатываемые и необрабатываемые исключения', 'Checked (Exception) и Unchecked (RuntimeException)', 'Все исключения обрабатываются', 'Unchecked всегда фатальны', 'Checked — только для IO'),
    ('Можно ли обработать необрабатываемые исключения?', 'Да, но не рекомендуется', 'Нет, это невозможно', 'Только через try-finally', 'Только через throw'),
    ('Какой оператор позволяет принудительно выбросить исключение?', 'throw', 'throws', 'try', 'catch'),
    ('О чем говорит ключевое слово throws?', 'Метод может выбросить указанное исключение', 'Метод его обрабатывает', 'Указывает уровень доступа', 'Обязательно к использованию'),
    ('Как создать собственное («пользовательское») исключение?', 'Наследование от Exception или RuntimeException', 'Только через RuntimeException', 'Через @interface', 'Через аннотацию'),
    ('Расскажите про механизм обработки исключений в java (Try-catch-finally)', 'try — код, catch — обработка, finally — освобождение ресурсов', 'finally не обязателен', 'catch не может быть несколько', 'try не может быть без catch'),
    ('Возможно ли использование блока try-finally (без catch)?', 'Да, для гарантии выполнения finally', 'Нет, это ошибка', 'Только в многопоточной среде', 'Только в try-with-resources'),
    ('Может ли один блок catch отлавливать сразу несколько исключений?', 'Да, начиная с Java 7 через |', 'Нет, только одно исключение', 'Только через instanceof', 'Только через try-finally'),
    ('"Всегда ли выполняется блок finally? Существуют ли ситуации, когда блок finally не будет выполнен?"', 'Нет, если JVM завершится аварийно или вызван System.exit()', 'Всегда выполняется', 'Только при исключении', 'Только без исключений'),
    ('"Может ли метод main() выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?"', 'Да, JVM завершится с выводом стека', 'main не может выбрасывать', 'Обработает catch', 'main не имеет finally'),
    ('В каком порядке следует обрабатывать исключения в catch блоках?', 'От более конкретных к общим', 'От общих к конкретным', 'По алфавиту', 'В любом порядке'),
    ('Что такое механизм try-with-resources?', 'Автоматическое закрытие ресурсов, реализующих AutoCloseable', 'Только для файлов', 'Работает без finally', 'Только в Java 7+'),
    ('Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из блока finally?', 'Будет выброшено исключение из catch, finally добавится как suppressed', 'Будет только из finally', 'Оба будут потеряны', 'Ни одно не будет'),
    ('Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из метода close() при использовании try-with-resources?', 'Первое исключение будет основным, второе — suppressed', 'Будет только из close()', 'Оба будут игнорированы', 'Только из catch'),
    ('Что такое сериализация и как она реализована в Java?', 'Процесс преобразования объекта в байты для сохранения или передачи', 'Работает только с примитивами', 'Требует наличия конструктора', 'Поддерживается всеми классами'),
    ('Для чего нужна сериализация?', 'Для сохранения состояния объекта или передачи по сети', 'Для шифрования', 'Для оптимизации памяти', 'Для работы с GUI'),
    ('Опишите процесс сериализации/десериализации с использованием Serializable.', 'writeObject() / readObject()', 'Только через JSON', 'Только через XML', 'Только через YAML'),
    ('Как изменить стандартное поведение сериализации/десериализации?', 'Переопределить writeObject() и readObject()', 'Добавить аннотации', 'Использовать Externalizable', 'Использовать transient'),
    ('Какие поля не будут сериализованы при сериализации? Будет ли сериализовано final поле?', 'transient поля, final сериализуется', 'final не сериализуется', 'static поля не сериализуются', 'Все поля сериализуются'),
    ('Как создать собственный протокол сериализации?', 'Реализовать Externalizable и написать свои методы', 'Использовать только Serializable', 'Использовать JSON', 'Использовать XML'),
    ('Какая роль поля serialVersionUID в сериализации?', 'Уникальный идентификатор версии класса', 'ID сессии', 'Хэш-код объекта', 'Идентификатор JVM'),
    ('Когда стоит изменять значение поля serialVersionUID?', 'При изменениях, влияющих на совместимость', 'При каждом изменении класса', 'Только при удалении полей', 'Только при добавлении методов'),
    ('В чем проблема сериализации Singleton?', 'При десериализации создаётся новый экземпляр', 'Singleton нельзя сериализовать', 'Serializable не поддерживается', 'final поля теряются'),
    ('Расскажите про клонирование объектов.', 'clone() из Object, глубокое и поверхностное', 'Только через конструктор', 'Только через сериализацию', 'Только через reflection'),
    ('Что представляют собой дженерики в Java?', 'Обобщенные типы, обеспечивающие типобезопасность', 'Макросы', 'Функции', 'Классы без методов'),
    ('Какова цель использования дженериков?', 'Типобезопасность и повторное использование кода', 'Ускорение выполнения', 'Уменьшение потребления памяти', 'Поддержка многопоточности'),
    ('Что такое сырые типы (raw type)?', 'Типы без параметров дженериков', 'Типы с явными параметрами', 'Только примитивные типы', 'Только строки'),
    ('Что такое стирание типов?', 'Информация о типах удаляется на этапе компиляции', 'Информация сохраняется во время выполнения', 'Используется только в generics', 'Используется только в массивах'),
    ('Как работают вайлдкарды в контексте дженериков?', 'Позволяют использовать неизвестные типы с ограничениями', 'Запрещают использование дженериков', 'Работают только с примитивами', 'Работают только со строками'),
    ('Объясните принцип PECS в контексте дженериков.', 'Producer Extends, Consumer Super', 'Producer Super, Consumer Extends', 'Producer Only, Consumer Many', 'Producer Many, Consumer One'),
    ('"Что означает термин ""коллекция"" в Java?"', 'Группа элементов, представленная через Collection API', 'Массив данных', 'Структура БД', 'Набор Map и Set'),
    ('Расскажите про иерархию коллекций в Java.', 'Collection -> Set, List, Queue; Map отдельно', 'Set и List родители', 'Queue наследуется от Map', 'Map наследуется от Collection'),
    ('"Почему Map не является подтипом Collection, в отличие от List и Set?"', 'Map хранит пары ключ-значение, Collection — одиночные элементы', 'Map старше', 'Map работает быстрее', 'Map не поддерживает null'),
    ('Какие различия между java.util.Collection и java.util.Collections?', 'Collection — интерфейс, Collections — утилитный класс', 'Collections — набор', 'Collection — Map', 'Collections — потокобезопасный'),
    ('Как отличается итератор с fail-fast итератора с fail-safe поведением? Приведите примеры.', 'Fail-fast выбрасывает исключение при изменении, fail-safe работает с копией', 'Fail-safe всегда медленнее', 'Fail-fast работает с копией', 'Fail-safe не существует'),
    ('В чем разница между Enumeration и Iterator?', 'Iterator имеет более современный API и remove()', 'Enumeration быстрее', 'Iterator работает только с List', 'Enumeration безопаснее'),
    ('"Как связаны между собой интерфейсы Iterable, Iterator и ""for-each""?"', 'Iterable предоставляет Iterator для for-each', 'Iterator использует for-each', 'Iterable реализует Iterator', 'for-each не связан ни с кем'),
    ('"Можно ли удалить элемент, итерируясь по ArrayList? Какая исключительная ситуация может возникнуть?"', 'Да, через Iterator.remove(), ConcurrentModificationException при прямом удалении', 'Нельзя удалять вообще', 'NoSuchElementException всегда', 'IndexOutOfBoundsException всегда'),
    ('Как ведет себя коллекция при использовании метода iterator.remove()?', 'Удаляет текущий элемент без ConcurrentModificationException', 'Выбрасывает исключение', 'Добавляет элемент обратно', 'Не влияет на коллекцию'),
    ('Какие существуют реализации интерфейса Map в Java?', 'HashMap, TreeMap, LinkedHashMap, Hashtable', 'HashSet, TreeSet, LinkedHashSet', 'ArrayList, LinkedList', 'ConcurrentQueue, BlockingQueue'),
    ('"Как устроена HashMap, и какова сложность ее основных операций (до Java 8 и после)? Объясните принцип корзин."', 'Массив бакетов; до Java 8 — O(n) при коллизиях, после — O(log n)', 'Хэширование; O(1)', 'Сложность всегда O(1)', 'Только списки без оптимизации'),
    ('Для чего предназначена аннотация @FunctionalInterface?', 'Указывает, что интерфейс должен содержать ровно один абстрактный метод', 'Запрещает наследование', 'Обязует реализацию методов', 'Не имеет значения'),
    ('"Как устроена TreeMap, и какова сложность ее основных операций?"', 'Красно-черное дерево; O(log n)', 'Хэширование; O(1)', 'Массив; O(1)', 'Список; O(n)'),
    ('"Как ведет себя HashMap, если пытаться добавить в нее два элемента с одинаковыми hashCode(), но с различающимися equals()?"', 'Добавляются оба элемента в одну бакет-связку', 'Первый элемент перезаписывается', 'Вызывается исключение', 'Игнорируется второй элемент'),
    ('"Как поведет себя HashMap, если ключ, у которого определены некорректно equals и hashCode, будет добавлен?"', 'Не сможет найти/удалить этот ключ', 'Работает нормально', 'Выбросит исключение', 'Автоматически исправит методы'),
    ('"Возможно ли, что HashMap превратится в список, даже если ключи имеют разные hashCode()?"', 'Нет, только при совпадении хэшей', 'Да, всегда', 'Только при большом количестве записей', 'Только при маленькой ёмкости'),
    ('Почему нельзя использовать byte[] в качестве ключа в HashMap?', 'Поскольку hash вычисляется по ссылке, а не содержимому', 'byte[] слишком маленький тип', 'Тип byte[] запрещен', 'byte[] не поддерживает equals()'),
    ('"Сможет ли работать HashMap, если все добавляемые ключи будут иметь одинаковый hashCode?"', 'Да, но производительность упадет до O(n)', 'Нет, это ошибка', 'Только для String', 'Только для примитивов'),
    ('"Каково худшее время выполнения метода get(key) для ключа, отсутствующего в HashMap?"', 'O(n), если все ключи в одном бакете', 'O(1)', 'O(log n)', 'O(n²)'),
    ('"Каково худшее время выполнения метода get(key) для ключа, присутствующего в HashMap?"', 'O(n), если все ключи в одном бакете', 'O(1)', 'O(log n)', 'O(n²)'),
    ('Что такое rehashing?', 'Увеличение размера массива бакетов и перераспределение элементов', 'Очистка памяти', 'Сборка мусора', 'Загрузка классов'),
    ('При каких условиях список в бакете перерождается в красно-черное дерево?', 'При длине списка >= TREEIFY_THRESHOLD (по умолчанию 8)', 'При длине 1', 'При любом количестве коллизий', 'При использовании только int'),
    ('Как Set отличается от Map?', 'Set хранит уникальные элементы, Map — пары ключ-значение', 'Set работает быстрее', 'Map старше', 'Set не поддерживает null'),
    ('Как Set отличается от List?', 'Set — уникальные элементы, List — упорядоченные с возможными дубликатами', 'List работает быстрее', 'Set не поддерживает индексы', 'List не поддерживает null'),
    ('Объясните интерфейс Set в Java.', 'Интерфейс, представляющий набор уникальных элементов', 'Подтип Map', 'Интерфейс для очередей', 'Интерфейс для потоков'),
    ('Расскажите о реализациях интерфейса Set.', 'HashSet, TreeSet, LinkedHashSet', 'ArrayList, LinkedList', 'HashMap, TreeMap', 'Stack, Queue'),
    ('Каковы отличия между TreeSet и HashSet?', 'TreeSet — отсортирован, HashSet — произвольный порядок', 'HashSet быстрее', 'TreeSet использует хэширование', 'HashSet не поддерживает Comparable'),
    ('В чем разница между LinkedHashSet и HashSet?', 'LinkedHashSet сохраняет порядок вставки', 'HashSet работает быстрее', 'LinkedHashSet старше', 'HashSet не поддерживает null'),
    ('"Как изменится TreeSet, если добавлять элементы в него по возрастанию?"', 'Останется отсортированным, но структура не меняется', 'Производительность улучшится', 'Станет LinkedList', 'Станет HashMap'),
    ('"Как устроен HashSet, и какова сложность его основных операций? Объясните принцип корзин."', 'На основе HashMap; O(1) среднее, O(n) при коллизиях', 'На основе ArrayList', 'На основе LinkedList', 'На основе TreeMap'),
    ('"Как устроен LinkedHashSet, и какова сложность его основных операций?"', 'На основе LinkedHashMap; O(1) + сохранение порядка', 'На основе TreeSet', 'На основе ArrayList', 'На основе LinkedList'),
    ('Объясните интерфейс List в Java.', 'Упорядоченная коллекция с доступом по индексу', 'Неупорядоченная коллекция', 'Интерфейс для очередей', 'Интерфейс для Map'),
    ('"Как устроен ArrayList, и какова сложность его основных операций?"', 'Массив; get — O(1), add — O(1) амортизированное, insert/delete — O(n)', 'Связный список', 'Дерево', 'Хэш-таблица'),
    ('Что лучше использовать ArrayList или LinkedList?', 'ArrayList для случайного доступа, LinkedList для частых вставок/удалений', 'LinkedList всегда лучше', 'ArrayList не рекомендуется', 'LinkedList устарел'),
    ('"Оцените объем памяти, необходимый для хранения одного примитива типа byte в LinkedList."', '~40 байт (узел с ссылками)', '1 байт', '4 байта', '8 байт'),
    ('"Оцените объем памяти, необходимый для хранения одного примитива типа byte в ArrayList."', '~16 байт (объект Byte)', '1 байт', '4 байта', '8 байт'),
    ('Что такое Queue в Java?', 'Интерфейс для FIFO-очереди', 'Интерфейс для LIFO-очереди', 'Интерфейс для потоков', 'Интерфейс для файлов'),
    ('"Что представляет собой Deque, и в чем разница между Deque и Queue?"', 'Deque — двусторонняя очередь, Queue — односторонняя', 'Deque медленнее', 'Queue старше', 'Deque не поддерживает null'),
    ('Приведите пример реализации Deque в Java.', 'ArrayDeque', 'ArrayList', 'LinkedList', 'HashMap'),
    ('Какую коллекцию можно использовать для реализации FIFO?', 'Queue или LinkedList', 'Stack', 'HashSet', 'TreeMap'),
    ('Какую коллекцию можно использовать для реализации LIFO?', 'Deque или Stack', 'Queue', 'HashSet', 'TreeMap'),
    ('Начальная емкость коллекций?', 'ArrayList — 10, HashMap — 16, HashSet — 16', 'ArrayList — 16', 'HashMap — 10', 'HashSet — 1'),
    ('Что такое функциональный интерфейс, и как он используется в Java?', 'Интерфейс с одним абстрактным методом, используется в лямбдах', 'Интерфейс без методов', 'Интерфейс с несколькими методами', 'Интерфейс для работы с файлами'),
    ('Какие встроенные функциональные интерфейсы вы знаете?', 'Function, Predicate, Consumer, Supplier', 'List, Set, Map', 'Thread, Runnable', 'Object, Cloneable'),
    ('Что такое ссылка на метод в контексте лямбда-выражений?', 'Сокращенная запись лямбды, указывающая на существующий метод', 'Ссылка на класс', 'Ссылка на конструктор', 'Адрес памяти метода'),
    ('Что представляет собой лямбда-выражение, и чем его можно заменить?', 'Функциональный объект, заменяет анонимные классы', 'Метод', 'Конструктор', 'Поле'),
    ('Что такое Stream API, и для чего используются стримы?', 'API для декларативной обработки последовательностей данных', 'Для работы с файлами', 'Для многопоточности', 'Для GUI'),
    ('Почему Stream называется ленивым?', 'Промежуточные операции выполняются только при наличии терминальной', 'Stream всегда медленный', 'Stream не поддерживает параллелизм', 'Stream работает только с null'),
    ('Какие способы создания стрима вы знаете?', 'Stream.of(), collection.stream(), Files.lines()', 'Только через массивы', 'Только через строки', 'Только через List'),
    ('Как можно создать стрим из коллекции?', 'collection.stream()', 'new Stream()', 'stream.of(collection)', 'collection.toStream()'),
    ('Какие промежуточные операции со стримами вы знаете?', 'map(), filter(), sorted()', 'forEach()', 'collect()', 'reduce()'),
    ('В чем разница между методами map() и flatMap() в стримах?', 'map — преобразует элементы, flatMap — объединяет потоки', 'map работает быстрее', 'flatMap не принимает функции', 'map не поддерживает null'),
    ('Какие терминальные операции со стримами вы знаете?', 'collect(), forEach(), count()', 'filter()', 'map()', 'sorted()'),
    ('Объясните метод collect() в контексте стримов.', 'Преобразует стрим в коллекцию или другую структуру', 'Только для фильтрации', 'Только для подсчета', 'Только для вывода'),
    ('Объясните метод reduce() в контексте стримов.', 'Сводит элементы к одному значению', 'Только для чисел', 'Только для строк', 'Не поддерживает null'),
    ('Расскажите о классе Collectors и его методах в контексте стримов.', 'Группирует, суммирует, собирает в коллекции', 'Только для строк', 'Только для чисел', 'Только для файлов'),
    ('Что такое параллельная обработка в Java 8?', 'Работа с данными через ForkJoinPool', 'Однопоточная обработка', 'Работа с GUI', 'Работа с файлами'),
    ('Что представляют собой IntStream и DoubleStream?', 'Специализированные стримы для примитивов', 'Стримы для строк', 'Стримы для файлов', 'Стримы для Map'),
    ('Какие нововведения появились в Java 8?', 'Лямбды, Stream API, новые даты, default-методы', 'Новые типы данных', 'Новая JVM', 'Новые исключения'),
    ('Какие новые классы для работы с датами появились в Java 8?', 'LocalDate, LocalDateTime, ZonedDateTime, Instant', 'Date, Calendar', 'Time, Year', 'Month, Day'),
    ('Что представляет собой класс Optional в Java?', 'Обертка для значения, которое может быть null', 'Альтернатива примитивам', 'Класс для работы с коллекциями', 'Механизм сериализации'),
    ('Какой класс появился в Java 8 для кодирования и декодирования данных?', 'Base64', 'Encoder', 'Decoder', 'Coder'),
    ('Как создать кодировщик и декодировщик Base64 в Java?', 'Base64.getEncoder(), Base64.getDecoder()', 'new Base64()', 'new Encoder()', 'new Decoder()'),
    ('Какие дополнительные методы для работы с ассоциативными массивами (maps) появились в Java 8?', 'compute(), merge(), putIfAbsent()', 'add()', 'removeAll()', 'clear()'),
    ('Что такое LocalDateTime в контексте дат и времени?', 'Дата и время без временной зоны', 'Дата с временной зоной', 'Только дата', 'Только время'),
    ('Что представляет собой ZonedDateTime в контексте дат и времени?', 'Дата и время с временной зоной', 'Дата без зоны', 'Только зона', 'Только дата'),
    ('Что такое Instant?', 'Момент во времени в UTC', 'Локальная дата', 'Время с зоной', 'Произвольное время'),
    ('В чем отличие Instant от LocalDateTime?', 'Instant хранит время в UTC, LocalDateTime — в локальной зоне', 'Instant медленнее', 'LocalDateTime точнее', 'Instant устарел'),
    ('Что представляет собой монитор? Как в Java реализован монитор?', 'Механизм синхронизации, связанный с объектом', 'Отдельный класс', 'Интерфейс', 'Пакет java.util.concurrent'),
    ('Чем отличается процесс от потока?', 'Процесс — независимая единица выполнения, поток — внутри процесса', 'Поток всегда один', 'Процесс — это поток', 'Процессы работают медленнее'),
    ('В чем разница между классом Thread и интерфейсом Runnable?', 'Runnable позволяет делиться между потоками, Thread — нет', 'Thread проще', 'Runnable старше', 'Runnable требует больше памяти'),
    ('Что такое синхронизация? Какие методы синхронизации существуют в Java?', 'Контроль доступа к общим ресурсам; synchronized, Lock', 'volatile', 'final', 'static'),
    ('Какое значение имеет ключевое слово synchronized? Где и для каких целей его следует использовать?', 'Обеспечивает потокобезопасность методов и блоков', 'Для оптимизации памяти', 'Для сериализации', 'Для работы с GUI'),
    ('Какой объект является монитором для статического synchronized-метода?', 'Класс (Class.class)', 'Экземпляр объекта', 'this', 'super'),
    ('Какой объект является монитором для нестатического synchronized-метода?', 'Экземпляр объекта (this)', 'Класс', 'null', 'super'),
    ('"Как действуют методы wait(), notify() и notifyAll() в контексте многопоточности?"', 'Управляют состоянием потоков, ждущих на мониторе', 'Останавливают JVM', 'Перезапускают потоки', 'Не влияют на состояние'),
    ('В каких состояниях может находиться поток?', 'NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED', 'ACTIVE, PAUSED', 'STARTED, STOPPED', 'RUNNING, DEAD'),
    ('Что такое семафор? Как его можно реализовать в Java?', 'Счетчик разрешений, через java.util.concurrent.Semaphore', 'Через synchronized', 'Через volatile', 'Через final поля'),
    ('Какое значение имеет ключевое слово volatile? Почему операции с volatile переменными не являются атомарными?', 'Гарантирует видимость изменений между потоками, но не атомарность', 'Делает переменную константой', 'Делает переменную потокобезопасной', 'Ускоряет выполнение'),
    ('Зачем нужны атомарные (Atomic) типы данных? В чем отличие от переменных с ключевым словом volatile?', 'Atomic обеспечивают атомарные операции, volatile — только видимость', 'Atomic медленнее', 'Volatile обеспечивает атомарность', 'Atomic не поддерживаются'),
    ('Что представляют собой демон-потоки? Какова их роль и как создать демон-поток?', 'Потоки фоновой работы, завершающиеся при завершении основных, setDaemon(true)', 'Главные потоки', 'Потоки с высоким приоритетом', 'Потоки с низким приоритетом'),
    ('Что такое приоритет потока? Как он влияет на выполнение потока? Какой приоритет у потоков по умолчанию?', 'Число от 1 до 10, влияет на планирование, по умолчанию 5', 'Влияет на производительность', 'Приоритет не важен', 'По умолчанию 10'),
    ('Как работает метод Thread.join()? Для чего он используется?', 'Приостанавливает текущий поток до завершения целевого', 'Завершает JVM', 'Останавливает все потоки', 'Не влияет на работу'),
    ('В чем разница между методами wait() и sleep()?', 'wait() освобождает монитор, sleep() — нет', 'sleep() вызывается у потока', 'wait() статический', 'sleep() не бросает исключение'),
    ('Можно ли вызвать start() для одного потока дважды?', 'Нет, будет IllegalThreadStateException', 'Да, безопасно', 'Только если поток завершен', 'Только если он не запущен'),
    ('"Как правильно остановить поток? Какие методы .stop(), .interrupt(), .interrupted(), .isInterrupted() используются и для каких целей?"', 'interrupt() сигнализирует о необходимости остановки', '.stop() безопасно', '.interrupted() не влияет', 'Все методы устарели'),
    ('В чем различия между интерфейсами Runnable и Callable?', 'Callable возвращает результат и может выбрасывать исключение', 'Runnable быстрее', 'Callable не поддерживается', 'Runnable не поддерживает параметры'),
    ('Что представляет собой FutureTask?', 'Объект, представляющий асинхронную задачу', 'Пул потоков', 'Блокирующая очередь', 'Финальный класс'),
    ('Что такое deadlock (взаимная блокировка)?', 'Потоки ждут друг друга бесконечно', 'Ошибка компиляции', 'Исключение ввода-вывода', 'Проблема с памятью'),
    ('Что такое livelock? Как он отличается от deadlock?', 'Потоки активно работают, но не продвигаются; в отличие от deadlock не зависают', 'Это то же самое', 'Livelock менее опасен', 'Deadlock всегда приводит к crash'),
    ('Что представляет собой race condition?', 'Неопределённое поведение при одновременном доступе к общему ресурсу', 'Ошибка типизации', 'Проблема с класслоадером', 'Ошибка сериализации'),
    ('Что такое фреймворк fork/join? Какова его роль и назначение?', 'Работа с параллельными задачами через ForkJoinPool', 'Фреймворк для GUI', 'Для работы с файлами', 'Для сериализации'),
    ('Что входит в java.util.concurrent?', 'Коллекции, блокировки, пулы потоков и др.', 'Только Map', 'Только List', 'Только исключения'),
    ('Что такое Executor в контексте пакета java.util.concurrent?', 'Интерфейс для управления выполнением задач', 'Класс для создания GUI', 'Интерфейс для работы с БД', 'Утилитный класс'),
    ('Как создать и использовать пул потоков с помощью ExecutorService?', 'Executors.newFixedThreadPool(), submit()', 'new Thread().start()', 'Executor.start()', 'ThreadGroup.create()'),
    ('Как использовать CountDownLatch для ожидания завершения определенного числа задач?', 'await() и countDown()', 'wait() и notify()', 'sleep()', 'join()'),
    ('Что представляет собой CyclicBarrier и в каких сценариях он может быть полезен?', 'Барьер, позволяющий группе потоков ждать друг друга', 'Для работы с файлами', 'Для GUI', 'Для работы с сетью'),
    ('Что представляют собой классы ReentrantLock и ReentrantReadWriteLock?', 'Расширяемые реализации Lock и ReadWriteLock', 'Статические методы', 'Финальные классы', 'Интерфейсы'),
    ('Как работает Phaser и для чего может быть использован?', 'Для синхронизации нескольких фаз выполнения', 'Для работы с базами данных', 'Для работы с файлами', 'Для GUI'),
    ('Что представляет собой ConcurrentHashMap и где используется?', 'Потокобезопасная хэш-таблица', 'Обертка над HashMap', 'Не поддерживает null', 'Реализация Set'),
    ('Что представляет собой ThreadLocal и где используется?', 'Переменная, уникальная для каждого потока', 'Глобальная переменная', 'Статическая переменная', 'Локальная переменная'),
    ('Как связаны Stream API и ForkJoinPool? Что представляют из себя?', 'Stream использует ForkJoinPool для параллельной обработки', 'ForkJoinPool не связан со стримами', 'Stream — это ForkJoinPool', 'ForkJoinPool заменяет Stream'),
    ('Что такое Java Memory Model?', 'Модель взаимодействия между потоками и памятью', 'Модель работы с диском', 'Модель управления версиями', 'Модель работы с исключениями'),
    ('"Что такое reordering, happens-before и область видимости?"', 'Правила порядка исполнения и видимости изменений между потоками', 'Правила для GC', 'Правила для JIT', 'Правила для JRE'),
    ('Что такое ORM? Что такое JPA? Что такое Hibernate?', 'ORM — отображение объектов в БД, JPA — стандарт, Hibernate — реализация', 'ORM — СУБД', 'JPA — интерфейс, Hibernate — класс', 'Hibernate — фреймворк для GUI'),
    ('Что такое EntityManager?', 'Интерфейс для управления жизненным циклом Entity', 'Класс для работы с файлами', 'Интерфейс для работы с HTTP', 'Утилитный класс'),
    ('Каким условиям должен удовлетворять класс чтобы являться Entity?', 'Аннотирован @Entity, имеет ID, конструктор по умолчанию', 'Только public поля', 'Только статические методы', 'Только final поля'),
    ('Может ли абстрактный класс быть Entity?', 'Да, если аннотирован как @Entity', 'Нет, только конкретные классы', 'Только final классы', 'Только интерфейсы'),
    ('Может ли Entity класс наследоваться от не Entity классов (non-entity classes)?', 'Да, если они @MappedSuperclass или обычные классы', 'Нет, только от других Entity', 'Только от интерфейсов', 'Только от final классов'),
    ('Может ли Entity класс наследоваться от других Entity классов?', 'Да, с использованием @Inheritance', 'Нет, запрещено', 'Только через интерфейсы', 'Только через композицию'),
    ('Может ли не Entity класс наследоваться от Entity класса?', 'Да, но не может быть сохранён как Entity', 'Нет, это ошибка', 'Только если он final', 'Только если он абстрактный'),
    ('Что такое встраиваемый (Embeddable) класс? Какие требования JPA устанавливает к встраиваемым (Embeddable) классам?', '@Embeddable, без @Entity, с полями', 'Только статические методы', 'Только примитивные типы', 'Только String'),
    ('Что такое Mapped Superclass?', 'Базовый класс для наследования с маппингом полей', 'Обычный класс', 'Интерфейс', 'Финальный класс'),
    ('Какие три типа стратегий наследования мапинга (Inheritance Mapping Strategies) описаны в JPA?', 'SINGLE_TABLE, JOINED, TABLE_PER_CLASS', 'INNER JOIN, LEFT JOIN, RIGHT JOIN', 'UNION, INTERSECT, EXCEPT', 'INHERIT, EXTEND, COPY'),
    ('Как мапятся Enum`ы?', '@Enumerated(EnumType.STRING/ORDINAL)', 'Только через int', 'Только через String', 'Не поддерживаются'),
    ('Как мапятся даты (до java 8 и после)?', 'java.util.Date / LocalDate, @Temporal(TemporalType.DATE|TIME|TIMESTAMP)', 'Только как String', 'Только как long', 'Не поддерживаются'),
    ('Как “смапить” коллекцию примитивов?', '@ElementCollection + List<Wrapper>', 'Только через массивы', 'Только через Set', 'Примитивы нельзя мапить напрямую'),
    ('Какие есть виды связей?', 'One-to-One, One-to-Many, Many-to-One, Many-to-Many', 'Только One-to-One', 'Только Many-to-Many', 'Только Tree'),
    ('Что такое владелец связи?', 'Та сторона, которая управляет связью в БД', 'Любая сторона', 'Только One-to-One', 'Только Many-to-Many'),
    ('Что такое каскады?', 'Перенаправление операций на связанные объекты', 'Автоматическое удаление', 'Автоматическая сериализация', 'Механизм транзакций'),
    ('Что такое orphanRemoval?', 'Автоматическое удаление связанных объектов, потерявших владельца', 'Удаление всех дубликатов', 'Удаление временных данных', 'Удаление кэша'),
    ('Разница между PERSIST и MERGE?', 'PERSIST создает новую запись, MERGE обновляет существующую', 'MERGE всегда добавляет', 'PERSIST работает с detached', 'MERGE не требует ID'),
    ('Какие два типа fetch стратегии в JPA вы знаете?', 'EAGER и LAZY', 'FAST и SLOW', 'ONE и ALL', 'ASYNC и SYNC'),
    ('Какие четыре статуса жизненного цикла Entity объекта (Entity Instance’s Life Cycle) вы можете перечислить?', 'New (Transient), Managed (Persistent), Detached, Removed', 'Alive, Dead, Sleeping, Waiting', 'Created, Updated, Deleted, Merged', 'Active, Inactive, Frozen, Archived'),
    ('Как влияет операция persist на Entity объекты каждого из четырех статусов?', 'Преобразует Transient в Persistent', 'На другие статусы игнорируется', 'Удаляет Detached', 'Обновляет Removed'),
    ('Как влияет операция remove на Entity объекты каждого из четырех статусов?', 'Помечает объект как Removed', 'На Transient — игнорируется', 'На Detached — исключение', 'На Persistent — удаляет'),
    ('Как влияет операция merge на Entity объекты каждого из четырех статусов?', 'Создает новый или обновляет существующий Persistent', 'На Removed — игнорируется', 'На Transient — становится Persistent', 'На Detached — восстанавливается'),
    ('Как влияет операция refresh на Entity объекты каждого из четырех статусов?', 'Обновляет состояние из БД', 'На Transient — игнорируется', 'На Removed — игнорируется', 'На Detached — исключение'),
    ('Как влияет операция detach на Entity объекты каждого из четырех статусов?', 'Переводит в Detached', 'На Transient — игнорируется', 'На Removed — игнорируется', 'На Detached — остается Detached'),
    ('Для чего нужна аннотация Basic?', 'Указывает, что поле должно быть маппировано', 'Для создания индексов', 'Для сериализации', 'Для многопоточности'),
    ('Для чего нужна аннотация Column?', 'Задает параметры столбца в таблице', 'Для связи Many-to-One', 'Для работы с файлами', 'Для работы с JSON'),
    ('Для чего нужна аннотация Access?', 'Определяет способ доступа к полям/методам', 'Для указания модификаторов', 'Для безопасности', 'Для сериализации'),
    ('Для чего нужна аннотация @Cacheable?', 'Включает кэширование результата метода', 'Для работы с файлами', 'Для многопоточности', 'Для сериализации'),
    ('Для чего нужна аннотация @Cache?', 'Управление кэшированием', 'Для работы с файлами', 'Для многопоточности', 'Для сериализации'),
    ('Для чего нужны аннотации @Embedded и @Embeddable?', 'Для встраивания объектов в сущность', 'Для наследования', 'Для связи Many-to-One', 'Для работы с массивами'),
    ('Как смапить составной ключ?', 'Через @EmbeddedId или @IdClass', 'Только через @Id', 'Только через Long', 'Только через String'),
    ('Для чего нужна аннотация ID? Какие @GeneratedValue вы знаете?', 'Определяет первичный ключ; AUTO, IDENTITY, SEQUENCE, TABLE', 'Только AUTO', 'Только IDENTITY', 'Только SEQUENCE'),
    ('Расскажите про аннотации @JoinColumn и @JoinTable? Где и для чего они используются?', 'Определяют внешние ключи и промежуточные таблицы', 'Только для One-to-One', 'Только для Many-to-Many', 'Только для Join'),
    ('"Для чего нужны аннотации @OrderBy и @OrderColumn, чем они отличаются?"', '@OrderBy — логическая сортировка, @OrderColumn — физический порядок в БД', 'Обе одинаковы', '@OrderBy быстрее', '@OrderColumn медленнее'),
    ('Для чего нужна аннотация Transient?', 'Поле не сохраняется в БД', 'Поле шифруется', 'Поле кэшируется', 'Поле сериализуется'),
    ('Какие шесть видов блокировок (lock) описаны в спецификации JPA?', 'NONE, READ, WRITE, OPTIMISTIC, OPTIMISTIC_FORCE_INCREMENT, PESSIMISTIC_READ, PESSIMISTIC_WRITE', 'Только READ', 'Только WRITE', 'Только LOCK'),
    ('Какие два вида кэшей (cache) вы знаете в JPA и для чего они нужны?', 'First Level Cache (EntityManager), Second Level Cache (SessionFactory)', 'Только First Level', 'Только Second Level', 'Третий уровень кэша'),
    ('Как работать с кешем 2 уровня?', 'Включить в persistence.xml и использовать @Cacheable', 'Только через XML', 'Только через аннотации', 'Только через программный API'),
    ('Что такое JPQL/HQL и чем он отличается от SQL?', 'JPQL — язык запросов к сущностям, SQL — к таблицам', 'JPQL медленнее SQL', 'SQL работает только с Hibernate', 'JPQL не поддерживает JOIN'),
    ('Что такое Criteria API и для чего он используется?', 'Построение типобезопасных запросов на Java', 'Для работы с файлами', 'Для сериализации', 'Для многопоточности'),
    ('Расскажите про проблему N+1 Select и путях ее решения.', 'Fetch join, EntityGraph, BatchSize', 'Увеличение памяти', 'Использование List вместо Set', 'Оптимизация GC'),
    ('Что такое Entity Graph', 'Механизм управления загрузкой связанных сущностей', 'График производительности', 'Диаграмма классов', 'Структура БД'),
    ('Можно ли вставить бин в статическое поле? Почему?', 'Нет, Spring не может инжектить в статику', 'Да, через @Autowired', 'Да, через static setter', 'Да, через reflection'),
    ('Расскажите про аннотации @Primary и @Qualifier', '@Primary — приоритетный бин, @Qualifier — выбор по имени/типу', 'Обе работают только с примитивами', '@Primary работает только с @Service', '@Qualifier старше и медленнее'),
    ('Как заинжектить примитив?', 'Через @Value или @Autowired + @Qualifier', 'Нельзя напрямую', 'Через String', 'Через Object'),
    ('Как заинжектить коллекцию?', 'List<Interface> будет содержать все имплементации', 'Нельзя', 'Только через Map', 'Только через Set'),
    ('Расскажите про аннотацию @Conditional', 'Создание бинов при выполнении условия', 'Только для тестов', 'Только для продакшена', 'Только для dev-профилей'),
    ('Что такое инверсия контроля (IoC) и внедрение зависимостей (DI)? Как эти принципы реализованы в Spring?', 'Контейнер управляет зависимостями, DI через аннотации или XML', 'DI через конструкторы', 'IoC — это GUI', 'DI — это ORM'),
    ('Что такое IoC контейнер?', 'Компонент, управляющий жизненным циклом бинов и их зависимостями', 'Сервис для работы с HTTP', 'Интерфейс для работы с БД', 'Утилитный класс'),
    ('Расскажите про ApplicationContext и BeanFactory, чем отличаются? В каких случаях что стоит использовать?', 'ApplicationContext расширяет BeanFactory, содержит больше фич', 'BeanFactory быстрее', 'ApplicationContext старее', 'BeanFactory не поддерживается'),
    ('Расскажите про аннотацию @Bean', 'Объявляет бин в конфигурационном классе', 'Для создания примитивов', 'Для работы с JSON', 'Для сериализации'),
    ('Расскажите про аннотацию @Component', 'Автосканирование компонентов', 'Только для сервисов', 'Только для контроллеров', 'Только для репозиториев'),
    ('Чем отличаются аннотации @Bean и @Component?', '@Bean — в конфигурации, @Component — автоматическое сканирование', 'Одинаковые', '@Bean старше', '@Component не требует конфигурации'),
    ('Расскажите про аннотации @Service и @Repository. Чем они отличаются?', 'Семантические различия, @Repository ловит исключения БД', 'Одинаковые', '@Service медленнее', '@Repository не поддерживает транзакции'),
    ('Расскажите про аннотацию @Autowired', 'Внедрение зависимостей через IoC контейнер', 'Только через конструктор', 'Только через сеттер', 'Только через поля'),
    ('Расскажите про аннотацию @Resource', 'Java EE аналог @Autowired по имени', 'Spring-специфичная', 'Только для строк', 'Только для чисел'),
    ('Расскажите про аннотацию @Inject', 'Java CDI аналог @Autowired', 'Spring-специфичная', 'Только для сервисов', 'Только для контроллеров'),
    ('Расскажите про аннотацию @Lookup', 'Позволяет получать prototype-бин внутри singleton', 'Только для статических полей', 'Только для final полей', 'Только для transient полей'),
    ('Расскажите про аннотацию @Profile', 'Активация бинов для конкретного профиля', 'Только для dev', 'Только для prod', 'Только для test'),
    ('"Расскажите про жизненный цикл бина, аннотации @PostConstruct и @PreDestroy"', 'Инициализация и уничтожение бина', 'Только @PostConstruct', 'Только @PreDestroy', 'Не поддерживаются'),
    ('Расскажите про скоупы бинов? Какой скоуп используется по умолчанию? Что изменилось в Spring 5?', 'singleton по умолчанию, есть prototype, request, session', 'prototype по умолчанию', 'request по умолчанию', 'scope не существует в Spring 5'),
    ('Расскажите про аннотацию @ComponentScan', 'Автоматическое сканирование компонентов', 'Только для XML', 'Только для аннотаций', 'Не поддерживается'),
    ('Как спринг работает с транзакциями? Расскажите про аннотацию @Transactional.', 'Прокси-объекты, поддержка ACID', 'Только через XML', 'Только через JDBC', 'Только через DAO'),
    ('Какие есть атрибуты у @Transactional?', 'propagation, isolation, timeout, readOnly, rollbackFor', 'Только propagation', 'Только isolation', 'Только timeout'),
    ('"Как @Transactional работает под капотом?"', 'Создает прокси, управляющий транзакцией', 'Через reflection', 'Через аннотации', 'Через статические методы'),
    ('Как решить проблему N+1 с использованием @Transactional?', 'Fetch join или EntityGraph внутри транзакции', 'Увеличение памяти', 'Использование List вместо Set', 'Оптимизация GC'),
    ('Расскажите про аннотации @Controller и @RestController. Чем они отличаются?', '@RestController = @Controller + @ResponseBody', 'Оба одинаковы', '@RestController старше', '@Controller быстрее'),
    ('Что такое ResponseEntity?', 'Объект ответа с HTTP статусом и заголовками', 'Класс для запросов', 'Тип данных', 'Интерфейс'),
    ('Что такое ViewResolver?', 'Компонент, разрешающий логические имена представлений', 'Резолвер URL', 'Резолвер классов', 'Резолвер бинов'),
    ('"Чем отличаются Model, ModelMap и ModelAndView?"', 'Model — интерфейс, ModelMap — реализация, ModelAndView — содержит оба', 'Все одинаковы', 'Model старше', 'ModelMap не поддерживается'),
    ('"Расскажите про паттерн Front Controller, как он реализован в Spring?"', 'DispatcherServlet управляет входящими запросами', 'Посредством фильтров', 'Через REST', 'Через MVC'),
    ('"Расскажите про паттерн MVC, как он реализован в Spring?"', 'Model — данные, View — отображение, Controller — логика', 'MVC не поддерживается', 'Spring использует только REST', 'Spring не поддерживает View'),
    ('Что такое АОП? Как реализовано в спринге?', 'Перехватчики вокруг методов, через прокси или AspectJ', 'Через аннотации', 'Через статические методы', 'Через reflection'),
    ('В чем разница между Filters, Listeners and Interceptors?', 'Filters на уровне Servlet API, Interceptors — Spring MVC, Listeners — события', 'Все одинаковы', 'Filters медленнее', 'Interceptors не поддерживаются'),
    ('Можно ли передать в запросе один и тот же параметр несколько раз? Как?', 'Да, как массив или через повторяющиеся ключи', 'Нет, только один раз', 'Только через POST', 'Только через JSON'),
    ('Как работает Spring Security? Как сконфигурировать? Какие интерфейсы используются?', 'Фильтры, UserDetails, UserDetailsService, AuthenticationManager', 'Только через XML', 'Только через аннотации', 'Только через Spring Boot'),
    ('Что такое SpringBoot? Какие у него преимущества? Как конфигурируется? Подробно.', 'Автоконфигурация, starter-зависимости, embedded сервер', 'Только для микросервисов', 'Требует внешнего сервера', 'Не поддерживает JPA'),
    ('Что такое Spring Data JPA?', 'Проект для упрощения работы с JPA', 'ORM над Hibernate', 'Только для JDBC', 'Только для MongoDB'),
    ('Как сделать подключение к разным БД?', 'Через разные DataSource и @Qualifier', 'Только одна БД', 'Через JDBC', 'Через ORM'),
    ('Расскажите про аннотацию @Query', 'Запрос на JPQL или Native SQL в Spring Data JPA', 'Только для HQL', 'Только для SQL', 'Только для NamedQuery'),
    ('Что такое проекционный интерфейс (projection interface)?', 'Интерфейс для выборки подмножества полей сущности', 'Тип данных', 'Формат сериализации', 'Метод работы с коллекциями'),
    ('Как избавиться от циклической зависимости бинов?', 'setter-injection, @Lazy, Event/Observer', 'Нельзя', 'Только через XML', 'Только через аннотации'),
    ('Расскажите про нововведения Spring 5.', 'WebFlux, поддержка Kotlin, улучшения в WebMvc', 'Только Java 8+', 'Новая JVM', 'Изменения в JPA'),
    ('Что такое DDL? Какие операции в него входят? Рассказать про них.', 'CREATE, ALTER, DROP — операции изменения структуры БД', 'SELECT, INSERT', 'BEGIN, COMMIT', 'GRANT, REVOKE'),
    ('Что такое DML? Какие операции в него входят? Рассказать про них.', 'INSERT, UPDATE, DELETE — манипуляции с данными', 'CREATE, DROP', 'COMMIT, ROLLBACK', 'GRANT, DENY'),
    ('Что такое TCL? Какие операции в него входят? Рассказать про них.', 'BEGIN, COMMIT, ROLLBACK — управление транзакциями', 'SELECT, INSERT', 'CREATE, ALTER', 'GRANT, REVOKE'),
    ('Что такое DCL? Какие операции в него входят? Рассказать про них.', 'GRANT, REVOKE — контроль доступа', 'INSERT, UPDATE', 'BEGIN, COMMIT', 'CREATE, DROP'),
    ('Нюансы работы с NULL в SQL. Как проверить поле на NULL?', 'IS NULL / IS NOT NULL', '= NULL', 'NULL = NULL', 'WHERE column == NULL'),
    ('Виды Join’ов?', 'INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL JOIN', 'JOIN по умолчанию', 'Только INNER', 'Только OUTER'),
    ('Что лучше использовать join или подзапросы? Почему?', 'JOIN быстрее и понятнее в большинстве случаев', 'Подзапросы всегда лучше', 'JOIN сложнее читать', 'JOIN медленнее'),
    ('Что делает UNION?', 'Объединяет результаты двух и более SELECT', 'Сортирует данные', 'Агрегирует данные', 'Удаляет дубликаты'),
    ('Чем WHERE отличается от HAVING (ответа про то что используются в разных частях запроса - недостаточно)?', 'WHERE до группировки, HAVING после GROUP BY', 'HAVING работает быстрее', 'HAVING не поддерживает условия', 'WHERE нельзя использовать с агрегатами'),
    ('Что такое ORDER BY?', 'Сортировка результата запроса', 'Группировка', 'Ограничение количества записей', 'Выборка'),
    ('Что такое DISTINCT?', 'Удаление дубликатов', 'Добавление индексов', 'Удаление всех записей', 'Фильтрация по условию'),
    ('Что такое GROUP BY?', 'Группировка строк по значениям', 'Сортировка', 'Ограничение выборки', 'Объединение таблиц'),
    ('Что быстрее убирает дубликаты distinct или group by?', 'DISTINCT обычно быстрее', 'GROUP BY быстрее', 'Одинаково', 'Зависит от СУБД'),
    ('Что такое LIMIT?', 'Ограничивает количество возвращаемых строк', 'Сортирует данные', 'Группирует данные', 'Фильтрует данные'),
    ('Что такое EXISTS?', 'Проверяет существование строк в подзапросе', 'Проверяет значение на NULL', 'Проверяет тип данных', 'Условие сравнения'),
    ('Расскажите про операторы IN, BETWEEN, LIKE.', 'IN — список значений, BETWEEN — диапазон, LIKE — шаблон', 'IN — одно значение', 'BETWEEN — точное совпадение', 'LIKE — числовые значения'),
    ('Что делает оператор MERGE? Какие у него есть ограничения?', 'Объединяет INSERT, UPDATE, DELETE в зависимости от условия', 'Работает только с одной таблицей', 'Требует наличия первичного ключа', 'Не поддерживается всеми СУБД'),
    ('Какие агрегатные функции вы знаете?', 'COUNT, SUM, AVG, MAX, MIN', 'FIRST, LAST', 'CONCAT, SUBSTR', 'DATE_ADD, DATE_SUB'),
    ('Что такое ограничения (constraints)? Какие вы знаете?', 'PRIMARY KEY, FOREIGN KEY, UNIQUE, CHECK, NOT NULL', 'INDEX, VIEW', 'TRIGGER, PROCEDURE', 'SEQUENCE, CURSOR'),
    ('Что такое суррогатные ключи?', 'Искусственные идентификаторы, например ID', 'Естественные ключи', 'Имена пользователей', 'Email как ключ'),
    ('Что такое индексы? Какие они бывают?', 'B-tree, Hash, Full-text, Bitmap — для ускорения запросов', 'Только B-tree', 'Только Hash', 'Только Full-text'),
    ('Чем TRUNCATE отличается от DELETE?', 'TRUNCATE быстрее, не логируется, не поддерживает WHERE', 'DELETE не удаляет данные', 'TRUNCATE можно откатить', 'DELETE быстрее'),
    ('Что такое представления (VIEW)? Для чего они нужны?', 'Виртуальные таблицы, основанные на запросе', 'Физические таблицы', 'Хранилища данных', 'Файлы'),
    ('Что такое временные таблицы? Для чего они нужны?', 'Таблицы, существующие только во время сессии', 'Таблицы для тестирования', 'Таблицы для резервного копирования', 'Таблицы для отчетов'),
    ('Что такое транзакции? Расскажите про принципы ACID.', 'Atomicity, Consistency, Isolation, Durability', 'Только Atomicity', 'Только Isolation', 'Только Durability'),
    ('Расскажите про уровни изолированности транзакций.', 'READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE', 'Только READ ONLY', 'Только WRITE ONLY', 'Только SHARED'),
    ('Что такое нормализация и денормализация? Расскажите про 3 нормальные формы?', 'Нормализация — устранение избыточности, 1NF, 2NF, 3NF', 'Нормализация — добавление индексов', 'Денормализация — удаление дубликатов', 'Нормализация — увеличение производительности'),
    ('Что такое TIMESTAMP?', 'Тип данных, представляющий момент времени', 'Дата без времени', 'Время без даты', 'Число секунд с 1970 года'),
    ('Шардирование БД', 'Разделение базы данных на горизонтальные части для масштабирования', 'Вертикальное разделение таблиц', 'Резервное копирование', 'Оптимизация запросов'),
    ('EXPLAIN', 'Показывает план выполнения запроса', 'Выполняет запрос немедленно', 'Удаляет данные', 'Создает индекс'),
    ('Как сделать запрос из двух баз?', 'Через CROSS JOIN или подзапросы', 'Только через UNION', 'Нельзя', 'Через DDL'),
    ('Механизмы оптимизации запросов в БД', 'Индексы, кэширование, переписывание запросов', 'Только GROUP BY', 'Только ORDER BY', 'Только LIMIT'),
    ('Что такое «триггер»?', 'Процедура, автоматически вызываемая при изменении данных', 'Хранимая процедура', 'Функция', 'Таблица');
