INSERT INTO questions (question, answer, theme, is_impotent)
VALUES ('Что такое ООП', 'ООП - методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.\n\n
Согласно парадигмы ООП программа состоит из обьектов, обменивающихся сообщениями. Обьекты могут обладать состоянием, единственный способ изменить состояние обьекта - передать ему сообщение,  в ответ на которое, обьект может изменить собственное состояние.\n\n
Класс — это описание еще не созданного объекта, как бы общий шаблон, состоящий из полей, методов и конструктора, а объект – экземпляр класса, созданный на основе этого описания.', 'CORE1', true),
       ('Какие преимущества у ООП', '1. Легко читается - не нужно выискивать в коде функции и выяснять, за что они отвечают\n\n
2. Быстро пишется - можно быстро создать сущности, с которыми должна работать программа.\n\n
3. Простота реализации большого функционала - т.к. на написание кода уходит меньше времени, можно гораздо быстрее создать приложение с множеством возможностей\n\n
4. Меньше повторений кода - не нужно писать однотипные функции для разных сущностей', 'CORE1', false),
       ('Какие недостатки у ООП', '1. Потребление памяти - обьекты потребляют больше оперативной памяти, чем примитивные типы данных\n\n
2. Снижает производительность - многие вещи технически реализованы иначе, поэтому они используют больше ресурсов.\n\n
3. Неэффективность и неэкономное распределения памяти на этапе выполнения (по причине издержек на динамическое связывание и проверки типов на этапе выполнения).\n\n
4. Излишняя универсальность. Часто содержится больше методов, чем это реально необходимо текущей программе. А поскольку лишние методы не могут быть удалены, они становятся мертвым грузом.\n\n
5. Сложно начать - парадигма ООП сложнее функционального программирования, поэтому на старт уходит больше времени', 'CORE1', false),
       ('Назовите основные принципы ООП', 'Инкапсуляция, Наследование, Полиморфизм', 'CORE1', true),
       ('Что такое инкапсуляция?', 'Инкапсуляция - Свойство системы, которое объединяет данные и методы, манипулирующие этими данными, а также защищает и то, и другое от внешнего вмешательства или неправильного использования.\n\n
Инкапсуляция - это объединение данных и методов работы с этими данными в одной упаковке («капсуле»).\n\n
Чтобы малейшее изменение в классе не влекло за собой изменение внешнего поведения класса.', 'CORE1', true),
       ('Что такое наследование?', 'Наследование - Свойство системы, которое позволяет описать новый класс на основе уже существующего с частично или полностью заимствованной функциональностью.', 'CORE1', true),
       ('Что такое полиморфизм? ', 'Полиморфизм – предоставляет возможность единообразно обрабатывать объекты с различной реализацией при условии наличия у них общего интерфейса или класса. Полиморфизм – способность функции обрабатывать данные разных типов.\n\n
Есть три вида полиморфизма:\n\n
-ad hoc полиморфизм, основан на различении типов. Для различных типов аргументов используется разный код метода, пример статического - перегрузка метода. Пример динамического - перегрузка метода. (@Overload)\n\n
-параметрический полиморфизм - ситуация, когда один и тот же метод работает с аргументами различных типов одинаково, не зависимо от их точного типа. Пример — функция, работающая с объектом некоторого класса C, может без изменений работать с объектом порождённого от C класса (этот вид полиморфизма часто называют полиморфизм включения). (@Override)\n\n
-subtype полиморфизм - самый популярный - возможность объектов с одинаковой спецификацией(интерфейс\класс\abstract класс) иметь различную реализацию.\n\n
Пример:\n\n
Переопределение методов, интерфейсы.', 'CORE1', true),
       ('Что такое ассоциация', 'Ассоциация – это когда один класс включает в себя другой класс в качестве одного из полей. Ассоциация описывается словом «имеет». Автомобиль имеет двигатель. Вполне естественно, что он не будет являться наследником двигателя (хотя такая архитектура тоже возможна в некоторых ситуациях).\n\n
Выделяют два частных случая ассоциации: композицию и агрегацию.', 'CORE1', false),
       ('Что такое композиция', 'Композиция – это когда двигатель не существует отдельно от автомобиля. Он создается при создании автомобиля и полностью управляется автомобилем. В типичном примере, экземпляр двигателя будет создаваться в конструкторе автомобиля.', 'CORE1', false),
       ('Что такое агрегация', 'Агрегация – это когда экземпляр двигателя создается где-то в другом месте кода, и передается в конструктор автомобиля в качестве параметра.', 'CORE1', false),
       ('Расскажите про раннее и позднее связывание.', 'Связывание означает наличие связи между ссылкой и кодом. Например, переменная, на которую вы ссылаетесь, привязана к коду, в котором она определена. Аналогично, вызываемый метод привязан к месту в коде, где он определен.\n\n
Раннее связывание - Если метод известен компилятору,  то происходит ранее связывание на этапе компиляции (early binding), также называют статическим связыванием. Используется для final, перегруженных, статических методов.\n\n
Позднее связывание (late binding) - вызов метода возможен только во время выполнения, т.к. у компилятора нет информации, чтобы проверить корректность такого вызова. В java это возможно при помощи рефлексии. Используется для переопределенных и абстрактных методов.\n\n
 Вот пример: Object a = ... // какое-то присваивание a.toString(); На этапе компиляции мы не знаем, какого типа объект a. Он может быть как собственно Object, так и любым его наследником, в котором метод toString() переопределён. Именно на этапе выполнения определяется тип a и вызывается toString() из того класса, какого типа объект a. Это и есть позднее связывание.\n\n
В случае статического связывания используются не конкретные объекты, а информация о типе, то есть используется тип ссылочной переменной. С другой стороны, при динамическом связывании для нахождения нужного метода используется конкретный объект.\n\n
Исходя из того, что раннее связывание выполняется на этапе компиляции, а позднее - в рантайме, первый вариант обладает лучшим быстродействием, однако второй необходим для реализации полиморфизма.', 'CORE1', false),
       ('SOLID', 'SOLID — это акроним, образованный из заглавных букв первых пяти принципов ООП и проектирования.\n\n
S(Single Responsibility Principle) - принцип единственной ответственности - каждый класс выполняет лишь одну задачу. Легкая модификация в будущем, простое тестирование, класс не имеет зависимостей на другие классы.\n\n
O(Open Closed Principle) - принцип открытости/закрытости - программные сущности открыты для расширения и закрыты для модификации. Чтобы не сломать логику в классе-родителе, мы унаследуемся от него и реализуем что-то своё, и используем свой класс.\n\n
L(Liskov’s Substitution Principle) - принцип подстановки барбары лисков -  объекты в программе можно заменить их наследниками без изменения свойств программы.\n\n
I(Interface Segregation Principle) - принцип разделения интерфейса - много специализированных интерфейсов лучше, чем один общий\n\n
D(Dependency Inversion Principle) - принцип инверсии зависимостей - зависимость на абстракциях. Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.', 'CORE1', true),
       ('Какая основная идея языка?', '«Написано однажды - работает везде». Идея основывается в написании одного кода, который будет работать на любой платформе.', 'CORE1', false),
       ('За счет чего обеспечивается кроссплатформенность?', 'Кроссплатформенность была достигнута за счёт создания виртуальной машина Java. Java Virtual Machine или JVM - это программа, являющаяся прослойкой между операционной системой и Java программой. В среде виртуальной машины выполняются коды Java программ. Сама JVM реализована для разных ОС. Что байт код для JVM может исполняться везде где установлена JVM. Код не нужно перекомпилировать под каждую из платформ.', 'CORE1', false),
       ('Какие преимущества у java?', 'Объектно-ориентированное программирование - структура данных становится объектом, которым можно управлять для создания отношений между различными объектами.\n\n
Стандарт для корпоративных вычислительных систем - корпоративные приложения — главное преимущество Java с 90-х годов, когда организации начали искать надежные инструменты программирования не на C.\n\n
Безопасность - благодарю отсутсвию указателей и Security Manager (политика безопасности, в которой можно указать правила доступа, позволяет запускать приложения Java в "песочнице").\n\n
Независимость от платформы - Можно создать Java-приложение на Windows, скомпилировать его в байт-код и запустить его на любой другой платформе, поддерживающей виртуальную машину Java (JVM). Таким образом, JVM служит уровнем абстракции между кодом и оборудованием.\n\n
Язык для распределенного программирования и комфортной удаленной совместной работы - Специфическая для Java методология распределенных вычислений называется Remote Method Invocation (RMI). RMI позволяет использовать все преимущества Java: безопасность, независимость от платформы и объектно-ориентированное программирование для распределенных вычислений. Кроме того, Java также поддерживает программирование сокетов и методологию распределения CORBA для обмена объектами между программами, написанными на разных языках.\n\n
Автоматическое управление памятью - Разработчикам Java не нужно вручную писать код для управления памятью благодаря автоматическому управлению памятью (AMM).\n\n
Многопоточность - Поток — наименьшая единица обработки в программировании. Чтобы максимально эффективно использовать время процессора, Java позволяет запускать потоки одновременно, что называется многопоточностью.', 'CORE1', false),
       ('Какие недостатки у java?', 'Платное коммерческое использование (с 2019)\n\n
Низкая производительность - из-за компиляции и абстракции с помощью виртуальной машины, а также приложение очистки памяти.\n\n
Не развитые инструменты по созданию GUI приложений на чистой java.\n\n
Многословный код. Java — это более легкая версия неприступного C ++, которая вынуждает программистов прописывать свои действия словами из английского языка. Это делает язык более понятным для неспециалистов, но менее компактным.', 'CORE1', false),
       ('Что такое JDK? Что в него входит?', 'JDK (Java Development Kit) - включает JRE и набор инструментов разработчика приложений на языке Java:\n\n
- компилятор Java (javac)\n\n
- стандартные библиотеки классов java\n\n
- примеры\n\n
- документацию\n\n
- различные утилиты', 'CORE1', false),
       ('Что такое JRE? Что в него входит?', 'JRE (java Runtime Environment) - минимально-необходимая реализация виртуальной машины для исполнения Java-приложений. Состоит из JVM, ClassLoader и стандартного набора библиотек и классов Java', 'CORE1', false),
       ('Что такое JVM?', 'JVM (Java Virtual Machine) - виртуальная машина Java исполняет байт-код Java, предварительно созданный из кода JIT компилятором, с помощью встроенного интерпретатора байткода.\n\n
HotSpot представляет собой реализацию концепции JVM.', 'CORE1', false),
       ('Что такое byte code?', 'Байт-код Java — набор инструкций, скомпилированный компилятором, исполняемый JVM. ', 'CORE1', false),
       ('Что такое загрузчик классов (classloader)?', 'Загрузчик классов (classloader) в Java - это компонент виртуальной машины Java (JVM), который ответственен за загрузку классов в память приложения. Каждый класс, используемый в Java программе, загружается загрузчиком классов, который находится внутри JVM.\n\n Используется для передачи в JVM скомпилированного байт-кода, хранится в файлах с расширением .class\n\n
При запуске JVM, используются три загрузчика классов:\n\n
- Bootstrap ClassLoader - базовый загрузчик - загружает платформенные классы JDK из архива rt.jar\n\n
- AppClassLoader - системный загрузчик (3) - загружает классы приложения, определенные в CLASSPATH\n\n
- Extension ClassLoader - загрузчик расширений (2) - загружает классы расширений, которые по умолчанию находятся в каталоге jre/lib/ext.\n\n
ClassLoader выполняет три основных действия в строгом порядке:\n\n
1. Загрузка: находит и импортирует двоичные данные для типа.\n\n
2. Связывание: выполняет проверку, подготовку и (необязательно) разрешение.\n\n
3. Инициализация: вызывает код Java, который инициализирует переменные класса их правильными начальными значениями.\n\n
Каждый загрузчик хранит указатель на родительский, чтобы суметь передать загрузку если сам будет не в состоянии этого сделать.', 'CORE1', true),
       ('Что такое JIT?', 'JIT (Just-In-Time) компилятор в Java - это компонент виртуальной машины Java (JVM), который переводит байт-код Java в машинный код во время выполнения программы. JIT-компиляция позволяет оптимизировать производительность приложения, поскольку ускоряет выполнение кода за счет компиляции только необходимых методов в машинный код на лету.', 'CORE1', false),
       ('Что такое сборщик мусора? (Garbage collector)', 'Сборщик мусора выполняет две задачи: - поиск мусора; - очистка мусора.\n\n
Области памяти Кучи:\n
1. Молодое поколение (Young Generation) - это область кучи, где размещаются недавно созданные объекты. Объекты, которые "выживают" после сборки мусора в молодом поколении, переносятся в следующее поколение. Молодое поколение состоит из следующих частей:\n
   - Eden Space - сюда помещаются новые объекты.\n
   - Survivor Space (from/to) - здесь хранятся объекты, пережившие одну или несколько сборок мусора в молодом поколении.\n\n
2. Старое поколение (Old Generation) - это область кучи, куда переносятся объекты, "пережившие" несколько сборок мусора в молодом поколении. Это более стабильные и долгоживущие объекты.\n\n
3. Постоянное поколение (Permanent Generation) - это область памяти, используемая для хранения метаданных JVM, таких как классы и методы. В Java 8 и более поздних версиях постоянное поколение было заменено на Метаспейс (Metaspace).\n\n
Процессы сборки мусора разделяются несколько видов:\n\n
        1. minor GC (малая) - частый и быстрый, работает только с областью памяти "young generation";\n\n
         - приложение приостанавливается на начало сборки мусора (такие остановки называются stop-the-world);\n
         - «живые» объекты из Eden перемещаются в область памяти «To»;\n
         - «живые» объекты из «From» перемещаются в «To» или в «old generation», если они достаточно «старые»;\n
         - Eden и «From» очищаются от мусора;\n
         - «To» и «From» меняются местами;\n
         - приложение возобновляет работу.\n\n
        2. major GC (старшая) - редкий и более длительный, затрагивает объекты старшего поколения. В принцип работы «major GC» добавляется процедура «уплотнения», позволяющая более эффективно использовать память. В процедуре живые объекты перемещаются в начало. Таким образом, мусор остается в конце памяти.\n\n
        full GC (полная) -  полный сборщик мусора сначала запускает Minor, а затем Major (хотя порядок может быть изменен, если старое поколение заполнено, и в этом случае он освобождается первым, чтобы позволить ему получать объекты от молодого поколения',  'CORE1', true),
       ('Виды ссылок в Java', '1) StrongReference — это самые обычные ссылки которые мы создаем каждый день, любая переменная ссылочного типа.         StringBuilder builder = new StringBuilder(); - builder это и есть strong-ссылка на объект StringBuilder.Любой объект что имеет strong ссылку запрещен для удаления сборщиком мусора.\n\n
2) SoftReference —  GC гарантировано удалит с кучи все объекты, доступные только по soft-ссылке, перед тем как бросит OutOfMemoryError. SoftReference это наш механизм кэширования объектов в памяти, но в критической ситуации, когда закончится доступная память, GC удалит не использующиеся объекты из памяти и тем самым попробует спасти JVM от завершения работы.\n\n
   StringBuilder builder = new StringBuilder();\n\n
   SoftReference<StringBuilder> softBuilder = new SoftReference(builder);\n\n
   softBuilder.get() — вернет strong-ссылку на объект StringBuilder в случае если GC не удалил этот объект из памяти. В другом случае вернется null.\n\n
   softBuilder.clear() — удалит ссылку на объект StringBuilder То же самое работает для WeakReference.\n\n
3) WeakReference — если GC видит, что объект доступен только через цепочку weak-ссылок (исчезнули strong-ссылки), то он удалит его из памяти.', 'CORE1', false),
       ('Stack и Heap', 'В Java, стек (stack) используется для хранения локальных переменных и вызовов методов. Каждый поток выполнения программы имеет свой собственный стек. Переменные на стеке имеют кратковременную жизнь и удаляются после выхода из метода.\n\n
Куча (heap) в Java используется для хранения объектов и доступна всем потокам. Память в куче выделяется для объектов и освобождается сборщиком мусора, когда объект больше не используется. Переменные ссылочного типа (например, объекты класса) хранятся в куче, а сами объекты на которые они ссылаются также лежат в куче.', 'CORE1', true),
       ('Какие примитивные типы данных есть в Java? Вопрос чтобы отсеить дурака', 'В Java существует 8 примитивных типов данных:\n\n
1. byte: 8-битное целое число от -128 до 127.\n\n
2. short: 16-битное целое число от -32,768 до 32,767.\n\n
3. int: 32-битное целое число от -2,147,483,648 до 2,147,483,647.\n\n
4. long: 64-битное целое число от -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807.\n\n
5. float: 32-битное число с плавающей запятой от ~3.4e-38 до ~3.4e38.\n\n
6. double: 64-битное число с плавающей запятой от ~1.7e-308 до ~1.7e308.\n\n
7. boolean: логический тип данных, принимающий значение true или false.\n\n
8. char: 16-битный символ Unicode от 0 до 65,535.\n\n
Каждый примитивный тип данных имеет фиксированный размер и диапазон значений, который определяет, какие значения он может хранить.', 'CORE1', true),
       ('Что такое char?', '16-разрядное беззнаковое целое, представляющее собой символ UTF-16 (буквы и цифры)', 'CORE1', false),
       ('Сколько памяти занимает boolean?', 'Зависит от реализации JVM. В стандартной реализации Sun JVM и Oracle HotSpot JVM тип boolean занимает 4 байта (32 бита), как и тип int. Однако, в определенных версия JVM имеются реализации, где в массиве boolean каждое значение занимает по 1-му биту.', 'CORE1', false),
       ('Что такое классы-обертки?', 'Обертка — это специальный класс, который хранит внутри себя значение примитива(объекты классов-оберток являются неизменяемыми (Immutable)). Нужны для реализации дженериков.', 'CORE1', false),
       ('Что такое автоупаковка и автораспаковка?', 'Автоупаковка - присвоение классу обертки значения примитивного типа;\n\n
Автораспаковка - присвоение переменной примитивного типа значение класса обертки.\n\n
для присваивания ссылок-примитивов объектам их классов-оберток (и наоборот) не требуется ничего делать, все происходит автоматически. Для того, чтобы иметь возможность оперировать с простыми числами (и boolean) как с объектами были придуманы классы-обёртки.', 'CORE1', false),
       ('Что такое явное и неявное приведение типов? В каких случаях в java нужно использовать явное приведение?', 'Неявное приведение – автоматическое расширение типа переменной от меньшего к большему.\n\n
Явное приведение -  явное сужение от большего к меньшему. Необходимо явно указать сужаемый тип.long l = (long)d; //explicit type casting int i = (int)l;\n\n
В случае с объектами мы можем делать неявное(автоматическое) приведение от наследника к родителю, но не наоборот, иначе получим ClassCastException.', 'CORE1', false),
       ('Что такое пул интов?', 'В Java есть пул(pool) целых чисел в промежутке [-128;127], так как это самый часто вречающийся диапазон. Т.е. если мы создаем Integer в этом промежутке, то вместо того, чтобы каждый раз создавать новый объект, JVM берет их из пула.\n\n
Изменить размер кэша в HotSpot вы можете, указав ключ -XX:AutoBoxCacheMax=<размер>. ( внастройках JVM)', 'CORE1', false),
       ('Какие нюансы у строк в Java?', 'Класс String в Java -  неизменяемый из-за модификатора final и отсутствия сеттера. Это нужно для реализации пула стрингов. При редактировании будет создаваться новая строка. При копировании новая строка не создается, а создается ссылка на существующую строку.', 'CORE1', false),
       ('Что такое пул строк?', 'Область памяти где хранятся обьекты строк.\n\n
При создании в пуле идет поиск строки:\n\n
-если НЕ находит -  создается строка, возращается ссылка\n\n
-если находит - возращает ссылку найденной строки.\n\n
При этом использование оператора new заставляет класс String создать новый объект, даже если такая строка уже есть в пуле. После этого можем использовать метод intern(), чтобы поместить этот объект в пул строк.\n\n
Пул строк и Integer хранится в heap, но ссылки на объекты хранятся в stack.', 'CORE1', false),
       ('Почему не рекомендуется изменять строки в цикле? Что рекомендуется использовать?', 'Т.к. строка неизменяемый класс, потребление ресурсов при редактировании, т.к. каждую итерацию при редактировании будет создаваться новый обьект строки. Рекомендуется использовать StringBuilder или StringBuffer.', 'CORE1', false),
       ('Почему строки не рекомендуется использовать для хранения паролей?', '1. Пул строк. Так как строки в Java хранятся в пуле строк, то ваш пароль в виде обычного текста будет доступен в памяти, пока сборщик мусора не очистит её. И поскольку String используются в String pool для повторного использования, существует довольно высокая вероятность того, что пароль останется в памяти надолго, что совсем не безопасно.\n\n
2. Рекомендации авторов. Java сама по себе рекомендует использовать метод getPassword () из класса JPasswordField, который возвращает char [].\n\n
3. Случайная печать в логах. С типом String всегда существует опасность того, что текст, хранящийся в строке будет напечатан в файле логов или в консоли. В то же время в случае использования Array, вы не будете печатать содержимое массива, а только его расположение в памяти.', 'CORE1', false),
       ('Почему String неизменяемый и финализированный класс?', '1. Для возможности реализации строкового пула (String pool)\n
Виртуальная машина имеет возможность сохранить много места в памяти (heap space) т.к. разные строковые переменные указывают на одну переменную в пуле. При изменяемости строк было бы невозможно реализовать интернирование, поскольку если какая-либо переменная изменит значение, это отразится также и на остальных переменных, ссылающихся на эту строку.\n\n
2. Безопасность\n
Изменяемость строк несло бы в себе потенциальную угрозу безопасности приложения. Поскольку в Java строки используются для передачи параметров для авторизации, открытия файлов и т.д. — неизменяемость позволяет избежать проблем с доступом.\n\n
3. Для многопоточности. Неизменяемые строки потокобезопасны\n
Так как строка неизменяемая то, она безопасна для много поточности и один экземпляр строки может быть совместно использован различными потоками. Это позволяет избежать синхронизации для потокобезопасности. Таким образом, строки в Java полностью потокобезопасны.\n\n
4. Ключ для HashMap\n
Поскольку строка неизменная, её hashcode кэшируется в момент создания и нет никакой необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в Map и его обработка будет быстрее, чем других ключей HashMap. Поэтому строка наиболее часто используется в качестве ключа HashMap.\n\n
- можно передавать строку между потоками не опасаясь, что она будет изменена\n\n
- отсутствуют проблемы с синхронизацией потоков\n\n
- отсутствие проблем с  утечкой памяти\n\n
- отсутствие проблем с доступом и безопасностью при использовании строк для передачи параметров авторизации, открытия файлов и т.д.\n\n
- кэширование hashcode\n\n
- Экономия памяти при использовании пула строк для хранения повторяющихся строк.', 'CORE1', true),
       ('Почему строка является популярным ключом в HashMap в Java?', 'Поскольку строки неизменны, их хэшкод кэшируется в момент создания, и не требует повторного пересчета.', 'CORE1', false),
       ('Что делает метод intern() в классе String?', 'Помещает строку в pool строк.', 'CORE1', false),
       ('Можно ли использовать строки в конструкции switch?', 'Да, начиная с Java 7 в операторе switch можно использовать строки, ранние версии Java не поддерживают этого.\n\n
При этом:\n\n
- участвующие строки чувствительны к регистру;\n\n
- использование строк в конструкции switch делает код читабельнее, убирая множественные цепи условий if-else\n\n
- оператор switch использует метод String.equals() для сравнения полученного значения со значениями case, поэтому добавьте проверку на NULL во избежание NullPointerException.', 'CORE1', false),
       ('Какая основная разница между String, StringBuffer, StringBuilder?', 'String - неизменяемый, потокобезопасный;\n\n
StringBuffer - изменяемый, потокобезопасный;\n\n
StringBuilder - изменяемый, потоконебезопасный.', 'CORE1', false),
       ('Существуют ли в java многомерные массивы?', 'Многомерные массивы в их классическом понимании в java не существуют.\n\n
Многомерный массив всегда прямоугольный и неразрывен в памяти. А то, что в java считается мнгомерным - в других языках ещё называют "зубчатым массивом" или массивом массивов.', 'CORE1', false),
       ('Какими значениями инициируются переменные по умолчанию?', 'byte 0\n\n
short 0\n\n
int 0\n\n
long 0L\n\n
float 0.0f\n\n
double 0.0d\n\n
char \u0000\n\n
boolean false\n\n
Обьекты null\n\n
Локальные (в методе) переменные не имеют значений по умолчанию, их имеют поля класса.\n\n
Не static-поле класса будет инициализировано после того, как будет создан объект этого класса. А static-поле будет инициализировано тогда, когда класс будет загружен виртуальной Java машиной.', 'CORE1', false),
       ('Что такое сигнатура метода?', 'Это имя метода плюс параметры (порядок параметров имеет значение из-за множественной передачи данных через троеточие, которое должно располагаться последним). В сигнатуру метода не входит возвращаемое значение, а также бросаемые им исключения.\n\n
А сигнатура метода в сочетании с типом возвращаемого значения и бросаемыми исключениями называется контрактом метода.', 'CORE1', false),
       ('Расскажите про метод main', 'Является, как правило, точкой входа в программу и вызывается JVM.\n\n
Как только заканчивается выполнение метода main(), так сразу же завершается работа самой программы.\n\n
static - чтобы JVM смогла загрузить его во время компиляции.\n\n
public static void и сигнатура - обязательное декларирование.\n\n
Мэйнов может быть много и может не быть вообще.\n\n
Может быть перегружен.', 'CORE1', false),
       ('Каким образом переменные передаются в методы, по значению или по ссылке? Очень важный вопрос, часто используется для проверки на дурака', 'Java передает параметры по значению. Всегда. С примитивами, мы получаем копию содержимого. Со ссылками мы тоже получаем копию ссылки.', 'CORE1', true),
       ('Какие виды классов есть в java?', '1. Вложенные классы – нестатические классы внутри внешнего класса.\n\n
2. Вложенные статические классы – статические классы внутри внешнего класса.\n\n
3. Локальные классы Java – классы внутри методов. разница между локальным и внутреним\n\n
4. Анонимные Java классы – классы, которые создаются на ходу. Анонимные классы доступно\n\n
5. Final, abstract, enum - классы', 'CORE1', false),
       ('Расскажите про вложенные классы. В каких случаях они применяются?', 'Нужны для обслуживания внешних классов\n\n
1. Статические вложенные классы (Static nested classes)\n\n
   - Есть возможность обращения к внутренним статическим полям и методам класса обертки.\n\n
2. Вложенные классы\n\n
   - Есть возможность обращения к внутренним полям и методам класса обертки.\n\n
   - Не может иметь статических объявлений.\n\n
   - Внутри такого класса нельзя объявить перечисления.\n\n
   - Если нужно явно получить this внешнего класса — OuterClass.this\n\n
3. Локальный класс\n\n
   - Видны только в пределах блока, в котором объявлены.\n\n
   - Не могут быть объявлены как private/public/protected или static (по этой причине интерфейсы нельзя объявить локально).\n\n
   - Не могут иметь внутри себя статических объявлений (полей, методов, классов), но могут иметь константы (static final)\n\n
   - Имеют доступ к полям и методам обрамляющего класса.\n\n
   - Можно обращаться к локальным переменным и параметрам метода, если они объявлены с модификатором final или являются effectively final.\n\n
   - Анонимные классы\n\n
   - Локальный класс без имени.', 'CORE1', false),
       ('- Что такое «локальный класс»? Каковы его особенности?', 'Данные классы объявляются внутри других методов. Они обладают всеми свойствами нестатического вложенного класса, только создавать их экземпляры можно только в методе.\n\n
Особенности:
Локальные классы способны работать только с final переменными метода.\n\n
С 8+ версий Java можно использовать не final переменные в локальных классах, но только при условии, что они не будут изменяться.\n\n
Локальные классы нельзя объявлять с модификаторами доступа.\n\n
Локальные классы обладают доступом к переменным метода.\n\n
Может быть создан внутри блоков инициализации.', 'CORE1', false),
       ('Что такое «анонимные классы»? Где они применяются?', '\tАнонимные классы - это вложенный локальный класс без имени в Java, которые позволяют определить и создать экземпляр класса одновременно. Анонимные классы полезны в случаях, когда требуется создать класс один раз и не планируется его повторное использование.\n\n
\tОсновные характеристики анонимных классов:\n
1. Они не имеют имени и создаются inline (на месте использования).\n
2. Часто используются для реализации интерфейсов или наследования от классов абстрактного типа.\n
3. Могут содержать содержание в виде методов и переопределений.\n\n
Пример использования анонимного класса:\n\n
interface Greeting {\n
    \tvoid greet();\n
}\n\n

public class Main {\n
    \tpublic static void main(String[] args) {\n
        \t\tGreeting greeting = new Greeting() {\n
            \t\t\t@Override\n
            \t\t\tpublic void greet() {\n
                \t\t\t\tSystem.out.println("Hello, World!");\n
            \t\t\t}\n
        \t\t};\n\n

        \t\tgreeting.greet();\n
    \t}\n
}\n\n

\tАнонимные классы часто применяются в разработке GUI приложений (например, обработчики событий) и при реализации стратегий или шаблонов проектирования. Они позволяют упростить код, избежать создания лишних классов и сделать код более компактным и лаконичным. В документации Oracle приведена хорошая рекомендация: «Применяйте анонимные классы, если вам нужен локальный класс для одноразового использования». ', 'CORE1', true),
       ('- Каким образом из вложенного класса получить доступ к полю внешнего класса?', 'Статический вложенный класс имеет прямой доступ только к статическим полям обрамляющего класса.\n\n
Простой вложенный класс, может обратиться к любому полю внешнего класса напрямую.\n\n
В случае, если у вложенного класса уже существует поле с таким же литералом, то обращаться к внешнему полю следует через имя внешнего класса. Например: Outer.this.field.', 'CORE1', false),
       ('Что такое перечисления (enum)?', 'Перечисления представляют набор логически связанных констант.\n\n
Перечисление фактически представляет новый класс, поэтому мы можем определить переменную данного типа и использовать ее.\n\n
Перечисления, как и обычные классы, могут определять конструкторы, поля и методы.\n\n
Следует отметить, что конструктор по умолчанию приватный. Также можно определять методы для отдельных констант.\n\n
Методы:\n\n
-ordinal() возвращает порядковый номер определенной константы (нумерация начинается с 0)\n\n
-values() возвращает массив всех констант перечисления\n\n
Еnum имеет ряд преимуществ при использовании в сравнении с static final int.\n\n
Главным отличием является то что используя enum вы можете проверить тип данных.\n\n
Недостатки\n\n
-  К ним не применимы операторы >, <, >=, <= \n\n
- enum также требует больше памяти для хранения чем обычная константа.\n\n
Нужны для ограничения области допустимых значений: например, времена года, дни недели', 'CORE1', false),
       ('Как проблема ромбовидного наследования решена в java?', 'В Java нет поддержки множественного наследования классов.\n\n
Предположим, что SuperClass — это абстрактный класс, описывающий некоторый метод, а классы ClassA и ClassB — обычные классы наследники SuperClass, а класс ClassC наследуется от ClassA и ClassB одновременно. Вызов метода родительского класса приведет к неопределенности, так как компилятор не знает о том, метод какого именно суперкласса должен быть вызван. Это и есть основная причина, почему в Java нет поддержки множественного наследования классов.\n\n
1. Классы всегда побеждают: Определенный в классе / суперклассе метод всегда имеет высший приоритет перед дефолтными методами интерфейсов.\n\n
2. Если не срабатывает правило 1, то побеждают саб-интерфейсы (more specific). Т.е. если интерфейс B наследует A, и у обоих есть методы с одинаковой сигнатурой, то побеждает B.\n\n
3. Если оба правила не работают, то класс, наследующий конфликтующие интерфейсы, должен явно через super определить, какой именно метод вызвать, иначе компилятор будет сильно материться.', 'CORE1', false),
       ('Что такое конструктор по умолчанию?', 'Если у какого-либо класса не определить конструктор, то компилятор сгенерирует конструктор без аргументов - так называемый «конструктор по умолчанию».\n\n
Если у класса уже определен какой-либо конструктор, то конструктор по умолчанию создан не будет и, если он необходим, его нужно описывать явно.', 'CORE1', false),
       ('Могут ли быть приватные конструкторы? Для чего они нужны?', 'Да, могут. Приватный конструктор запрещает создание экземпляра класса вне методов самого класса.\n\n
Нужен для реализации паттернов, например singleton.', 'CORE1', false),
       ('Расскажите про классы-загрузчики и про динамическую загрузку классов.', 'При запуске JVM, используются три загрузчика классов:\n\n
- Bootstrap ClassLoader - главный загрузчик - загружает платформенные классы JDK из архива rt.jar\n\n
- AppClassLoader - системный загрузчик - загружает классы приложения, определенные в CLASSPATH\n\n
- Extension ClassLoader - загрузчик расширений - загружает классы расширений, которые по умолчанию находятся в каталоге jre/lib/ext.\n\n
Динамическая загрузка происходит "на лету" в ходе выполнения программы с помощью статического метода класса Class.forName(имя класса). Для чего нужна динамическая загрузка? Например мы не знаем какой класс нам понадобится и принимаем решение в ходе выполнения программы передавая имя класса в статический метод forName().', 'CORE1', true),
       ('Чем отличаются конструкторы по-умолчанию, конструктор копирования и конструктор с параметрами?', '-У конструктора по умолчанию отсутствуют какие-либо аргументы. \n\n
-Конструктор копирования принимает в качестве аргумента уже существующий объект класса для последующего создания его клона.\n\n
-Конструктор с параметрами имеет в своей сигнатуре аргументы (обычно необходимые для инициализации полей класса).', 'CORE1', false),
       ('Какие модификаторы доступа есть в Java? Какие применимы к классам?', 'Private – доступ к компоненту только из этого класса, в котором объявлен.\n\n
Default – Переменная или метод будут доступны для любого другого класса в том же пакете.\n\n
Protected – Поля protected доступны всем классам внутри пакета, а также всем классам-наследникам вне пакета.\n\n
Public – доступ к компоненту из экземпляра любого класса и любого пакета.\n\n
Класс может быть объявлен с модификатором public и default.', 'CORE1', false),
       ('Что означает модификатор static?', 'Статическая переменная - это переменная, принадлежащая классу, а не объекту.\n\n
А статический класс- это вложенный класс, который может обращаться только к статическим полям обертывающего его класса.\n\n
Внутри static метода нельзя вызвать не статический метод по имени класса.', 'CORE1', false),
       ('Может ли статический метод быть переопределён или перегружен', 'Нельзя переопределять статические методы.\n\n
Если вы объявите такой же метод в классе-наследнике (subclass), т.е. метод с таким же именем и сигнатурой, вы лишь «спрячете» метод суперкласса  вместо переопределения. Это явление известно как сокрытие методов (hiding methods).\n\n
Перегружен - да. Всё работает точно так же как и с обычными методами - 2 статических метода могут иметь одинаковое имя, если количество их параметров или типов различается.', 'CORE1', false),
       ('Могут ли нестатические методы перегрузить статические?', 'Да. Это будут просто два разных метода для программы. Статический будет доступен по имени класса.', 'CORE1', false),
       ('Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?', 'При переопределении метода нельзя сузить модификатор доступа к методу (например, с public до private), но можно расширить.\n\n
Изменить тип возвращаемого значения нельзя, но можно сузить возвращаемое значение, если они совместимы. Например, если метод возвращает объект класса, а переопределенный метод возвращает класс-наследник.', 'CORE1', false),
       ('Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы (throws и тп)?', 'В сигнатуре(имя + параметры) менять ничего нельзя.\n\n
Возможно расширение уровня доступа.\n\n
Изменять тип возвращаемого значения при переопределении метода разрешено только в сторону сужения типа (вместо родительского класса - наследника).\n\n
Секцию throws метода можно не указывать, но стоит помнить, что она остаётся действительной, если уже определена у метода родительского класса. Так же, возможно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения RuntimeException. Порядок следования таких элементов при переопределении значения не имеет.', 'CORE1', false),
       ('Могут ли классы быть статическими?', 'Класс можно объявить статическим за исключением классов верхнего уровня.\n\n
Такие классы известны как «вложенные статические классы» (nested static class). ', 'CORE1', false),
       ('Что означает модификатор final? К чему он может быть применим?', 'Для класса это означает, что класс не сможет иметь подклассов, т.е. запрещено наследование. \n\n
Следует также отметить, что к abstract-классам нельзя применить модификатор final, т.к. это взаимоисключающие понятия.\n\n
Для переменных примитивного типа это означает, что однажды присвоенное значение не может быть изменено\n\n
Для ссылочных переменных это означает, что после присвоения объекта, нельзя изменить ссылку на данный объект. Важно: Ссылку изменить нельзя, но состояние объекта изменять можно.\n\n
Т.к. массив – это объект, то final означает, что после присвоения ссылки на объект, уже нельзя ее изменить, но можно изменять состояние объекта.', 'CORE1', false),
       ('Что такое абстрактные классы? Чем они отличаются от обычных?', 'Абстрактным называется класс, на основе которого не могут создаваться объекты.\n\n
Как обычный класс, но с абстрактными методами.\n\n
Нельзя создать объект или экземпляр абстрактного класса.\n\n
Наследниками абстрактного класса могут быть другие абстрактные классы', 'CORE1', false),
       ('Может ли быть абстрактный класс без абстрактных методов?', 'Класс может быть абстрактным без единого абстрактного метода, если у него указан модификатор abstract.', 'CORE1', false),
       ('Могут ли быть конструкторы у абстрактных классов? Для чего они нужны?', 'Да. Необходимы для наследников.\n\n
В абстрактном классе в Java можно объявить и определить конструкторы. Даже если вы не объявили никакого конструктора, компилятор добавит в абстрактный класс конструктор по умолчанию без аргументов. Абстрактные конструкторы будут часто использоваться для обеспечения ограничений класса или инвариантов, таких как минимальные поля, необходимые для настройки класса.', 'CORE1', false),
       ('Что такое интерфейсы? Какие модификаторы по умолчанию имеют поля и методы интерфейсов?', 'Интерфейс — это план класса или, можно сказать, набор абстрактных методов и статических констант. В интерфейсе каждый метод является открытым и абстрактным, но не содержит конструктора. Таким образом, интерфейс в основном представляет собой группу связанных методов с пустыми телами. Другими словами, интерфейс определяет как элементы будут взаимодействовать между собой.\n\n
- методы интерфейса являются публичными (public) и абстрактными (abstract)\n\n
- поля — public static final.', 'CORE1', false),
       ('Чем интерфейсы отличаются от абстрактных классов? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?', '1. Интерфейс описывает только поведение (методы) объекта, а вот состояний (полей) у него нет (кроме public static final), в то время как у абстрактного класса они могут быть.\n\n
2. Мы можем наследовать только один класс, а реализовать интерфейсов — сколько угодно. Интерфейс может наследовать (extends) другой интерфейс/интерфейсы.\n\n
3. Абстрактные классы используются, когда есть отношение "is-a", то есть класс-наследник расширяет базовый абстрактный класс, а интерфейсы могут быть реализованы разными классами, вовсе не связанными друг с другом.\n\n
4. Абстрактный класс может реализовывать методы; интерфейс может реализовывать статические методы начиная с 8й версии.', 'CORE1', false),
       ('Может ли один интерфейс наследоваться от другого? От двух других?', 'Да, может. Используется ключевое слово extends', 'CORE1', false),
       ('Что такое дефолтные методы интерфейсов? Для чего они нужны?', 'В JDK 8 была добавлена такая функциональность как методы по умолчанию с модификатором default. И теперь интерфейсы могут иметь их реализацию по умолчанию, которая используется, если класс, реализующий данный интерфейс, не реализует метод. Это нужно для обратной совместимости.\n\n
(Если один или несколько методов добавляются к интерфейсу, все реализации также будут вынуждены их реализовывать. Методы интерфейса по умолчанию являются эффективным способом решения этой проблемы.) ', 'CORE1', false),
       ('Как решается проблема ромбовидного наследования при наследовании интерфейсов при наличии default методов?', 'класс, наследующий конфликтующие интерфейсы, должен явно через super определить, какой именно метод вызвать:\n\n
InterfaceB.super.method();', 'CORE1', false),
       ('Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?', '1. Статические блоки от первого до последнего предка(от предка до наследника)\n\n
2. Попарно динамической блок инициализации и конструктор от первого до последнего предка', 'CORE1', false),
       ('Зачем нужны и какие бывают блоки инициализации?', 'Инициализация - это когда мы впервые задаем переменной какое-либо значение.\n\n
Существуют статические и нестатические блоки инициализации.', 'CORE1', false),
       ('Для чего в Java используются статические блоки инициализации?', 'Статические блоки инициализация используются для выполнения кода, который должен выполняться один раз при инициализации класса загрузчиком классов, в момент предшествующий созданию объектов этого класса при помощи конструктора. Такой блок принадлежит только самому классу.', 'CORE1', false),
       ('Что произойдет, если в блоке инициализации возникнет исключительная ситуация?', 'Для нестатических блоков инициализации, если выбрасывание исключения прописано явным образом, требуется, чтобы объявления этих исключений были перечислены в throws всех конструкторов класса. Иначе будет ошибка компиляции.\n\n
Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции.', 'CORE1', false),
       ('Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?', 'Если возникшее исключение - наследник RuntimeException:\n\n
-для статических блоков инициализации будет выброшено java.lang.ExceptionInInitializerError;\n\n
-для нестатических будет проброшено исключение-источник.\n\n
Если возникшее исключение - наследник Error, то в обоих случаях будет выброшено java.lang.Error.\n\n
Если исключение: java.lang.ThreadDeath - смерть потока. В этом случае никакое исключение выброшено не будет.', 'CORE1', false),
       ('Что такое класс Object?', 'Базовый класс для всех остальных объектов в Java. Любой класс наследуется от Object и, соответственно, наследуют его методы\n\n
Все классы являются наследниками суперкласса Object. Это не нужно указывать явно. В результате объект Object может ссылаться на объект любого другого класса.\n\n', 'CORE1', true),
       ('Какие методы есть у класса Object (перечислить все)? Что они делают?', '- equals() - проверка на равенство двух обьектов\n\n
- hashCode() - изначально случайно число int\n\n
- toString() - представления данного объекта в виде строки.\n\n
- getClass() - получение типа данного обьекта\n\n
- clone() -  клонирует объект методом.\n\n
- finalize() - deprecated, вызывается GC перед удалением. (нет гарантии что будет вызван)\n\n
для многопоточки\n\n
- notify() - «размораживает» одну случайную нить\n\n
- notifyAll() - «размораживает» все нити данного монитора\n\n
- wait() - нить освобождает монитор и «становится на паузу»\n\n
- wait(long timeOut) - нить освобождает монитор и «становится на паузу»,принимает максимальное время ожидания в миллисекундах.\n\n
- wait(long timeOut, int nanos) - нить освобождает монитор и «становится на паузу»,принимает максимальное время ожидания в миллисекундах, дополнительное время, в диапазоне наносекунд 0-999999.', 'CORE1', true),
       ('Расскажите про equals и hashcode', '\tХеш-код — это целочисленный результат работы метода, которому в качестве входного параметра передан объект.\n
\tЕсли более точно, то это битовая строка фиксированной длины, полученная из массива произвольной длины. \n
\tEquals - это метод, определенный в Object, который служит для сравнения объектов. При сравнении объектов при помощи == идет сравнение по ссылкам. При сравнении по equals() идет сравнение по состояниям объектов.\n\n
Свойства equals():\n
\t-        Симметричность: Для двух ссылок, a и b, a.equals(b) тогда и только тогда, когда b.equals(a)\n
\t-        Рефлексивность: для любого заданного значения x, выражение x.equals(x) должно возвращать true.\n
\tЗаданного — имеется в виду такого, что x != null\n
\t-        Постоянство: повторный вызов метода equals() должен возвращать одно и тоже значение до тех пор, пока какое-либо значение свойств объекта не будет изменено.\n
\t-        Транзитивность: Если a.equals(b) и b.equals(c), то тогда a.equals(c)\n
\t-        Совместимость с hashCode(): Два тождественно равных объекта должны иметь одно и то же значение hashCode()\n\n
\tПри переопределении equals() обязательно нужно переопределить метод hashCode(). Равные объекты должны возвращать одинаковые хэш коды.', 'CORE1', true),
       ('Каким образом реализованы методы hashCode() и equals() в классе Object?', '1 - Реализация метода Object.equals() сводится к проверке на равенство двух ссылок:\n\n
public boolean equals(Object obj) {\n
  \treturn (this == obj);\n
}\n\n
2 - HashCode реализован таким образом, что для одного и того же входного объекта, хеш-код всегда будет одинаковым.\n\n
\tРеализация метода Object.hashCode() описана как native, т.е. написана не на Java. Непереопределенный hashCode возвращает идентификационный хеш, основанный на состоянии потока, объединённого с xorshift (в OpenJDK8). А вообще, функция предлагает шесть методов на базе значения переменной hashCode:\n\n
0. Случайно сгенерированное число.\n
1. Функция адреса объекта в памяти.\n
2. Жёстко запрограммированное значение 1 (используется при тестировании на чувствительность (sensitivity testing)).\n
3. Последовательность.\n
4. Адрес объекта в памяти, приведённый к целочисленному значению.\n
5. Состояние потока, объединённое с xorshift (https://en.wikipedia.org/wiki/Xorshift)\n
public native int hashCode();\n\n
\tСитуация, когда у разных объектов одинаковые хеш-коды называется — коллизией. Вероятность возникновения коллизии зависит от используемого алгоритма генерации хеш-кода.', 'CORE1', true),
       ('Зачем нужен equals(). Чем он отличается от операции ==?', 'equals() -  сравнение по состоянию, == -  по ссылкам', 'CORE1', false),
       ('Правила переопределения equals()', '1. Проверить на равенство ссылки объектов this и параметра метода o.\n\n
if (this == o) return true;\n\n
2. Проверить, определена ли ссылка o, т. е. является ли она null.\n\n
Если в дальнейшем при сравнении типов объектов будет использоваться оператор instanceof, этот пункт можно пропустить, т. к. этот параметр возвращает false в данном случае null instanceof Object.\n\n
3. Сравнить типы объектов this и o с помощью оператора instanceof или метода getClass(), руководствуясь описанием выше и собственным чутьем.\n\n
4. Если метод equals переопределяется в подклассе, не забудьте сделать вызов super.equals(o)\n\n
5. Выполнить преобразование типа параметра o к требуемому классу.\n\n
6. Выполнить сравнение всех значимых полей объектов:\n\n
  - для примитивных типов (кроме float и double), используя оператор == \n\n
  - для ссылочных полей необходимо вызвать их метод equals\n\n
  - для массивов можно воспользоваться перебором по циклу, либо методом Arrays.equals()\n\n
  - для типов float и double необходимо использовать методы сравнения соответствующих оберточных классов Float.compare() и Double.compare()', 'CORE1', false),
       ('Что будет, если переопределить equals() не переопределяя hashCode()? Какие могут возникнуть проблемы?', 'Нарушится контракт. Классы и методы, которые использовали правила этого контракта могут некорректно работать. Так для объекта HashMap это может привести к тому, что пара, которая была помещена в Map возможно не будет найдена в ней при обращении к Map, если используется новый экземпляр ключа.', 'CORE1', false),
       ('Какой контракт между hashCode() и equals()?', '1) Если два объекта возвращают разные значения hashcode(), то они не могут быть равны\n\n
2) Если equals объектов true, то и хэшкоды должны быть равны. \n\n
3) Переопределив equals, всегда переопределять и hashcode.', 'CORE1', true),
       ('Для чего нужен метод hashCode()?', 'вычисляет целочисленное значение для конкретного элемента класса, чтобы использовать его для быстрого поиска и доступа к этому элементу в hash-структурах данных, например, HashMap, HashSet и прочих.', 'CORE1', true),
       ('Правила переопределения метода hashcode()', 'Если хеш-коды разные, то и входные объекты гарантированно разные.\n\n
Если хеш-коды равны, то входные объекты не всегда равны.\n\n
При вычислении хэш-кода следует использовать те же поля, которые сравниваются в equals и которые не вычисляются на основе других значений.\n\n
- вызов метода hashCode один и более раз над одним и тем же объектом должен возвращать одно и то же хэш-значение, при условии что поля объекта, участвующие в вычислении значения, не изменялись.\n\n
- вызов метода hashCode над двумя объектами должен всегда возвращать одно и то же число, если эти объекты равны (вызов метода equals для этих объектов возвращает true).\n\n
- вызов метода hashCode над двумя неравными между собой объектами должен возвращать разные хэш-значения. Хотя это требование и не является обязательным, следует учитывать, что его выполнение положительно повлияет на производительность работы хэш-таблиц.', 'CORE1', false),
       ('Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode()?', 'Выбирать поля, которые с большой долью вероятности будут различаться. Для этого необходимо использовать уникальные, лучше всего примитивные поля, например такие как id, uuid. При этом нужно следовать правилу, если поля задействованы при вычислении hashCode(), то они должны быть задействованы и при выполнении equals().', 'CORE1', false),
       ('Могут ли у разных объектов быть одинаковые hashCode()?', 'Могут. Когда у разных объектов одинаковые хеш-коды называется — коллизией.', 'CORE1', false),
       ('Почему нельзя реализовать hashcode() который будет гарантированно уникальным для каждого объекта?', 'В Java множество возможных хэш кодов ограничено типом int, а множество объектов ничем не ограничено.\n\n
Из-за этого, вполне возможна ситуация, что хэш коды разных объектов могут совпасть', 'CORE1', false),
       ('Есть класс Point{int x, y;}. Почему хэш-код в виде 31 * x + y предпочтительнее чем x + y?', 'Множитель создает зависимость значения хэш-кода от очередности обработки полей, а это дает гораздо лучшую хэш-функцию.', 'CORE1', false),
       ('Чем a.getClass().equals(A.class) отличается от a instanceOf A.class', 'getClass() получает только класс, а оператор instanceof проверяет является ли объект экземпляром класса или его потомком', 'CORE1', false),
       ('Что такое исключения?', 'Исключение — это ошибка (является объектом), возникающая во время выполнения программы. ', 'CORE1', true),
       ('Опишите иерархию исключений', '1. класс Throwable (checked)\n\n
2. от Throwable  -> Error (ошибки JVM) и Exception (checked общие)\n\n
3. от Exception \n\n
    - > RuntimeException (unchecked)\n\n
    - > IOException, SQLException, ReflectiveOperationException (checked)\n\n
4.RuntimeException (unchecked):\n\n
  ClassCastExceptiuon\n\n
  IndexOutOfBoundException\n\n
  AritthmeticException\n\n
  NullPointerException\n\n', 'CORE1', true),
       ('Расскажите про обрабатываемые и необрабатываемые исключения', '1. Checked исключения, это те, которые должны обрабатываться блоком catch или описываться в сигнатуре метода. Unchecked могут не обрабатываться и не быть описанными.\n\n
2. Unchecked исключения в Java — наследованные от RuntimeException, checked — от Exception.\n\n
Checked исключения отличаются от Unchecked исключения в Java, тем что \n\n
наличие\обработка Checked исключения проверяются компилятором на этапе компиляции.\n\n
Наличие\обработка Unchecked исключения происходит на этапе выполнения.\n\n', 'CORE1', false),
       ('Можно ли обработать необрабатываемые исключения?', 'Можно, чтобы в некоторых случаях программа не прекратила работу', 'CORE1', false),
       ('Какой оператор позволяет принудительно выбросить исключение?', 'Throw', 'CORE1', false),
       ('О чем говорит ключевое слово throws?', 'Метод потенциально может выбросить исключение с указанным типом. \n\n
Передаёт обработку исключения вышестоящему методу.', 'CORE1', false),
       ('Как создать собственное («пользовательское») исключение?', 'Необходимо унаследоваться от базового класса требуемого типа исключений (например, от Exception или RuntimeException) и переопределить методы', 'CORE1', false),
       ('Расскажите про механизм обработки исключений в java (Try-catch-finally)', 'Try - блок в котором может появиться исключение;\n\n
Catch - блок в котором мы указываем исключение и логику его обработки;\n\n
Finally - блок который обязательно отработает', 'CORE1', false),
       ('Возможно ли использование блока try-finally (без catch)?', 'try может быть в паре с finally, без catch. Работает это точно так же - после выхода из блока try выполняется блок finally', 'CORE1', false),
       ('Может ли один блок catch отлавливать сразу несколько исключений?', 'Да', 'CORE1', false),
       ('Всегда ли выполняется блок finally? Существуют ли ситуации, когда блок finally не будет выполнен?', 'Да, кроме случаев завершения работы программы или JVM:\n\n
1 - Finally может не выполниться в случае если в блоке try вызывает System.exit(0),\n\n
2 - Runtime.getRuntime().exit(0), Runtime.getRuntime().halt(0) и если во время исполнения блока try виртуальная машина выполнила недопустимую операцию и будет закрыта.\n\n
3 - В блоке try{} бесконечный цикл.', 'CORE1', true),
       ('Может ли метод main() выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?', 'Может и оно будет передано в виртуальную машину Java (JVM).\n\n
Для случая с методом main произойдет две вещи:\n\n
- будет завершен главный поток приложения;\n\n
- будет вызван ThreadGroup.uncaughtException.', 'CORE1', false),
       ('В каком порядке следует обрабатывать исключения в catch блоках?', 'От наследника к предку', 'CORE1', false),
       ('Что такое механизм try-with-resources?', 'Дает возможность объявлять один или несколько ресурсов в блоке try, которые будут закрыты автоматически без использования finally блока.\n\n
В качестве ресурса можно использовать любой объект, класс которого реализует интерфейс java.lang.AutoCloseable или java.io.Closeable.\n\n
Closeable extends AutoCloseable', 'CORE1', true),
       ('Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из блока finally?', 'finally-секция может «перебить» throw/return при помощи другого throw/return', 'CORE1', false),
       ('Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из метода close() при использовании try-with-resources?', 'В try-with-resources добавленна возможность хранения "подавленных" исключений, и брошенное try-блоком исключение имеет больший приоритет, чем исключения получившиеся во время закрытия.', 'CORE1', false),
       ('Что такое сериализация и как она реализована в Java?', 'Сериализация это процесс сохранения состояния объекта в последовательность байт;\n\n
Реализована через интерфейс - маркер Serializable. ', 'CORE1', true),
       ('Для чего нужна сериализация?', 'Для компактного сохранения состояния объекта и считывание этого состояния.', 'CORE1', false),
       ('Опишите процесс сериализации/десериализации с использованием Serializable.', '1) Класс объекта должен реализовывать интерфейс Serializable\n\n
2) Создать поток ObjectOutputStream (oos), который записывает объект в переданный OutputStream.\n\n
3) Записать в поток: oos.writeObject(Object);\n\n
4) Сделать oos.flush() и oos.close()', 'CORE1', false),
       ('Как изменить стандартное поведение сериализации/десериализации?', 'Использовать интерфейс Externalizable. \n\n
Переопределить методы\n\n
 writeExternal(ObjectOutput out) throws IOException\n\n
 readExternal(ObjectInput in) throws IOException, ClassNotFoundException', 'CORE1', false),
       ('Какие поля не будут сериализованы при сериализации? Будет ли сериализовано final поле?', '1) Добавить к полю модификатор transient. В таком случае после восстановления его значение будет null.\n\n
2) Сделать поле static. Значения статических полей автоматически не сохраняются.\n\n
3) Поля с модификатором final сериализуются как и обычные. За одним исключением – их невозможно десериализовать при использовании Externalizable, поскольку final-поля должны быть инициализированы в конструкторе, а после этого в readExternal изменить значение этого поля будет невозможно. Соответственно, если необходимо сериализовать объект с final-полем неоходимо использовать только стандартную сериализацию.', 'CORE1', false),
       ('Как создать собственный протокол сериализации?', 'Для создания собственного протокола нужно просто переопределить writeExternal() и readExternal().\n\n
В отличие от двух других вариантов сериализации, здесь ничего не делается автоматически. Протокол полностью в ваших руках. ', 'CORE1', false),
       ('Какая роль поля serialVersionUID в сериализации?', 'Поле private static final long serialVersionUID содержит уникальный идентификатор версии сериализованного класса. Оно вычисляется по содержимому класса - полям, их порядку объявления, методам, их порядку объявления. Соответственно, при любом изменении в классе это поле поменяет свое значение.\n\n
Если мы не объявляем его явно, Java делает это за нас.', 'CORE1', false),
       ('Когда стоит изменять значение поля serialVersionUID?', 'Вы должны изменить serialVersionUID только тогда, когда вы сознательно хотите нарушить совместимость со всеми существующими сериализациями , например, когда изменения в вашем классе сделают его настолько семантически отличным, что у вас не будет выбора - в этом случае вы действительно должны несколько раз подумать о том, что вы на самом деле делаете.', 'CORE1', false),
       ('В чем проблема сериализации Singleton?', '- Проблема - в том что после десериализации мы получим другой объект.\n\n
Таким образом, сериализация дает возможность создать Singleton еще раз, что не совсем нужно.\n\n
- Решение - В классе определяется метод с сигнатурой "Object readResolve() throws ObjectStreamException"\n\n
- Назначение  - этого метода - возвращать замещающий объект вместо объекта, на котором он вызван.', 'CORE1', false),
       ('Расскажите про клонирование объектов.', 'в Java, есть 3 способа клонирования объекта:\n\n
1. С использованием интерфейса Cloneable; \n\n
Первый способ подразумевает, что вы будете использовать механизм так называемого «поверхностного клонирования» и сами позаботитесь о клонировании полей-объектов. Метод clone() в родительском классе Object является protected, поэтому требуется переопределение его с объявлением как public. Он возвращает экземпляр объекта с копированными полями-примитивами и ссылками. И получается что у оригинала и его клона поля-ссылки указывают на одни и те же объекты.\n\n
2. С использованием конструктора клонирования объекта;\n\n
В классе описывается конструктор, который принимает объект этого же класса и инициализирует значениями его полей поля нового объекта.\n\n
3. С использованием сериализации.\n\n
Он заключается в сохранении объекта в поток байтов с последующей эксгумацией его от туда.', 'CORE1', false),
       ('В чем отличие между поверхностным и глубоким клонированием?', 'Поверхностное копирование копирует настолько малую часть информации, насколько это возможно. По умолчанию, клонирование в Java является поверхностным, т.е. Object class не знает о структуре класса, которого он копирует.\n\n
Глубокое копирование дублирует все. Глубокое копирование — это две коллекции, в одну из которых дублируются все элементы оригинальной коллекции. ', 'CORE1', false),
       ('Какой способ клонирования предпочтительней?', 'Наиболее безопасным и следовательно предпочтительным способом клонирования является использование специализированного конструктора копирования:\n\n
Отсутствие ошибок наследования (не нужно беспокоиться, что у наследников появятся новые поля, которые не будут склонированы через метод clone());\n\n
Поля для клонирования указываются явно;\n\n
Возможность клонировать даже final поля.', 'CORE1', false),
       ('Почему метод clone() объявлен в классе Object, а не в интерфейсе Cloneable?', 'Метод clone() объявлен в классе Object с сигнатурой native, чтобы обеспечить доступ к стандартному механизму "поверхностного копирования" объектов (копируются значения всех полей, включая ссылки на сторонние объекты); он объявлен, как protected, чтобы нельзя было вызвать этот метод у не переопределивших его объектов. ', 'CORE1', false),
       ('Как создать глубокую копию объекта? (2 способа)', 'Глубокое клонирование требует выполнения следующих правил:\n\n
-Нет необходимости копировать отдельно примитивные данные;\n\n
-Все классы-члены в оригинальном классе должны поддерживать клонирование. Для каждого члена класса должен вызываться super.clone() при переопределении метода clone();\n\n
-Если какой-либо член класса не поддерживает клонирование, то в методе клонирования необходимо создать новый экземпляр этого класса и скопировать каждый его член со всеми атрибутами в новый объект класса, по одному.\n\n
1 Сериализация – это еще один способ глубокого копирования. Мы просто сериализуем нужный объект и десериализуем его. Очевидно, объект должен поддерживать интерфейс Serializable. Мы сохраняет объект в массив байт и потом прочитать из него.\n\n
2 При помощи библиотеки DeepCloneable\n\n
Глубокое клонирование с этой библиотекой сводится с двум строкам кода:\n\n
Cloner cloner = new Cloner();\n\n
DeepCloneable clone = cloner.deepClone(this);', 'CORE1', false);