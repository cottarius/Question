INSERT INTO questions (question, answer, theme, is_impotent)
VALUES ('Что такое «шаблон проектирования»?', 'Проверенное и готовое к использованию логическое решение, которе может быть реализовано по-разному в разных языках программирования.\n\n
Плюсы:\n\n
снижение сложности разработки за счёт готовых абстракций\n\n
облегчение коммуникации между разработчиками\n\n
Минусы:\n\n
слепое следование некоторому шаблону может привести к усложнению программы.\n\n
желание попробовать некоторый шаблон в деле без особых на то оснований.','PATTERNS_ALGORITHMS', false),
       ('Назовите основные характеристики шаблонов.', 'Имя - все шаблоны имеют уникальное имя, служащее для их идентификации;\n\n
Назначение данного шаблона;\n\n
Задача, которую шаблон позволяет решить;\n\n
Способ решения, предлагаемый в шаблоне для решения задачи в том контексте, где этот шаблон был найден;\n\n
Участники - сущности, принимающие участие в решении задачи;\n\n
Следствия от использования шаблона как результат действий, выполняемых в шаблоне;\n\n
Реализация - возможный вариант реализации шаблона.','PATTERNS_ALGORITHMS', false),
       ('Назовите три основные группы паттернов.', 'Порождающие - отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов без внесения в программу лишних зависимостей.\n\n
Структурные - отвечают за построение удобных в поддержке иерархий классов\n\n
Поведенческие - заботятся об эффективной коммуникации между объектами.\n\n
Основные - основные строительные блоки, используемые для построения других шаблонов. Например, интерфейс.', 'PATTERNS_ALGORITHMS', false),
       ('Расскажите про паттерн Одиночка (Singleton).','Порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.\n\n
Конструктор помечается как private, а для создания нового объекта Singleton использует специальный метод getInstance(). Он либо создаёт объект, либо отдаёт существующий объект, если он уже был создан.\n\n
private static Singleton instance;\n\n
    \tpublic static Singleton getInstance() {\n
        \t\tif (instance == null) {\n
           \t\t\tinstance = new Singleton(); \n
        \t\t}\n
        \t\treturn instance;\n
}\n\n
+ : можно не создавать множество объектов для ресурсоемких задач, а пользоваться одним\n\n
- : нарушает принцип единой ответственности, так как его могут использовать множество объектов\n\n
Почему считается антипаттерном?\n\n \t- Нельзя тестировать с помощью mock, но можно использовать powerMock.\n \t- Нарушает принцип единой ответственности\n \t- Нарушает Open/Close принцип, его нельзя расширить', 'PATTERNS_ALGORITHMS', false),
       ('Расскажите про паттерн Строитель (Builder).', 'Порождающий паттерн, который позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений одного объекта.\n\n
Паттерн предлагает вынести конструирование объекта за пределы его собственного класса, поручив это дело отдельным объектам, называемым строителями.\n\n
Процесс конструирования объекта разбить на отдельные шаги (например, построитьСтены, вставитьДвери). Чтобы создать объект, вам нужно поочерёдно вызывать методы строителя. Причём не нужно запускать все шаги, а только те, что нужны для производства объекта определённой конфигурации.\n\n
Можно пойти дальше и выделить вызовы методов строителя в отдельный класс, называемый директором. В этом случае директор будет задавать порядок шагов строительства, а строитель — выполнять их.\n\n
+: Позволяет использовать один и тот же код для создания различных объектов. Изолирует сложный код сборки объектов от его основной бизнес-логики.\n\n
-: Усложняет код программы из-за введения дополнительных классов.', 'PATTERNS_ALGORITHMS', false),
       ('Расскажите про паттерн Фабричный метод (Factory Method).', 'Порождающий шаблон проектирования, в котором предоставляет интерфейс для создания объектов в родительском классе,  но позволяет подклассам изменять тип создаваемых объектов.\n\n подклассы имплементируют общий интерфейс с методом для создания объектов. Переопределенный метод в каждом наследнике возвращает нужный вариант объекта.\n\n
Объекты всё равно будут создаваться при помощи new, но делать это будет фабричный метод. Таким образом можно переопределить фабричный метод в подклассе, чтобы изменить тип создаваемого продукта.\n\n
Чтобы эта система заработала, все возвращаемые объекты должны иметь общий интерфейс. Подклассы смогут производить объекты различных классов, следующих одному и тому же интерфейсу.\n\n
+: Выделяет код производства объектов в одно место, упрощая поддержку кода. Реализует принцип открытости/закрытости.\n\n
- : Может привести к созданию больших параллельных иерархий классов, так как для каждого класса продукта надо создать свой подкласс создателя.\n\n Пример: у нас есть интерфейс "разработичк" и его реализация в виде классов "разработчиков" но под каждую реализацию нужно создать производителя для этого создаем еще один интерфейс который будет имень всего один фабричный метод.','PATTERNS_ALGORITHMS', false),
       ('Расскажите про паттерн Абстрактная фабрика (Abstract Factory).', 'Порождающий паттерн проектирования, Абстрактная фабрика задаёт интерфейс создания всех доступных типов продуктов, а каждая конкретная реализация фабрики порождает продукты одной из вариаций.\n\n
Абстрактная фабрика предлагает выделить общие интерфейсы для отдельных продуктов, составляющих семейства. Так, все вариации кресел получат общий интерфейс Кресло, все диваны реализуют интерфейс Диван и так далее.\n\n
Далее вы создаёте абстрактную фабрику — общий интерфейс, который содержит фабричные методы создания всех продуктов семейства (например, создатьКресло, создатьДиван и создатьСтолик). Эти операции должны возвращать абстрактные типы продуктов, представленные интерфейсами, которые мы выделили ранее — Кресла, Диваны и Столики.\n\n
+: гарантированно будет создаваться тип одного семейства\n\n
- : Усложняет код программы из-за введения множества дополнительных классов.', 'PATTERNS_ALGORITHMS', false),
       ('Расскажите про паттерн Прототип (Prototype).', 'Порождающий паттерн проектирования, который позволяет копировать объекты, не вдаваясь в подробности их реализации.\n\n
Паттерн поручает создание копий самим копируемым объектам. Он вводит общий интерфейс с методом clone для всех объектов, поддерживающих клонирование. Реализация этого метода в разных классах очень схожа. Метод создаёт новый объект текущего класса и копирует в него значения всех полей собственного объекта.интерфейс Cloneable - является реализацией шаблона портотип\n\n
+: Позволяет клонировать объекты, не привязываясь к их конкретным классам.\n\n
- : Сложно клонировать составные объекты, имеющие ссылки на другие объекты.', 'PATTERNS_ALGORITHMS', false),
       ('Расскажите про паттерн Адаптер (Adapter).', 'Структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.\n\n
Это объект-переводчик, который трансформирует интерфейс или данные одного объекта в такой вид, чтобы он стал понятен другому объекту.\n\n
При этом адаптер оборачивает один из объектов, так что другой объект даже не знает о наличии первого.\n\n
+: Отделяет и скрывает от клиента подробности преобразования различных интерфейсов.\n\n
- : Усложняет код программы из-за введения дополнительных классов.', 'PATTERNS_ALGORITHMS',  false),
       ('Расскажите про паттерн Декоратор (Decorator).', 'Структурный паттерн проектирования, который позволяет добавлять объектам новую функциональность, оборачивая их в полезные «обёртки».\n\n(Надстройка когда уже есть готовый функционал(класс) и мы хотим вызывать этот же функционал но с добавлением своей реализации)\n\n
Целевой объект помещается в другой объект-обёртку, который запускает базовое поведение обёрнутого объекта, а затем добавляет к результату что-то своё.\n\n
Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы, с каким объектом работать — чистым или обёрнутым. Вы можете использовать несколько разных обёрток одновременно — результат будет иметь объединённое поведение всех обёрток сразу.\n\n
Адаптер не менят состояния объекта, а декоратор может менять.\n\n
+: Большая гибкость, чем у наследования.\n\n
- : Труднее конфигурировать многократно обёрнутые объекты.', 'PATTERNS_ALGORITHMS', false),
       ('Расскажите про паттерн Заместитель (Proxy).', 'Структурный паттерн проектирования, который позволяет подставлять вместо реальных объектов специальные объекты-заменители, которые перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.\n\n
Заместитель предлагает создать новый класс-дублёр, имеющий тот же интерфейс, что и оригинальный служебный объект. При получении запроса от клиента объект-заместитель сам бы создавал экземпляр служебного объекта, выполняя промежуточную логику, которая выполнялась бы до (или после) вызовов этих же методов в настоящем объекте.\n\n
+: Позволяет контролировать сервисный объект незаметно для клиента.\n\n
- : Увеличивает время отклика от сервиса.', 'PATTERNS_ALGORITHMS', false),
       ('Расскажите про паттерн Итератор (Iterator).', 'Поведенческий паттерн проектирования, который даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления.\n\n
Идея состоит в том, чтобы вынести поведение обхода коллекции из самой коллекции в отдельный класс.\n\n
Детали: Создается итератор и интерфейс, который возвращает итератор. В классе, в котором надо будет вызывать итератор, имплементируем интерфейс, возвращающий итератор, а сам итератор делаем там нестатическим вложенным классом, так как он нигде использоваться больше не будет.', 'PATTERNS_ALGORITHMS', false),
       ('Расскажите про паттерн Шаблонный метод (Template Method).', 'Поведенческий паттерн проектирования,это метод, внутренние блоки которого могут переопределяться подклассами для избежания повторного копирования ( который пошагово определяет алгоритм и позволяет наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом).\n\n
Паттерн предлагает разбить алгоритм на последовательность шагов, описать эти шаги в отдельных методах и вызывать их в одном шаблонном методе друг за другом. Для описания шагов используется абстрактный класс. Общие шаги можно будет описать прямо в абстрактном класе. Это позволит подклассам переопределять некоторые шаги алгоритма, оставляя без изменений его структуру и остальные шаги, которые для этого подкласса не так важны.', 'PATTERNS_ALGORITHMS', false),
       ('Расскажите про паттерн Цепочка обязанностей (Chain of Responsibility).', 'Поведенческий паттерн проектирования, позволяет передавать запрос по цепочке потенциальных обработчиков, пока один из них не обработает запрос. Каждый обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи  Область применения цепочки обязанностей — всевозможные обработчики событий, последовательные проверки доступа и прочее.\n\n
Базируется на том, чтобы превратить каждую проверку в отдельный класс с единственным методом выполнения. Данные запроса, над которым происходит проверка, будут передаваться в метод как аргументы.\n\n
Каждый из методов будет иметь ссылку на следующий метод-обработчик, что образует цепь. Таким образом, при получении запроса обработчик сможет не только сам что-то с ним сделать, но и передать обработку следующему объекту в цепочке. Может и не передавать, если проверка в одном из методов не прошла, например.', 'PATTERNS_ALGORITHMS', false),
       ('Какие паттерны используются в Spring Framework?', 'Singleton - Bean scopes\n\n
Factory - Bean Factory classes\n\n
Prototype - Bean scopes\n\n
Adapter - Spring Web and Spring MVC\n\n
Proxy - Spring Aspect Oriented Programming support\n\n
Template Method - JdbcTemplate, HibernateTemplate etc\n\n
Front Controller - Spring MVC DispatcherServlet\n\n
DAO - Spring Data Access Object support\n\n
Dependency Injection', 'PATTERNS_ALGORITHMS', false),
       ('Какие паттерны используются в Hibernate?', 'Domain Model – объектная модель предметной области, включающая в себя как поведение так и данные.\n\n
Data Mapper – слой мапперов (Mappers), который передает данные между объектами и базой данных, сохраняя их независимыми друг от друга и себя.\n\n
Proxy  — применяется для ленивой загрузки.\n\n
Factory — используется в SessionFactory', 'PATTERNS_ALGORITHMS', false),
       ('Шаблоны GRASP: Low Coupling (низкая связанность) и High Cohesion (высокая сплоченность)', 'Low Coupling - части системы, которые изменяются вместе, должны находиться близко друг к другу. Необходимо распределить ответственности между классами так, чтобы обеспечить минимальную связанность.\n\n
High Cohesion - если возвести Low Coupling в абсолют, то можно прийти к тому, чтобы разместить всю функциональность в одном единственном классе.классы должны содержать связанную бизнес — логику. В таком случае связей не будет вообще, но что-то тут явно не так, ведь в этот класс попадет совершенно несвязанная между собой бизнес-логика. Принцип High Cohesion говорит следующее: части системы, которые изменяются параллельно, должны иметь как можно меньше зависимостей друг на друга.\n\n
Low Coupling и High Cohesion представляют из себя два связанных между собой паттерна, рассматривать которые имеет смысл только вместе. Их суть: система должна состоять из слабо связанных классов, которые содержат связанную бизнес-логику. Соблюдение этих принципов позволяет удобно переиспользовать созданные классы, не теряя понимания о их зоне ответственности.', 'PATTERNS_ALGORITHMS', false),
       ('Расскажите про паттерн Saga', 'Сага — это механизм, обеспечивающий согласованность данных в микросервисах без применения распределенных транзакций.\n\n
Для каждой системной команды, которой надо обновлять данные в нескольких сервисах, создается некоторая сага. Сага представляет из себя некоторый «чек-лист», состоящий из последовательных локальных ACID-транзакций, каждая из которых обновляет данные в одном сервисе. Для обработки сбоев применяется компенсирующая транзакция. Такие транзакции выполняются в случае сбоя на всех сервисах, на которых локальные транзакции выполнились успешно.\n\n
Типов транзакций в саге четыре:\n\n
Компенсирующая — отменяет изменение, сделанное локальной транзакцией.\n\n
Компенсируемая — это транзакция, которую необходимо компенсировать (отменить) в случае, если последующие транзакции завершаются неудачей.\n\n
Поворотная — транзакция, опеределяющая успешность всей саги. Если она выполняется успешно, то сага гарантированно дойдет до конца.\n\n
Повторяемая — идет после поворотной и гарантированно завершается успехом.', 'PATTERNS_ALGORITHMS',  false),
       ('Change Data Capture', 'Change Data Capture (CDC) - это паттерн проектирования, который позволяет отслеживать и фиксировать изменения, происходящие в данных базы данных, и передавать эти изменения в другие системы или службы.\n\n
Основные характеристики CDC:\n\n
1.Непрерывное отслеживание изменений: CDC постоянно следит за изменениями в базе данных, фиксируя операции добавления, изменения и удаления данных.\n\n
2.Минимальные нарушения основных операций: CDC выполняет свою работу, не влияя на нормальную работу приложений, которые взаимодействуют с базой данных.\n\n
3.Передача изменений в другие системы: Собранные CDC-системой изменения данных передаются в другие системы, такие как хранилища данных, аналитические платформы или системы репликации.\n\n
4.Различные источники данных: CDC может работать с разными типами баз данных, включая реляционные, NoSQL и другие.', 'PATTERNS_ALGORITHMS', false),
       ('Event Sourcing', 'Event Sourcing - это паттерн проектирования, используемый для построения систем, в которых источником истины являются события, описывающие изменения состояния системы во времени.\n\n
Основные характеристики Event Sourcing:\n\n
1.Событийная модель: Вместо хранения текущего состояния объекта, Event Sourcing фокусируется на хранении последовательности событий, которые привели к данному состоянию.\n\n
2.Неизменяемость событий: События, записанные в системе, являются неизменяемыми. Новое состояние объекта создается путем применения новых событий к текущему состоянию.\n\n
3.Восстановление состояния: Текущее состояние объекта может быть восстановлено путем применения всех сохраненных событий, начиная с начального состояния.\n\n
4.Асинхронность и событийная модель: Событийная природа Event Sourcing хорошо сочетается с асинхронной обработкой данных и событийно-ориентированной архитектурой.', 'PATTERNS_ALGORITHMS',  false),
       ('Transactional outbox', 'Transactional Outbox - это паттерн проектирования, используемый в распределенных системах для обеспечения надежной доставки событий между различными сервисами.\n\n
Основные характеристики Transactional Outbox:\n\n
1.Двухфазная фиксация: Транзакции, изменяющие состояние системы, также записывают события в локальную "исходящую" очередь (outbox). Таким образом, изменения данных и публикация событий происходят в рамках одной транзакции.\n\n
2.Асинхронная обработка: Отдельный процесс периодически извлекает события из локальной очереди и публикует их в сторонние системы или сервисы-подписчики.\n\n
3.Отказоустойчивость: Если при публикации события возникает ошибка, оно остается в локальной очереди и будет повторно обработано при следующем цикле.\n\n
4.Идемпотентность: События, публикуемые из транзакционной очереди, должны быть идемпотентными, чтобы подписчики могли корректно обрабатывать повторные события.', 'PATTERNS_ALGORITHMS',  false),
       ('Что такое Big O? Как происходит оценка асимптотической сложности алгоритмов?', 'Big O нотация нужна для описания сложности алгоритмов.Сложность алгоритма состоит из двух факторов: временная сложность и сложность по памяти.\n\n
Основные виды сложности:\n\n
- **Константная сложность O(1)**: Количество операций не зависит от размера входных данных.\n\n
- **Линейная сложность O(n)**: Количество операций линейно зависит от размера входных данных.\n\n
- **Логарифмическая сложность O(log n)**: Количество операций растет логарифмически с ростом размера входных данных.\n\n
- **Квадратичная сложность O(n^2)**: Количество операций пропорционально квадрату размера входных данных.\n\n
- **Экспоненциальная сложность O(2^n)**: Количество операций растет экспоненциально с ростом размера входных данных.', 'PATTERNS_ALGORITHMS', false),
       ('Что такое рекурсия? Сравните преимущества и недостатки итеративных и рекурсивных алгоритмов. С примерами.', 'Рекурсия - это процесс, при котором функция или метод вызывает сам себя для решения некоторой подзадачи. Рекурсия состоит из базового случая и шага рекурсии. Базовый случай представляет собой самую простую задачу, которая решается за одну итерацию, например, if(n == 0) return 1.\n\n
В базовом случае обязательно  присутствует условие выхода из рекурсии; \n\n
Преимущества рекурсивных алгоритмов:\n\n
1.**Простота и читаемость**: Рекурсивные решения часто более компактны и читабельны, особенно для задач, которые естественно представляются в рекурсивной форме.\n\n
2.**Естественное выражение идеи**: Многие задачи, такие как обход дерева или вычисление факториала, могут быть естественно выражены и решены рекурсивно.\n\n
3.**Избегание явного управления состоянием**: Рекурсивные алгоритмы позволяют избежать необходимости явно управлять состоянием, так как состояние инкапсулируется в стеке вызовов.\n\n
Недостатки рекурсивных алгоритмов:\n\n
1.**Повышенное потребление памяти**: Каждый рекурсивный вызов добавляет новый уровень в стек вызовов, что может привести к высокому потреблению памяти для глубоких рекурсий.\n\n
2.**Возможность переполнения стека**: Если глубина рекурсии слишком велика, то это может привести к переполнению стека и ошибке времени выполнения.\n\n
3.**Более высокие накладные расходы**: Вызовы функций и возвраты из них сопряжены с накладными расходами, которые могут быть выше, чем у итеративных алгоритмов.', 'PATTERNS_ALGORITHMS', false),
       ('Что такое жадные алгоритмы? Приведите пример.', 'Жадные алгоритмы являются одной из 3х техник создания алгоритмов, вместе с принципом "Разделяй и властвуй" и динамическим программированием.\n\n
Жадный алгоритм - это алгоритм, который на каждом шагу совершает локально оптимальные решения, т.е. максимально возможное из допустимых, не учитывая предыдущие или следующие шаги. Последовательность этих локально оптимальных решений приводит (не всегда) к глобально оптимальному решению.\n\n
Т.е. задача рабивается на подзадачи, в каждой подзадаче делается оптимальное решение и, в итоге, вся задача решается оптимально. При этом важно является ли каждое локальное решение безопасным шагом. Безопасный шаг - приводящий к оптимальному решению.\n\n
К примеру, алгоритм Дейкстры нахождения кратчайшего пути в графе вполне себе жадный, потому что мы на каждом шагу ищем вершину с наименьшим весом, в которой мы еще не бывали, после чего обновляем значения других вершин. При этом можно доказать, что кратчайшие пути, найденные в вершинах, являются оптимальными.', 'PATTERNS_ALGORITHMS', false),
       ('Расскажите про пузырьковую сортировку.', 'Будем идти по массиву слева направо. Если текущий элемент больше следующего, меняем их местами. Делаем так, пока массив не будет отсортирован.\n\n
Aсимптотика в худшем и среднем случае – O(n^2), в лучшем случае – O(n) - массив уже отсортирован.  ', 'PATTERNS_ALGORITHMS', false),
       ('Расскажите про быструю сортировку.', 'Выберем некоторый опорный элемент(pivot). После этого перекинем все элементы, меньшие его, налево, а большие – направо. Для этого используются дополнительные переменные - значения слева и справа, которые сравниваются с pivot. Рекурсивно вызовемся от каждой из частей, где будет выбран новый pivot. В итоге получим отсортированный массив, так как каждый элемент меньше опорного стоял раньше каждого большего опорного.\n\n
Асимптотика: O(n*log(n)) в среднем и лучшем случае. Наихудшая оценка O(n^2) достигается при неудачном выборе опорного элемента. ', 'PATTERNS_ALGORITHMS', false),
       ('Расскажите про сортировку слиянием.', 'Основана на парадигме «разделяй и властвуй». Будем делись массив пополам, пока не получим множество массивов из одного элемента. После чего выполним процедуру слияния: поддерживаем два указателя, один на текущий элемент первой части, второй – на текущий элемент второй части. Из этих двух элементов выбираем минимальный, вставляем в ответ и сдвигаем указатель, соответствующий минимуму. Так сделаем слияния массивов из 1го элемента в массивы по 2 элемента, затем из 2х в 4 и т.д. Слияние работает за O(n), уровней всего log(n), поэтому асимптотика O(n*log(n)). ', 'PATTERNS_ALGORITHMS', false),
       ('Расскажите про бинарное дерево.', 'Бинарное дерево - иерархическая структура данных, в которой каждый узел может иметь двух потомков. Как правило, первый называется родительским узлом, а наследники называются левым и правым нодами/узлами. Каждый узел в дереве задаёт поддерево, корнем которого он является. Оба поддерева — левое и правое — тоже являются бинарными деревьями. Ноды, которые не имеют потомков, называются листьями дерева. У всех узлов левого поддерева произвольного узла X значения ключей данных меньше, нежели значение ключа данных самого узла X. У всех узлов правого поддерева произвольного узла X значения ключей данных больше либо равны, нежели значение ключа данных самого узла X. Этим достигается упорядоченная структура данных, то есть всегда отсортированная.\n\n
Поиск в лучшем случае - O(log(n)), худшем - O(n) -  при вырождении в связанный список.', 'PATTERNS_ALGORITHMS', false),
       ('Расскажите про красно-черное дерево.', 'Усовершенствованная версия бинарного дерева. Каждый узел в к/ч дереве имеет дополнительное поле - цвет. К/ч дерево отвечает следующим требованиям:\n\n
1) Узел либо красный, либо черный.\n\n
2) Корень - черный.\n\n
3) Все листья - черные и не хранят данных.\n\n
4) Оба потомка каждого красного узла - черные.\n\n
5) Любой простой путь от узла-предка до листового узла-потомка содержит одинаковое число черных узлов. Если не одинаковое, то происходит переворот.\n\n
При добавлении постоянно увеличивающихся/уменьшающихся чисел в бинарное дерево, оно вырождается в связанный список и теряет свои преимущества. Тогда как к/ч дерево может потребовать до двух поворотов для поддержки сбалансированности, чтобы избежать вырождения.\n\n
При операциях удаления в бинарном дереве для удаляемого узла надо найти замену. К/ч дерево сделает тоже самое, но потребует до трёх поворотов для поддержки сбалансированности.\n\n
В этом и состоит преимущство.\n\n
Сложность поиска, вставки и удаления — O(log(n))', 'PATTERNS_ALGORITHMS', false),
       ('Расскажите про линейный и бинарный поиск.', 'Линейный поиск - сложность O(n), так как все элементы проверяются по очереди.\n\n
Бинарный поиск - O(log(n)). Массив должен быть отсортирован. Происходит поиск индекса в массиве, содержащего искомое значение.\n\n
1) Берем значение из середины массива и сраваем с искомым. Индекс середины считается по формуле mid = (high + low) / 2\n\n
low - индекс начала левого подмассива, high - индекс конца правого подмассива.\n\n
2) Если значение в середине больше искомого, то рассматриваем левый подмассив и high = middle - 1\n\n
3) Если меньше, то правый и low = middle + 1\n\n
4) Повторяем, пока mid не страновится равен искомому элементу или подмассив не станет пустым.', 'PATTERNS_ALGORITHMS', false);