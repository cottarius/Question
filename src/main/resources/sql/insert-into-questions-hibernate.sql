INSERT INTO questions (question, answer, theme, is_impotent)
VALUES ('Что такое ORM? Что такое JPA? Что такое Hibernate?', 'ORM(Object Relational Mapping) - технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования.\n\n JPA(Java Persistence API) - это стандартная для Java спецификация, описывающая принципы ORM. JPA не умеет работать с объектами, а только определяет правила как должен действовать каждый провайдер (Hibernate, EclipseLink), реализующий стандарт JPA\n\n (Plain Old Java Object - POJO)\n  Hibernate - библиотека, являющаяся реализацией этой спецификации, в которой можно использовать стандартные API-интерфейсы JPA.\n\n
Важные интерфейсы Hibernate:\n * Session - обеспечивает физическое соединение между приложением и БД. Основная функция - предлагать DML-операции для экземпляров сущностей.\n * SessionFactory - это фабрика для объектов Session. Обычно создается во время запуска приложения и сохраняется для последующего использования. Является потокобезопасным объектом и используется всеми потоками приложения.\n * Transaction - однопоточный короткоживущий объект, используемый для атомарных операций. Это абстракция приложения от основных JDBC транзакций. Session может занимать несколько Transaction в определенных случаях, является необязательным API./n * Query - интерфейс позволяет выполнять запросы к БД. Запросы написаны на HQL или на SQL.', 'HIBERNATE_JDBC', false),
       ('Что такое EntityManager?', 'EntityManager это интерфейс, который описывает API для всех основных операций над Enitity, получение данных и других сущностей JPA. По сути главный API для работы с JPA.\n\n Основные операции:\n
1) Для операций над Entity: persist (добавление Entity под управление JPA), merge (обновление), remove (удаления), refresh (обновление данных), detach (удаление из управление JPA), lock (блокирование Enity от изменений в других thread)\n\n
2) Получение данных: find (поиск и получение Entity), createQuery, createNamedQuery, createNativeQuery, contains, createNamedStoredProcedureQuery, createStoredProcedureQuery\n\n
3) Получение других сущностей JPA: getTransaction, getEntityManagerFactory, getCriteriaBuilder, getMetamodel, getDelegate\n\n
4) Работа с EntityGraph: createEntityGraph, getEntityGraph\n\n
5) Общие операции над EntityManager или всеми Entities: close, isOpen, getProperties, setProperty, clear', 'HIBERNATE_JDBC', false),
       ('Каким условиям должен удовлетворять класс чтобы являться Entity?', 'Entity это легковесный хранимый объект бизнес логики. Основная программная сущность это entity-класс, который так же может использовать дополнительные классы, которые могут использоваться как вспомогательные классы или для сохранения состояния еntity.\n\n
1) Entity класс должен быть помечен аннотацией Entity или описан в XML файле\n 2) Entity класс должен содержать public или protected конструктор без аргументов (он также может иметь конструкторы с аргументами) - при получении данных из БД и формировании из них объекта сущности, Hibernate должен создать этот самый объект сущности\n 3) Entity класс должен быть классом верхнего уровня (top-level class)\n 4) Entity класс не может быть enum или интерфейсом\n 5) Entity класс не может быть финальным классом (final class)\n 6) Entity класс не может содержать финальные поля или методы, если они участвуют в маппинге (persistent final methods or persistent final instance variables)\n 7) Если объект Entity класса будет передаваться по значению как отдельный объект (detached object), например через удаленный интерфейс (through a remote interface), он так же должен реализовывать Serializable интерфейс\n 8) Поля Entity класс должны быть напрямую доступны только методам самого Entity класса и не должны быть напрямую доступны другим классам, использующим этот Entity. Такие классы должны обращаться только к методам (getter/setter методам или другим методам бизнес-логики в Entity классе)\n 9) Entity класс должен содержать первичный ключ, то есть атрибут или группу атрибутов которые уникально определяют запись этого Entity класса в базе данных
', 'HIBERNATE_JDBC', false),
       ('Может ли абстрактный класс быть Entity?', 'Может, при этом он сохраняет все свойства Entity, отличается от обычных Entity классов только тем, что нельзя создать объект этого
класса. Абстрактные Entity классы используются в наследовании, когда их потомки
наследуют поля абстрактного класса', 'HIBERNATE_JDBC', false),
       ('Может ли Entity класс наследоваться от не Entity классов (non-entity classes)?', 'Может', 'HIBERNATE_JDBC', false),
       ('Может ли Entity класс наследоваться от других Entity классов?', 'Может', 'HIBERNATE_JDBC', false),
       ('Может ли не Entity класс наследоваться от Entity класса?', 'Может', 'HIBERNATE_JDBC', false),
       ('Что такое встраиваемый (Embeddable) класс? Какие требования JPA устанавливает к встраиваемым (Embeddable) классам?', 'Embeddable класс - это класс, который не используется сам по себе, а является частью одного или нескольких Entity-классов. Entity-класс может содержать как одиночные встраиваемые классы, так и коллекции таких классов. Также такие классы могут быть использованы как ключи или значения map. Во время выполнения каждый встраиваемый класс принадлежит только одному объекту Entity-класса и не может быть использован для передачи данных между объектами Entity-классов (то есть такой класс не является общей структурой данных для разных объектов). В целом, такой класс служит для того чтобы выносить определение общих атрибутов для нескольких Entity.\n\n
1. Такие классы должны удовлетворять тем же правилам что Entity классы, за исключением того что они не обязаны содержать первичный ключ и быть отмечены аннотацией Entity\n\n 2. Embeddable класс должен быть помечен аннотацией @Embeddable или описан в XML файле конфигурации JPA. А поле этого класса в Entity аннотацией @Embedded. От Embeddable класса нельзя наследоваться - конечный класс Стоит использовать если класс конечный\n\n
Embeddable-класс может содержать другой встраиваемый класс. Embeddable Person может имент поле класса Adress - тогда в Student пишем adress.имяполя.\n\n
Встраиваемый класс может содержать связи с другими Entity или коллекциями Entity, если такой класс не используется как первичный ключ или ключ map''ы. Так как мы можем встраивать классы в неограниченное количество других классов, то у каждого класса, содержащего встраиваемый класс, мы можем изменить названия полей из встраиваемого класса. Например, у класса Driver поля из встраиваемого класса Person будут изменены с name на driver_name и с age на driver_age. Делаем с помощью аннотации AttributeOverride - также класс Embeddable "Person" может быть встроет в Studen и с помощью AttributeOverride можно задать для 2 персон "муж и жен пол" 2 разделения. @AssociationOverride - в Embeddable Person есть объект Embeddable Adress а в нем связть MonyToOne с другой таблицой Street для этого в Studen ставим аннотацию @AssociationOverride над Person и подключаем @AssociationOverride(name = adress.street joinColumns = @JoinColumn(name))', 'HIBERNATE_JDBC', false),
       ('Что такое Mapped Superclass?', 'Mapped Superclass - (позволяет обойти блокировку наследования Embeddable-классов, то есть от такого класса мы можем наследоваться, также в классе Entity если мы используем класс MappedSuperclass то над ним нужно ставить аннтотацию @Embedded)  это класс, от которого наследуются Entity , он может содержать анотации JPA, однако сам такой класс не является Entity, ему не обязательно выполнять все требования установленные для Entity (например, он может не содержать первичного ключа). Такой класс не может использоваться в операциях EntityManager или Query. Такой класс должен быть отмечен аннотацией MappedSuperclass или описан в xml файле.\n
Создание такого класса-предка оправдано тем, что мы заранее определяем ряд свойств и методов, которые должны быть определены в сущностях. Использование такого подхода позволило сократить количество кода.', 'HIBERNATE_JDBC', false),
       ('Какие три типа стратегий наследования мапинга (Inheritance Mapping Strategies) описаны в JPA?', 'Inheritance Mapping Strategies Стратегии наследования нужны для того, чтобы дать понять провайдеру (Hibernate) как ему отображать в БД сущности-наследники: 1) Одна таблица на всю иерархию классов (SINGLE_TABLE) — все enity, со всеми наследниками записываются в одну таблицу, для идентификации типа entity определяется специальная колонка “discriminator column”. Например, если есть entity Animals c классами-потомками Cats и Dogs, при такой стратегии все entity записываются в таблицу Animals, но при это имеют дополнительную колонку animalType в которую соответственно пишется значение «cat» или «dog». Минусом является то что в общей таблице, будут созданы все поля уникальные для каждого из классов-потомков, которые будет пусты для всех других классов-потомков. Например, в таблице animals окажется и скорость лазанья по дереву от cats и может ли пес приносить тапки от dogs, которые будут всегда иметь null для dog и cat соотвественно. Минусом стратегии является невозможность применения ограничения NOT NULL для тех колонок таблицы, которые характерны только для классов-наследников., но можно использовать тригеры. Является стратегией по умолчанию. @DiscriminatorColumn(name = "EMP_TYPE") - имя общей колонки указывающий на принодлежность к классу @DiscriminatorValue("P") - указывает какое имя будет отображенно в @DiscriminatorColumn\n\n
2) Стратегия «соединения» (JOINED) — В данной стратегии корневой класс иерархии представлен отдельной таблицей, а каждый класс-наследник имеет свою таблицу, в которой отображены только поля этого класса-наследника., дополнительно устанавливается связь (relationships) между этими таблицами, например в случае классов Animals (см.выше), будут три таблицы animals, cats, dogs, причем в cats будет записана только ключ и скорость лазанья, в dogs — ключ и умеет ли пес приносить палку, а в animals все остальные данные cats и dogs c ссылкой на соответствующие таблицы. Минусом тут являются потери производительности от объединения таблиц (join) для любых операций. @Id, который должен быть определен только в родительской таблице.\n\n
3) Таблица для каждого класса (TABLE_PER_CLASS) — каждый отдельный класс-наследник имеет свою таблицу,Во всех таблицах подклассов хранятся все поля этого класса плюс те, которые унаследованы от суперкласса. т.е. для cats и dogs (см.выше) все данные будут записываться просто в таблицы cats и dogs как если бы они вообще не имели общего суперкласса. Минусом является плохая поддержка полиморфизма (polymorphic relationships) и то что для выборки всех классов иерархии потребуются большое количество отдельных sql запросов или использование UNION запроса.  Для задания стратегии наследования используется аннотация Inheritance (или соответствующие блоки)', 'HIBERNATE_JDBC', false),
       ('Как мапятся Enum`ы?', 'В JPA (Java Persistence API) перечисления (Enum) могут быть отображены на базу данных различными способами:\n\n
1. **Ординальный маппинг (Ordinal Mapping)**. Значения Enum сохраняются в базе данных в виде числового индекса (порядкового номера).\n\n
2. **Строковый маппинг (String Mapping)**. Значения Enum сохраняются в базе данных в виде соответствующих строковых значений.\n\n
3. **Собственный маппинг (Custom Mapping)**. Можно создать класс-конвертер, реализующий интерфейс AttributeConverter, и затем аннотировать поле Enum аннотацией @Convert, указав созданный конвертер.', 'HIBERNATE_JDBC', false),
       ('Как мапятся даты (до java 8 и после)?', 'Аннотация @Temporal до Java 8, в которой надо было указать какой тип даты мы хотим использовать.\n
В Java 8 и далее аннотацию ставить не нужно. java.time Все классы в новом API неизменяемые (immutable) и, как следствие,
потоко-безопасные. Точность представления времени составляет одну наносекунду,
что в миллион раз точнее чем в пакете java.util.', 'HIBERNATE_JDBC', false),
       ('Как “смапить” коллекцию примитивов?', ' @ElementCollection\n
 @OrderBy\n
Если у нашей сущности есть поле с коллекцией, то мы привыкли ставить над ним аннотации @OneToMany либо @ManyToMany. Но данные аннотации применяются в случае, когда это коллекция других сущностей (entities). Если у нашей сущности коллекция не других сущностей, а базовых или встраиваемых (embeddable) типов для этих случаев в JPA имеется специальная аннотация @ElementCollection, которая указывается в классе сущности над полем коллекции. Все записи коллекции хранятся в отдельной таблице, то есть в итоге получаем две таблицы: одну для сущности, вторую для коллекции элементов.\n\n
При добавлении новой строки в коллекцию, она полностью очищается и заполняется заново, так как у элементов нет id. Можно решить с помощью @OrderColumn\n
 @CollectionTable - позволяет редактировать таблицу с коллекцией, прочитать', 'HIBERNATE_JDBC', false),
       ('Какие есть виды связей?', 'Существуют 4 типа связей:\n 1. OneToOne - когда один экземпляр Entity может быть связан не больше чем с одним экземпляром другого Entity.\n 2. OneToMany - когда один экземпляр Entity может быть связан с несколькими экземплярами других Entity.\n 3. ManyToOne - обратная связь для OneToMany. Несколько экземпляров Entity могут быть связаны с одним экземпляром другого Entity.\n 4. ManyToMany - экземпляры Entity могут быть связаны с несколькими экземплярами друг друга.\n\n
Каждую из которых можно разделить ещё на два вида:\n 1. Bidirectional Владеемая сторона в двунаправленных отношениях должна ссылаться на владеющую сторону используя элемент mappedBy аннотаций @OneToOne, @OneToMany, или @ManyToMany. Элемент mappedBy определяет поле в объекте, который является владельцем отношения.\n 2. Undirectional В однонаправленных отношениях только одна сущность имеет поле, которое ссылается на вторую сущность. Вторая сущность (сторона) не имеет поля первой сущности и не знает об отношениях. Элемент mappedBy определяет поле в объекте, который является владельцем отношения.\n\n
                                   * Bidirectional (Двунаправленные отношения) — ссылка на связь устанавливается у всех Entity, то есть в случае OneToOne A-B в Entity A есть ссылка на Entity B, в Entity B есть ссылка на Entity A. Entity A считается владельцем этой связи (это важно для случаев каскадного удаления данных, тогда при удалении A также будет удалено B, но не наоборот).\n
* Undirectional- ссылка на связь устанавливается только с одной стороны, то есть в случае OneToOne A-B только у Entity A будет ссылка на Entity B, у Entity B ссылки на A не будет.', 'HIBERNATE_JDBC', false),
       ('Что такое владелец связи?', 'В отношениях между двумя сущностями всегда есть одна владеющая сторона, а владеемой может и не быть, если это однонаправленные отношения.\n\n
По сути, у кого есть внешний ключ на другую сущность - тот и владелец связи. То есть, если в таблице одной сущности есть колонка, содержащая внешние ключи от другой сущности, то первая сущность признаётся владельцем связи, вторая сущность - владеемой.\n\n
В однонаправленных отношениях сторона, которая имеет поле с типом другой сущности, является владельцем этой связи по умолчанию.', 'HIBERNATE_JDBC', false),
       ('Что такое каскады?', 'Когда выполняется какое-либо действие над целевым объектом, то же самое действие будет применено к связанному объекту.\n
Каскадирования  можно  добиться,  указав  у  любой  из  аннотаций  @OneToOne, @ManyToOne, @OneToMany, @ManyToMany элемент cascade и присвоив ему одно или несколько значений из перечисления CascadeType\n\n
* ALL - все персистные события будут переданы дочернему объекту\n
* DETACH - отключает все связанные сущности при ручном отключении\n
* MERGE - возвращает все связанные сущности в persistant context\n
* PERSIST - операции save() или pesist() какскадно передаются связанным объектам\n
* REFRESH - посторон считывают значение связаннх сущностей при вызове refresh()\n
* REMOVE - удаляет все связанные сущности\n
Как  правило  каскадные  операции  применяются  от  родительской  сущности  к дочерним, но они могут распространяться и в обратном направлении - от дочерней к родительской.', 'HIBERNATE_JDBC', false),
       ('Что такое orphanRemoval?', 'Два состояния: true и false\n
**True** - при удалении объекта этот объект удаляется из БД\n
**False -** при удалении объекта этот объект НЕ удаляется из БД. Просто его внешний ключ обнуляется и объект больше ни на что не ссылаетсяДва состояния: true и false', 'HIBERNATE_JDBC', false),
       ('Разница между PERSIST и MERGE?', 'persist(entity) следует использовать с совершенно новыми объектами, чтобы добавить их в БД (если объект уже существует в БД, будет выброшено исключение EntityExistsException).\n\n
Но в случае merge(entity) сущность, которая уже управляется в контексте персистентности, будет заменена новой сущностью (обновленной), и копия этой обновленной сущности вернется обратно. Но рекомендуется использовать для уже сохраненных сущностей.', 'HIBERNATE_JDBC', false),
       ('Какие два типа fetch стратегии в JPA вы знаете?', '1) LAZY — Hibernate может загружать данные не сразу, а при первом обращении к ним, но так как это необязательное требование, то Hibernate имеет право изменить это поведение и загружать их сразу. Это поведение по умолчанию для полей, аннотированных @OneToMany, @ManyToMany и @ElementCollection. В объект загружается прокси lazy-поля.\n\n
2) EAGER — данные поля будут загруженны немедленно. Это поведение по умолчанию для полей, аннотированных @Basic, @ManyToOne и @OneToOne.', 'HIBERNATE_JDBC', true),
       ('Какие четыре статуса жизненного цикла Entity объекта (Entity Instance’s Life Cycle) вы можете перечислить?', '1. Transient (New) — свежесозданная оператором new() сущность не имеет связи с базой данных, не имеет данных в базе данных и не имеет сгенерированных первичных ключей.\n
2. managed - объект создан, сохранён в бд, имеет primary key, управляется JPA\n
3. detached -объект создан, имеет primary key, не является (или больше не является) частью контекста персистентности (не управляется JPA);\n
4. removed - объект создан, управляется JPA, будет удален при commit-е и статус станет опять detached', 'HIBERNATE_JDBC', true),
       ('Как влияет операция persist на Entity объекты каждого из четырех статусов?', 'new → managed, и объект будет сохранен в базу при commit-е транзакции или в результате flush операций\n\n
managed → операция игнорируется, однако зависимые Entity могут поменять статус на managed, если у них есть аннотации каскадных изменений\n\n
detached → exception сразу или на этапе commit-а транзакции\n\n
removed → managed, но только в рамках одной транзакции. ', 'HIBERNATE_JDBC', false),
       ('Как влияет операция remove на Entity объекты каждого из четырех статусов?', 'new → операция игнорируется, однако зависимые Entity могут поменять статус на removed, если у них есть аннотации каскадных изменений и они имели статус managed\n\n
managed → removed и запись объект в базе данных будет удалена при commit-е транзакции (также произойдут операции remove для всех каскадно зависимых объектов)\n\n
detached → exception сразу или на этапе commit-а транзакции\n\n
removed → операция игнорируется', 'HIBERNATE_JDBC', false),
       ('Как влияет операция merge на Entity объекты каждого из четырех статусов?', 'new → будет создана новая managed entity, в которую будут скопированы данные объекта.\n\n
managed → операция игнорируется, однако операция merge сработает на каскадно зависимых entity, если их статус не managed.\n\n
removed → exception сразу или на этапе commit-а транзакции.\n\n
detached → либо данные будут скопированы в существующую БД managed entity с тем же пер', 'HIBERNATE_JDBC', false),
       ('Как влияет операция refresh на Entity объекты каждого из четырех статусов?', 'managed → будут восстановлены все изменения из базы данных данного Entity, также произойдет refresh всех каскадно зависимых объектов\n\n
new, removed, detached → exception
', 'HIBERNATE_JDBC', false),
       ('Как влияет операция detach на Entity объекты каждого из четырех статусов?', 'managed, removed → detached.\n\n
new, detached → операция игнорируется
', 'HIBERNATE_JDBC', false),
       ('Для чего нужна аннотация Basic?', ' @Basic - указывает на простейший тип маппинга данных на колонку таблицы базы данных. Также в параметрах аннотации можно указать fetch стратегию доступа к полю и является ли это поле обязательным или нет. Может быть применена к полю любого из следующих типов:\n\n
1. Примитивы и их обертки.\n
2. java.lang.String\n
3. java.math.BigInteger\n
4. java.math.BigDecimal\n
5. java.util.Date\n
6. java.util.Calendar\n
7. java.sql.Date\n
8. java.sql.Time\n
9. java.sql.Timestamp\n
10. byte[] or Byte[]\n
11. char[] or Character[]\n
12. enums\n
13. любые другие типы, которые реализуют Serializable.\n
Вообще, аннотацию @Basic можно не ставить, как это и происходит по умолчанию.\n\n
        Аннотация @Basic определяет 2 атрибута:\n
1. optional - boolean (по умолчанию true) - определяет, может ли значение поля или свойства быть null. Игнорируется для примитивных типов. Но если тип поля не примитивного типа, то при попытке сохранения сущности будет выброшено исключение.\n
2. fetch - FetchType (по умолчанию EAGER) - определяет, должен ли этот атрибут извлекаться незамедлительно (EAGER) или лениво (LAZY). Однако, это необязательное требование JPA, и провайдерам разрешено незамедлительно загружать данные, даже для которых установлена ленивая загрузка.\n\n
Без аннотации @Basic при получении сущности из БД по умолчанию её поля базового типа загружаются принудительно (EAGER) и значения этих полей могут быть null', 'HIBERNATE_JDBC', false),
       ('Для чего нужна аннотация Column?', 'Через аннотацию @Column можно явно указать поведение столбца. Если откроете ее реализацию, то увидите, что столбцу можно задавать такие свойства, как уникальность, обновляемость и т.д.\n\n
@Basic vs @Column:\n 1. Атрибуты @Basic применяются к сущностям JPA, тогда как атрибуты @Column применяются к столбцам базы данных.\n 2. @Basic имеет атрибут optional, который говорит о том, может ли поле объекта быть null или нет; с другой стороны атрибут nullable аннотации @Column указывает, может ли соответствующий столбец в таблице быть null.\n 3. Мы можем использовать @Basic, чтобы указать, что поле должно быть загружено лениво.\n 4. Аннотация @Column позволяет нам указать имя столбца в таблице и ряд других свойств:\n a. insertable/updatable - можно ли добавлять/изменять данные в колонке, по умолчанию true;\n  b. length - длина, для строковых типов данных, по умолчанию 255.\n Коротко, в Column (колум) мы задаем constraints (констрейнтс), а в Basic (бейсик) - ФЕТЧ ТАЙП
', 'HIBERNATE_JDBC', false),
       ('Для чего нужна аннотация Access?', 'Она определяет тип доступа (access type) для класса entity, Mapped Superclass, embeddable или отдельных атрибутов, то есть как JPA будет обращаться к атрибутам entity, как к полям класса (FIELD) или как к свойствам класса (PROPERTY), имеющие гетеры (getter) и сетеры (setter).\n\n  Определяет тип доступа к полям сущности. Для чтения и записи этих полей есть два подхода:\n 1. Field access (доступ по полям). При таком способе аннотации маппинга (Id, Column,...) размещаются над полями, и Hibernate напрямую работает с полями сущности, читая и записывая их.\n 2. Property access (доступ по свойствам). При таком способе аннотации размещаются над методами-геттерами, но никак не над сеттерами. Hibernate использует их и сеттеры для чтения и записи полей сущности.\n\n
По умолчанию тип доступа определяется местом, в котором находится аннотация @Id. Если она будет над полем - это будет AccessType.FIELD, если над геттером - это AccessType.PROPERTY.\n Чтобы явно определить тип доступа у сущности, нужно использовать аннотацию @Access, которая может быть указана у сущности, Mapped Superclass и Embeddable class, а также над полями или методами.\n Поля, унаследованные от суперкласса, имеют тип доступа этого суперкласса.\n Когда у одной сущности определены разные типы доступа, то нужно использовать аннотацию @Transient для избежания дублирования маппинга.', 'HIBERNATE_JDBC', false),
       ('Для чего нужна аннотация @Cacheable?', ' @Cacheable - необязательная аннотация JPA, используется для указания того, должна ли сущность храниться в кэше второго уровня. JPA говорит о пяти значениях shared-cache-mode из persistence.xml, который определяет как будет использоваться second-level cache:\n\n
❖ ENABLE_SELECTIVE: (дефолтное и рекомендуемое значение):только сущности с аннотацией @Cacheable (равносильно значению по умолчанию @Cacheable(value=true)) будут сохраняться в кэше второго уровня.\n\n
❖ DISABLE_SELECTIVE: все сущности будут сохраняться в кэше второго уровня, за исключением сущностей, помеченных @Cacheable(value=false) как некэшируемые.\n\n
❖ ALL: сущности всегда кэшируются, даже если они помечены как некэшируемые.\n\n
❖ NONE: ни одна сущность не кэшируется, даже если помечена как кэшируемая. При данной опции имеет смысл вообще отключить кэш второго уровня.\n\n
❖ UNSPECIFIED: применяются значения по умолчанию для кэша второго уровня, определенные Hibernate. Это эквивалентно тому, что вообще не используется shared-cache-mode, так как Hibernate не включает кэш второго уровня, если используется режим UNSPECIFIED.\n\n
Аннотация @Cacheable размещается над классом сущности. Её действие распространяется на эту сущность и её наследников, если они не определили другое поведение.', 'HIBERNATE_JDBC', false),
       ('Для чего нужна аннотация @Cache?', 'Это аннотация Hibernate, настраивающая тонкости кэширования объекта в кэше второго уровня Hibernate. @Cache принимает три параметра:\n\n
❖ include - имеет по умолчанию значение all и означающий кэширование всего объекта. Второе возможное значение - non-lazy, запрещает кэширование лениво загружаемых объектов. Кэш первого уровня не обращает внимания на эту директиву и всегда кэширует лениво загружаемые объекты.\n\n
❖ region - позволяет задать имя региона кэша для хранения сущности. Регион можно представить как разные области кэша, имеющие разные настройки на уровне реализации кэша. Например, можно было бы создать в конфигурации ehcache два региона, один с краткосрочным хранением объектов, другой с долгосрочным и отправлять часто изменяющиеся объекты в первый регион, а все остальные - во второй. Ehcache по умолчанию создает регион для каждой сущности с именем класса этой сущности, соответственно в этом регионе хранятся только эти сущности. К примеру, экземпляры Foo хранятся в Ehcache в кэше с именем “com.baeldung.hibernate.cache.model.Foo”.\n\n
❖ usage - задаёт стратегию одновременного доступа к объектам.\n
transactional\n
read-write\n
nonstrict-read-write\n
read-only', 'HIBERNATE_JDBC', false),
       ('Для чего нужны аннотации @Embedded и @Embeddable?', '@Embeddable - аннотация JPA, размещается над классом для указания того, что класс является встраиваемым в другие классы.\n\n
@Embedded - аннотация JPA, используется для размещения над полем в классе-сущности для указания того, что мы внедряем встраиваемый класс.', 'HIBERNATE_JDBC', false),
       ('Как смапить составной ключ?', 'Для маппинга составного ключа (composite key) в JPA (Java Persistence API) можно использовать несколько подходов, в зависимости от требований и структуры данных:\n\n
1. Аннотация @EmbeddedId. Создайте класс, который представляет составной ключ, и пометьте его аннотацией @Embeddable. Затем в основной сущности используйте аннотацию @EmbeddedId для указания поля, которое будет содержать составной ключ.\n\n
2. Аннотация @IdClass**. Создайте класс, который представляет составной ключ, и пометьте его аннотацией @IdClass. Затем в основной сущности используйте аннотацию @IdClass для указания класса составного ключа.\n\n
В обоих случаях важно, чтобы класс составного ключа реализовывал методы equals() и hashCode(), чтобы обеспечить правильное сравнение и идентификацию составного ключа.', 'HIBERNATE_JDBC', false),
       ('Для чего нужна аннотация ID? Какие @GeneratedValue вы знаете?', 'Аннотация @Id определяет простой (не составной) первичный ключ, состоящий из одного поля. В соответствии с JPA, допустимые типы атрибутов для первичного ключа:\n 1. примитивные типы и их обертки;\n 2. строки;\n 3. BigDecimal и BigInteger;\n 4. java.util.Date и java.sql.Date.\n\n
Если мы хотим, чтобы значение первичного ключа генерировалось для нас автоматически, мы можем добавить первичному ключу, отмеченному аннотацией @Id, аннотацию @GeneratedValue. Аннотация @GeneratedValue предназначена для настройки способа приращения указанного столбца(поля).\n Возможно 4 варианта:\n  AUTO(default) - Указывает, что Hibernate должен выбрать подходящую стратегию для конкретной базы данных, учитывая её диалект, так как у разных БД разные способы по умолчанию. Поведение по умолчанию - исходить из типа поля идентификатора.\n  IDENTITY - для генерации значения первичного ключа будет использоваться столбец IDENTITY, имеющийся в базе данных. Значения в столбце автоматически увеличиваются вне текущей выполняемой транзакции(на стороне базы, так что этого столбца мы не увидим), что позволяет базе данных генерировать новое значение при каждой операции вставки. В промежутках транзакций сущность будет сохранена.\n\n
SEQUENCE - тип генерации, рекомендуемый документацией Hibernate. Для получения значений первичного ключа Hibernate должен использовать имеющиеся в базе данных механизмы генерации последовательных значений (Sequence). В бд можно будет увидеть дополнительную таблицу. Но если наша БД не поддерживает тип SEQUENCE, то Hibernate автоматически переключится на тип TABLE. В промежутках транзакций сущность не будет сохранена, так как хибер возьмет из таблицы id hibernate-sequence и вернётся обратно в приложение.\n SEQUENCE - это объект базы данных, который генерирует инкрементные целые числа при каждом последующем запросе.\n TABLE - Hibernate должен получать первичные ключи для сущностей из создаваемой для этих целей таблицы, способной содержать именованные сегменты значений для любого количества сущностей. Требует использования пессимистических блокировок, которые помещают все транзакции в последовательный порядок и замедляет работу приложения.
', 'HIBERNATE_JDBC', false),
       ('Расскажите про аннотации @JoinColumn и @JoinTable? Где и для чего они используются?', ' @JoinColumn используется для указания столбца FOREIGN KEY, используемого при установлении связей между сущностями или коллекциями. Мы помним, что только сущность-владелец связи может иметь внешние ключи от другой сущности (владеемой). Однако, мы можем указать @JoinColumn как во владеющей таблице, так и во владеемой, но столбец с внешними ключами всё равно появится во владеющей таблице.\n  Особенности использования:\n
❖ @OneToOne: означает, что появится столбец в таблице сущности-владельца связи, который будет содержать внешний ключ, ссылающийся на первичный ключ владеемой сущности.\n
❖ @OneToMany/@ManyToOne: если не указать на владеемой стороне связи атрибут mappedBy, создается joinTable с ключами обеих таблиц. Но при этом же у владельца создается столбец с внешними ключами.\n\n
 @JoinColumns используется для группировки нескольких аннотаций @JoinColumn, которые используются при установлении связей между сущностями или коллекциями, у которых составной первичный ключ и требуется несколько колонок для указания внешнего ключа.\n В каждой аннотации @JoinColumn должны быть указаны элементы name и referencedColumnName.\n\n
 @JoinTable используется для указания связывающей (сводной, третьей) таблицы между двумя другими таблицами.\n - @JoinTable(name = "CATALOG", joinColumns = @JoinColumn(name = "ID_BOOK"), inverseJoinColumns = @JoinColumn(name = "ID_STUDENT"))\n  private Student student;', 'HIBERNATE_JDBC', false),
       ('Для чего нужны аннотации @OrderBy и @OrderColumn, чем они отличаются?', ' @OrderBy указывает порядок, в соответствии с которым должны располагаться элементы коллекций сущностей, базовых или встраиваемых типов при их извлечении из БД. Если в кэше есть нужные данные, то сортировки не будет.\n Так как @OrderBy просто добавляет к sql-запросу Order By, а при получении данных из кэша, обращения к бд нет. Эта аннотация может использоваться с аннотациями @ElementCollection, @OneToMany, @ManyToMany. При использовании с коллекциями базовых типов, которые имеют аннотацию @ElementCollection, элементы этой коллекции будут отсортированы в натуральном порядке, по значению базовых типов.\n\n
Если это коллекция встраиваемых типов (@Embeddable), то используя точку (".") мы можем сослаться на атрибут внутри встроенного атрибута.\n  Если это коллекция сущностей, то у аннотации @OrderBy можно указать имя поля сущности, по которому сортировать эти самые сущности\n Если мы не укажем у @OrderBy параметр, то сущности будут упорядочены по первичному ключу. \nВ случае с сущностями доступ к полю по точке не работает. Попытка использовать вложенное свойство, например @OrderBy ("supervisor.name") повлечет Runtime Exceprtion.\n\n
 @OrderColumn создает в таблице столбец с индексами порядка элементов, который используется для поддержания постоянного порядка в списке, но этот столбец не считается частью состояния сущности или встраиваемого класса. Hibernate отвечает за поддержание порядка как в базе данных при помощи столбца, так и при получении сущностей и элементов из БД. Hibernate отвечает за обновление порядка при записи в базу данных, чтобы отразить любое добавление, удаление или иное изменение порядка, влияющее на список в таблице.\n\n
 @OrderBy vs @OrderColumn Порядок, указанный в @OrderBy, применяется только в рантайме при выполнении запроса к БД, То есть в контексте персистентности, в то время как при использовании @OrderColumn, порядок сохраняется в отдельном столбце таблицы и поддерживается при каждой вставке/обновлении/удалении элементов.', 'HIBERNATE_JDBC', false),
       ('Для чего нужна аннотация Transient?', ' @Transient используется для объявления того, какие поля у сущности, встраиваемого класса или Mapped SuperClass не будут сохранены в базе данных.\n
Persistent fields (постоянные поля) - это поля, значения которых будут по умолчанию сохранены в БД. Ими являются любые не static и не final поля.\n
Transient fields (временные поля):\n
❖ static и final поля сущностей;\n
❖ иные поля, объявленные явно с использованием Java-модификатора transient, либо JPA-аннотации @Transient.', 'HIBERNATE_JDBC', false),
       ('Какие шесть видов блокировок (lock) описаны в спецификации JPA (или какие есть значения у enum LockModeType в JPA)?', 'В порядке от самого ненадежного и быстрого, до самого надежного и медленного:\n 1. NONE — без блокировки.\n 2. OPTIMISTIC (синоним READ в JPA 1) — оптимистическая  блокировка, которая работает, как описано ниже: если при завершении транзакции кто-то извне изменит поле @Version, то будет сделан RollBack транзакции и будет выброшено OptimisticLockException.\n 3. OPTIMISTIC_FORCE_INCREMENT (синоним WRITE в JPA 1) — работает по тому же алгоритму, что и LockModeType.OPTIMISTIC за тем исключением, что после commit значение поле Version принудительно увеличивается на 1. В итоге окончательно после каждого коммита поле увеличится на 2(увеличение, которое можно увидеть в Post-Update + принудительное увеличение).\n 4. PESSIMISTIC_READ — данные блокируются в момент чтения и это гарантирует, что никто в ходе выполнения транзакции не сможет их изменить. Остальные транзакции, тем не менее, смогут параллельно читать эти данные. Использование этой блокировки может вызывать долгое ожидание блокировки или даже выкидывание PessimisticLockException.\n 5. PESSIMISTIC_WRITE — данные блокируются в момент записи и никто с момента захвата блокировки не может в них писать и не может их читать до окончания транзакции, владеющей блокировкой. Использование этой блокировки может вызывать долгое ожидание блокировки.\n 6. PESSIMISTIC_FORCE_INCREMENT — ведёт себя как PESSIMISTIC_WRITE, но в конце транзакции увеличивает значение поля @Version, даже если фактически сущность не изменилась.\n Блокировка - в реляционных базах данных это установка метки на запись, что запись заблокирована для изменений.\n\n
Оптимистичное блокирование - подход предполагает, что параллельно выполняющиеся транзакции редко обращаются к одним и тем же данным и позволяет им свободно выполнять любые чтения и обновления данных. Но при окончании транзакции производится проверка, изменились ли данные в ходе выполнения данной транзакции и, если да, транзакция обрывается и выбрасывается OptimisticLockException. Оптимистичное блокирование в JPA реализовано путём внедрения в сущность специального поля версии:\n @Version\n private long version;\n Поле, аннотирование @Version, может быть целочисленным или временнЫм. При завершении транзакции, если сущность была заблокирована оптимистично, будет проверено, не изменилось ли значение @Version кем-либо ещё, после того как данные были прочитаны, и, если изменилось, будет выкинуто OptimisticLockException. Использование этого поля позволяет отказаться от блокировок на уровне базы данных и сделать всё на уровне JPA, улучшая уровень конкурентности. Позволяет отказатьсь от блокировок на уровне БД и делать всё с JPA.\n\n
Пессимистичное блокирование - подход напротив, ориентирован на транзакции, которые часто конкурируют за одни и те же данные и поэтому блокирует доступ к данным в тот момент когда читает их. Другие транзакции останавливаются, когда пытаются обратиться к заблокированным данным и ждут снятия блокировки (или кидают исключение). Пессимистичное блокирование выполняется на уровне базы и поэтому не требует вмешательств в код сущности.\n\n
Блокировки ставятся путём вызова метода lock() у EntityManager, в который передаётся сущность, требующая блокировки и уровень блокировки:\n EntityManager em = entityManagerFactory.createEntityManager();\n em.lock(company1, LockModeType.OPTIMISTIC);', 'HIBERNATE_JDBC', true),
       ('Какие два вида кэшей (cache) вы знаете в JPA и для чего они нужны?', '1. first-level cache (кэш первого уровня) — кэширует данные одной транзакции;\n 2. second-level cache (кэш второго уровня) — кэширует данные транзакций от одной фабрики сессий. Провайдер JPA может, но не обязан реализовывать работу с кэшем второго уровня.\n 3. Кэш запросов.\n\n
Кэш первого уровня – это кэш сессии (Session), который является обязательным, это и есть PersistenceContext. Через него проходят все запросы. В том случае, если мы выполняем несколько обновлений объекта, Hibernate старается отсрочить (насколько это возможно) обновление этого объекта для того, чтобы сократить количество выполненных запросов в БД. Например, при пяти истребованиях одного и того же объекта из БД в рамках одного persistence context, запрос в БД будет выполнен один раз, а остальные четыре загрузки будут выполнены из кэша. Если мы закроем сессию, то все объекты, находящиеся в кэше, теряются, а далее – либо сохраняются в БД, либо обновляются.\n\n
Особенности кэша первого уровня:\n ❖ включен по умолчанию, его нельзя отключить;\n ❖ связан с сессией (контекстом персистентности), то есть разные сессии видят только объекты из своего кэша, и не видят объекты, находящиеся в кэшах других сессий;\n ❖ при закрытии сессии PersistenceContext очищается - кэшированные объекты, находившиеся в нем, удаляются;\n ❖ при первом запросе сущности из БД, она загружается в кэш, связанный с этой сессией;\n ❖ если в рамках этой же сессии мы снова запросим эту же сущность из БД, то она будет загружена из кэша, и никакого второго SQL-запроса в БД сделано не будет;\n ❖ сущность можно удалить из кэша сессии методом evict(), после чего следующая попытка получить эту же сущность повлечет обращение к базе данных;\n ❖ метод clear() очищает весь кэш сессии.\n\n
Если кэш первого уровня привязан к объекту сессии, то кэш второго уровня привязан к объекту-фабрике сессий (Session Factory object) и, следовательно, кэш второго уровня доступен одновременно в нескольких сессиях или контекстах персистентности. Кэш второго уровня требует некоторой настройки и поэтому не включен по умолчанию. Настройка кэша заключается в конфигурировании реализации кэша и разрешения сущностям быть закэшированными. Hibernate не реализует сам никакого in-memory сache, а использует существующие реализации кэшей.', 'HIBERNATE_JDBC', false),
       ('Как работать с кешем 2 уровня?', 'Чтение из кэша второго уровня происходит только в том случае, если нужный объект не был найден в кэше первого уровня.\n Hibernate поставляется со встроенной поддержкой стандарта кэширования Java JCache, а также двух популярных библиотек кэширования: Ehcache и Infinispan.\n\n
В Hibernate кэширование второго уровня реализовано в виде абстракции, то есть мы должны предоставить любую её реализацию, вот несколько провайдеров: Ehcache, OSCache, SwarmCache, JBoss TreeCache.\n Для Hibernate требуется только реализация интерфейса org.hibernate.cache.spi.RegionFactory, который инкапсулирует все детали, относящиеся к конкретным провайдерам. По сути, RegionFactory действует как мост между Hibernate и поставщиками кэша. В примерах будем использовать Ehcache. Что нужно сделать: ❖ добавить мавен-зависимость кэш-провайдера нужной версии ❖ включить кэш второго уровня и определить конкретного провайдера hibernate.cache.use_second_level_cache=true hibernate.cache.region.factory_class=org.hibernate.cache.ehcache.EhCacheRegionFactory ❖ установить у нужных сущностей JPA-аннотацию @Cacheable, обозначающую, что сущность нужно кэшировать, и Hibernate-аннотацию @Cache, настраивающую детали кэширования, у которой в качестве параметра указать стратегию параллельного доступа" на "Чтение из кэша второго уровня происходит только в том случае, если нужный объект не был найден в кэше первого уровня. Hibernate поставляется со встроенной поддержкой стандарта кэширования Java JCache, а также двух популярных библиотек кэширования: Ehcache и Infinispan. Shared Cache Mode  ENABLE_SELECTIVE,  ALL, NONE, UNSPECIFIED', 'HIBERNATE_JDBC', false),
       ('Что такое JPQL/HQL и чем он отличается от SQL?', 'Hibernate Query Language (HQL) и Java Persistence Query Language (JPQL) - оба являются объектно-ориентированными языками запросов, схожими по природе с SQL.\n  JPQL - это подмножество HQL.\nn\
HQL - это язык запросов, практически такой же как SQL, однако, вместо имен и колонок таблиц базы данных, он использует имена классов Entity и их атрибуты. В качестве параметров запросов также используются типы данных атрибутов Entity, а не полей баз данных. В отличии от SQL в JPQL есть автоматический полиморфизм, то есть каждый запрос к Entity возвращает не только объекты этого Entity, но также объекты всех его классов-потомков, независимо от стратегии наследования. В JPA запрос представлен в виде javax.persistence.Query или javax.persistence.TypedQuery, полученных из EntityManager.\n\n
В Hibernate HQL-запрос представлен org.hibernate.query.Query, полученный из Session. Если HQL является именованным запросом, то будет использоваться Session#getNamedQuery, в противном случае требуется Session#createQuery.', 'HIBERNATE_JDBC', false),
       ('Что такое Criteria API и для чего он используется?', 'JPA Criteria API - это API, который позволяет делать WHERE (SELECT) запросы гораздо проще. (Динамические запросы).\n  Основные преимущества JPA Criteria API:\n ❖ ошибки могут быть обнаружены во время компиляции;\n ❖ позволяет динамически формировать запросы на этапе выполнения приложения.\n\n Основные недостатки:\n ❖ нет контроля над запросом, сложно отловить ошибку\n ❖ влияет на производительность, множество классов\n  Для динамических запросов - фрагменты кода создаются во время выполнения - JPA Criteria API является предпочтительней.\n\n
Вот некоторые области применения Criteria API:\n * Criteria API поддерживает проекцию, которую мы можем использовать для агрегатных функций вроде sum(), min(), max() и т.д.\n * Criteria API может использовать ProjectionList для извлечения данных только из выбранных колонок./n * Criteria API может быть использована для join запросов с помощью соединения нескольких таблиц, используя методы createAlias(), setFetchMode() и setProjection()./n * Criteria API поддерживает выборку результатов согласно условиям (ограничениям). Для этого используется метод add() с помощью которого добавляются ограничения (Restrictions)./n * Criteria API позволяет добавлять порядок (сортировку) к результату с помощью метода addOrder().', 'HIBERNATE_JDBC', false),
       ('Расскажите про проблему N+1 Select и путях ее решения.', 'Проблема N+1 запросов возникает, когда получение данных из БД выполняется за N дополнительных SQL-запросов для извлечения тех же данных, которые могли быть получены при выполнении основного SQL-запроса.\n Проблема N + 1 возникает, когда фреймворк доступа к данным выполняет N дополнительных SQL-запросов для получения тех же данных, которые можно получить при выполнении одного SQL-запроса.\n Чем больше значение N, тем больше запросов будет выполнено и тем больше влияние на производительность. И хотя лог медленных запросов может вам помочь найти медленные запросы, но проблему N + 1 он не обнаружит, так как каждый отдельный дополнительный запрос выполняется достаточно быстро.\n  Проблема заключается в выполнении множества дополнительных запросов, которые в сумме выполняются уже существенное время, влияющее на быстродействие.\n\n
1. JOIN FETCH И при FetchType.EAGER и при FetchType.LAZY нам поможет JPQL-запрос с JOIN FETCH. Опцию «FETCH» можно использовать в JOIN (INNER JOIN или LEFT JOIN) для выборки связанных объектов в одном запросе вместо дополнительных запросов для каждого доступа к ленивым полям объекта.\n Лучший вариант решения для простых запросов (1-3 уровня вложенности связанных объектов).\n  select pc\n     from PostComment pc\n    join fetch pc.post p\n\n
2. EntityGraph\n В случаях, когда нам нужно получить по-настоящему много данных, и у нас jpql запрос - лучше всего использовать EntityGraph.\n\n
3. @Fetch(FetchMode.SUBSELECT)\n Аннотация Hibernate. Можно использовать только с коллекциями. Будет сделан один sql-запрос для получения корневых сущностей и, если в контексте персистентности будет обращение к ленивым полям-коллекциям, то выполнится еще один запрос для получения связанных коллекций:\n  @Fetch(value = FetchMode.SUBSELECT)\n  private Set<Order> orders = new HashSet<>();\n\n
4. Batch fetching\n Это Аннотация Hibernate, в JPA её нет. Указывается над классом сущности или над полем коллекции с ленивой загрузкой. Будет сделан один sql-запрос для получения корневых сущностей и, если в контексте персистентности будет обращение к ленивым полям-коллекциям, то выполнится еще один запрос для получения связанных коллекций. Количество загружаемых сущностей указывается в аннотации.\n  @BatchSize(size=5)\n private Set<Order> orders = new HashSet<>();\n\n
5. HibernateSpecificMapping, SqlResultSetMapping Для нативных запросов рекомендуется использовать именно их.
', 'HIBERNATE_JDBC', true),
       ('Что такое Entity Graph', 'Он позволяет определить шаблон путем группировки связанных полей, которые мы хотим получить, и позволяет нам выбирать тип графа во время выполнения.Основная цель JPA Entity Graph - улучшить производительность в рантайме при
загрузке базовых полей сущности и связанных сущностей и коллекций.\n Вкратце, Hibernate загружает весь граф в одном SELECT-запросе, то есть все указанные связи от нужной нам сущности. . Работа с EntityGraph: createEntityGraph, getEntityGraph.', 'HIBERNATE_JDBC', true);