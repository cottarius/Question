INSERT INTO questions (question, answer, theme, is_impotent)
VALUES ('git cherry-pick', 'Git cherry-pick - это команда Git, которая позволяет выбрать и применить отдельные коммиты из одной ветки в другую. Она полезна, когда вы хотите перенести изменения из одной ветки в другую без слияния всех коммитов.', 'FASHION_TECHNOLOGIES', false),
       ('Git merge vs rebase', '**Git merge** и **git rebase** - это две разные команды Git, используемые для объединения изменений из нескольких веток. Основное различие между ними заключается в том, как они обрабатывают историю коммитов.\n\n
**Git merge** создает новый коммит, который объединяет изменения из двух или более веток. История коммитов при этом сохраняется линейной, показывая, что ветки были объединены в определенной точке.\n\n
**Git rebase** переписывает историю коммитов, перенося коммиты из одной ветки в другую. Это создает впечатление, что коммиты были изначально сделаны в новой ветке. Переписанная история может быть более упорядоченной и понятной, особенно если в ветке были небольшие или нежелательные изменения.', 'FASHION_TECHNOLOGIES', false),
       ('Git commit – amend', 'Git commit --amend - это команда Git, которая позволяет изменить последний коммит, не создавая нового. Она полезна для внесения небольших изменений в последний коммит, например, исправления ошибок, добавления забытых файлов или изменения сообщения коммита.', 'FASHION_TECHNOLOGIES', false),
       ('Git squash', 'Git squash - это команда Git, которая объединяет несколько коммитов в один. Она полезна для очистки истории коммитов, удаления ненужных или дублирующих коммитов и создания более упорядоченной истории.', 'FASHION_TECHNOLOGIES', false),
       ('6 принципов REST API', 'Шесть принципов REST API (Representational State Transfer - передача репрезентативного состояния):\n\n
1. **Идентификация ресурсов:**\n
Каждый ресурс в API должен иметь уникальный идентификатор, который используется для доступа и управления им.\n\n
2. **Манипуляция ресурсами через представления:**\n
Клиенты взаимодействуют с ресурсами, отправляя запросы и получая ответы в виде представлений ресурсов. Представления могут быть в различных форматах, таких как JSON, XML или HTML.\n\n
3. **Самоописание сообщений:**\n
Сообщения запросов и ответов должны быть самоописывающими, то есть содержать всю необходимую информацию для обработки запроса и интерпретации ответа.\n\n
4. **Единый интерфейс:**\n
API должен предоставлять единый и последовательный интерфейс для доступа к ресурсам. Это упрощает разработку и использование API.\n\n
5. **Без сохранения состояния:**\n
Сервер API не должен хранить состояние сеанса клиента. Каждый запрос должен обрабатываться независимо от предыдущих запросов.\n\n
6. **Кэширование по требованию:**\n
Клиенты могут кэшировать ответы API для повышения производительности, но сервер должен явно указывать, когда кэширование разрешено или запрещено.', 'FASHION_TECHNOLOGIES', false),
       ('Обмен сообщениями в микросервисах', 'Обмен сообщениями в микросервисах - это способ коммуникации между отдельными сервисами в архитектуре микросервисов. Он позволяет сервисам асинхронно отправлять и получать сообщения, что обеспечивает гибкость, масштабируемость и надежность.\n
Вот некоторые преимущества использования обмена сообщениями в микросервисах:\n
**Асинхронная коммуникация:**\n
Сообщения отправляются и получают асинхронно, что означает, что сервисы не блокируются при ожидании ответа. Это повышает производительность и масштабируемость.\n\n
**Свободная связь:**\n
Сервисы, которые обмениваются сообщениями, слабо связаны. Они не зависят напрямую друг от друга и могут разрабатываться и развертываться независимо.\n\n
**Надежная доставка:**\n
Системы обмена сообщениями обычно обеспечивают надежную доставку сообщений, гарантируя, что сообщения не будут потеряны или дублированы.\n\n
**Масштабируемость:**\n
Системы обмена сообщениями могут быть масштабированы для обработки больших объемов сообщений, что делает их подходящими для приложений с высокой нагрузкой.\n\n
Существуют различные технологии обмена сообщениями, которые можно использовать в микросервисах, например:\n\n
**Брокеры сообщений:**\n
Такие системы, как Apache Kafka и RabbitMQ, предоставляют надежную и масштабируемую платформу для обмена сообщениями.\n\n
**HTTP-запросы:**\n
HTTP-запросы также можно использовать для обмена сообщениями между микросервисами, хотя они менее надежны и не обеспечивают такую же гибкость, как системы обмена сообщениями.\n\n
**Удаленный вызов процедур (RPC):**\n
RPC позволяет сервисам напрямую вызывать методы друг друга, что делает обмен сообщениями более явным.', 'FASHION_TECHNOLOGIES', false),
       ('Преимущества очередей', '**Асинхронная обработка:**\n
Очереди позволяют асинхронно обрабатывать задачи, что повышаетпроизводительность и масштабируемость.\n\n
**Надежная доставка:**\n
Системы очередей обычно обеспечивают надежную доставку сообщений, гарантируя, что сообщения не будут потеряны или дублированы.\n\n
**Балансировка нагрузки:**\n
Очереди можно использовать для балансировки нагрузки между несколькими потребителями, что обеспечивает эффективное использование ресурсов.\n\n
**Повторные попытки обработки:**\n
Очереди могут автоматически повторять попытки обработки неудачных сообщений, что повышает надежность системы.\n\n
**Дедупликация сообщений:**\n
Очереди могут автоматически дедуплицировать сообщения, предотвращая повторную обработку дубликатов.\n\n
**Приоритезация сообщений:**\n
Очереди могут поддерживать приоритезацию сообщений, что позволяет важным сообщениям обрабатываться в первую очередь.\n\n
**Простая интеграция:**\n
Системы очередей обычно предоставляют простые в использовании API для интеграции с различными приложениями и системами.', 'FASHION_TECHNOLOGIES', false),
       ('Что такое Apache Kafka и для чего он используется?', 'Apache Kafka - это распределенная, отказоустойчивая, масштабируемая платформа для обработки потоковых данных в режиме реального времени. Она предоставляет механизмы для публикации, подписки, хранения и обработки потоков данных.', 'FASHION_TECHNOLOGIES', false),
       ('Какие ключевые компоненты включают в себя	архитектура Apache Kafka?', 'Основные ключевые компоненты архитектуры Apache Kafka включают в себя:\n\n
1. Производители (Producers):\n
    - Производители - это приложения, которые публикуют (отправляют) данные в Kafka.\n
    - Производители отправляют данные в виде сообщений в темы (topics).\n\n
2. Темы (Topics):\n
    - Темы - это категории или потоки сообщений в Kafka.\n
    - Темы делятся на разделы (partitions), которые распределяют данные по нескольким узлам кластера.\n\n
3. Брокеры (Brokers):\n
    - Брокеры - это серверы Kafka, которые хранят и обрабатывают данные.\n
    - Кластер Kafka состоит из одного или нескольких брокеров.\n\n
4. Потребители (Consumers):\n
    - Потребители - это приложения, которые читают и обрабатывают данные из Kafka.\n
    - Потребители читают данные из тем и обрабатывают их.\n\n
5. Группы потребителей (Consumer Groups):\n
    - Группы потребителей - это логические группы потребителей, которые совместно потребляют данные из одной темы.\n
    - Каждое сообщение в теме доставляется только одному потребителю из группы.\n\n
6. Смещения (Offsets):\n
    - Смещения - это позиция, до которой потребитель прочитал данные в теме.\n
    - Смещения позволяют потребителям возобновлять чтение с последней прочитанной позиции.\n\n
7. Репликация (Replication):\n
    - Репликация - это механизм, который обеспечивает отказоустойчивость Kafka, дублируя разделы на нескольких серверах.\n
    - Репликация гарантирует, что данные будут сохранены, даже если один из серверов выйдет из строя.\n\n
8. Коннекторы (Connectors):\n
    - Коннекторы - это модули, которые упрощают интеграцию Kafka с другими системами, такими как базы данных, файловые хранилища и т.д.\n
    - Коннекторы позволяют автоматизировать ввод и вывод данных в/из Kafka.', 'FASHION_TECHNOLOGIES', false),
       ('Как обеспечивается масштабируемость в Apache Kafka?', 'Apache Kafka обеспечивает масштабируемость за счет нескольких ключевых особенностей:\n\n
1. Партиционирование (Partitioning):\n
    - Темы (topics) в Kafka разделяются на партиции (partitions), которые распределяются по нескольким серверам (брокерам).\n
    - Это позволяет распределять нагрузку между серверами, повышая пропускную способность и горизонтальную масштабируемость.\n\n
2. Репликация (Replication):\n
    - Партиции реплицируются на несколько брокеров, что обеспечивает отказоустойчивость и высокую доступность данных.\n
    - При выходе из строя одного брокера, другие реплики продолжают обслуживать запросы, обеспечивая бесперебойную работу.\n\n
3. Распределенная архитектура:\n
    - Kafka построен на распределенной архитектуре, где множество брокеров работают совместно, образуя кластер.\n
    - При увеличении нагрузки, новые брокеры могут быть добавлены к кластеру, распределяя нагрузку между ними.\n\n
4. Горизонтальное масштабирование:\n
    - Kafka поддерживает горизонтальное масштабирование как для производителей (publishers), так и для потребителей (subscribers).\n
    - Новые производители и потребители могут быть динамически добавлены в систему, не влияя на работу существующих.\n\n
5. Распределенная обработка данных:\n
    - Kafka использует концепцию групп потребителей (consumer groups), где каждый потребитель в группе обрабатывает только свою долю данных.\n
    - Это обеспечивает параллельную обработку данных, увеличивая пропускную способность.\n\n
6. Эффективное хранение:\n
    - Kafka использует эффективные механизмы хранения данных, такие как сегментация файлов и компактирование.\n
    - Это позволяет хранить огромные объемы данных, не снижая.', 'FASHION_TECHNOLOGIES', false),
       ('Что такое RabbitMQ и для чего он используется?', 'RabbitMQ - это открытая платформа для обмена сообщениями, основанная на протоколе AMQP (Advanced Message Queuing Protocol). Она используется для построения распределенных, отказоустойчивых и масштабируемых приложений, использующих асинхронную обработку сообщений.', 'FASHION_TECHNOLOGIES', false),
       ('Какие основные компоненты включает в себя архитектура RabbitMQ?', 'Архитектура RabbitMQ включает в себя следующие основные компоненты:\n\n
1. Брокер сообщений (Message Broker):\n
    - Это центральный компонент RabbitMQ, который отвечает за получение, маршрутизацию и доставку сообщений.\n
    - Брокер может быть развернут в виде кластера для обеспечения высокой доступности и масштабируемости.\n\n
2. Очереди (Queues):\n
    - Очереди являются основными хранилищами сообщений в RabbitMQ.\n
    - Сообщения помещаются в очереди, откуда потребители (consumers) могут их получать.\n\n
3. Обмены (Exchanges):\n
    - Обмены являются точками входа для сообщений, поступающих в RabbitMQ.\n
    - Они отвечают за маршрутизацию сообщений в соответствующие очереди на основе заданных правил.\n\n
4. Связывание (Bindings)\n
    - Связывания определяют правила, по которым обмены направляют сообщения в очереди.\n
    - Они создают логические связи между обменами и очередями.\n\n
5. Производители (Producers):\n
    - Производители - это компоненты, ответственные за отправку сообщений в RabbitMQ.\n
    - Они публикуют сообщения в обмены, которые затем доставляются в соответствующие очереди.\n\n
6. Потребители (Consumers):\n
    - Потребители - это компоненты, получающие сообщения из очередей RabbitMQ.\n
    - Они обрабатывают полученные сообщения в соответствии с логикой приложения.\n\n
7. Плагины (Plugins):\n
    - RabbitMQ поддерживает широкий спектр плагинов, расширяющих его функциональность.\n
    - Например, плагины для мониторинга, управления, безопасности и т.д.', 'FASHION_TECHNOLOGIES', false),
       ('Как работает паттерн Publish-Subscribe в RabbitMQ?', 'Паттерн Publish-Subscribe (Pub/Sub) является одним из основных паттернов обмена сообщениями, реализованных в RabbitMQ. Он позволяет организовать асинхронное взаимодействие между производителями (publishers) и потребителями (subscribers) сообщений.\n\n
Принцип работы Pub/Sub в RabbitMQ:\n\n
1. Производители (Publishers):\n
    - Производители отправляют сообщения в специальный тип обмена (exchange) под названием "topic" или "fanout".\n
    - Производители не знают, какие именно потребители будут получать сообщения. Они просто публикуют сообщения в обмен.\n\n
2. Обмены (Exchanges):\n
    - Обмены "topic" или "fanout" получают сообщения от производителей и направляют их в соответствующие очереди.\n
    - Обмен "topic" маршрутизирует сообщения на основе ключей маршрутизации (routing keys), а обмен "fanout" рассылает сообщения во все связанные очереди.\n\n
3. Очереди (Queues):\n
    - Очереди привязываются (bound) к обменам с помощью ключей маршрутизации (для обмена "topic") или без них (для обмена "fanout").\n
    - Потребители подключаются к очередям и получают сообщения из них.\n\n
4. Потребители (Subscribers):\n
    - Потребители подписываются на одну или несколько очередей, в которые поступают сообщения.\n
    - Когда производитель публикует сообщение, оно доставляется во все очереди, связанные с обменом, и потребители получают эти сообщения.', 'FASHION_TECHNOLOGIES', false),
       ('Как RabbitMQ обеспечивает масштабируемость?', 'RabbitMQ обеспечивает масштабируемость системы благодаря нескольким ключевым механизмам:\n\n
1. Кластеризация:\n
    - RabbitMQ поддерживает возможность объединения нескольких брокеров в кластер.\n
    - Кластер позволяет распределить нагрузку по обработке сообщений между несколькими узлами, повышая производительность системы.\n
    - При этом кластер обеспечивает высокую доступность - даже при сбое одного из узлов, остальные продолжают обслуживать сообщения.\n\n
2. Федерация:\n
    - Федерация позволяет объединять несколько независимых кластеров RabbitMQ в единую логическую сеть.\n
    - Это дает возможность масштабировать систему на более глобальном уровне, распределяя нагрузку между кластерами.\n
    - Федерация также упрощает интеграцию между географически распределенными компонентами приложения.\n\n
3. Очереди с подписчиками:\n
    - RabbitMQ поддерживает концепцию очередей с подписчиками, когда сообщения доставляются всем потребителям, подключенным к очереди.\n
    - Это позволяет легко масштабировать обработку сообщений, добавляя или удаляя потребителей без необходимости изменять логику производителей.\n\n
4. Горизонтальное масштабирование:\n
    - Благодаря возможности кластеризации, RabbitMQ позволяет легко масштабировать систему горизонтально, добавляя или удаляя узлы в кластере.\n
    - Это дает возможность адаптировать вычислительные ресурсы под меняющуюся нагрузку на систему.\n\n
5. Плагины и расширения:\n
    - RabbitMQ предоставляет широкий набор плагинов и расширений, которые помогают в решении задач масштабирования.\n
    - Например, плагины для управления очередями, контроля доступа, мониторинга и т.д.', 'FASHION_TECHNOLOGIES', false),
       ('В чем разница между точками обмена (Direct Exchange), темами (Topic Exchange) и веерами (Fanout Exchange) в RabbitMQ?', 'В RabbitMQ существует несколько типов обменов (exchanges), которые различаются способом маршрутизации сообщений. Вот основные различия между ними:\n\n
1. Direct Exchange:\n
    - Прямой (direct) обмен маршрутизирует сообщения в очереди на основе точного совпадения ключа маршрутизации (routing key).\n
    - Сообщение будет доставлено в очередь, связанную с обменом точным соответствием ключа маршрутизации.\n
    - Это наиболее простой и прямолинейный способ маршрутизации сообщений.\n\n
2. Topic Exchange:\n
    - Тематический (topic) обмен маршрутизирует сообщения на основе шаблонов ключей маршрутизации.\n
    - Шаблон может содержать подстановочные символы, такие как звездочка (*) и решетка (#), позволяющие сопоставлять ключи с более общими правилами.\n
    - Это позволяет реализовать гибкую маршрутизацию сообщений на основе тем или категорий.\n\n
3. Fanout Exchange:\n
    - Веерный (fanout) обмен рассылает сообщения во все очереди, связанные с этим обменом, вне зависимости от ключа маршрутизации.\n
    - Это простой вариант широковещательной рассылки сообщений всем заинтересованным потребителям.\n
    - Данный тип обмена не использует ключи маршрутизации, а просто копирует сообщение во все связанные очереди.\n\n
Основные различия:\n\n
- Direct Exchange использует точное совпадение ключа маршрутизации.\n
- Topic Exchange использует шаблоны ключей маршрутизации для гибкой фильтрации.\n
- Fanout Exchange рассылает сообщения во все связанные очереди, игнорируя ключи маршрутизации.', 'FASHION_TECHNOLOGIES', false),
       ('В чем основные различия между Apache Kafka и RabbitMQ?', 'Основные различия между Apache Kafka и RabbitMQ:\n\n
1. Архитектура:\n
    - Kafka использует распределенную архитектуру, основанную на брокерах и темах.\n
    - RabbitMQ использует централизованную архитектуру с брокером и обменами/очередями.\n\n
2. Модель данных:\n
    - Kafka использует концепцию потоков (streams) и тем (topics) для организации данных.\n
    - RabbitMQ использует очереди (queues) и обмены (exchanges) для организации данных.\n\n
3. Гарантии доставки:\n
    - Kafka обеспечивает "как минимум один раз" доставку сообщений.\n
    - RabbitMQ предоставляет различные гарантии доставки, включая "как минимум один раз" и "в точности один раз".\n\n
4. Поддержка отказоустойчивости:\n
    - Kafka использует механизм репликации для обеспечения отказоустойчивости.\n
    - RabbitMQ поддерживает кластеризацию и резервное копирование для обеспечения отказоустойчивости.\n\n
5. Производительность:\n
    - Kafka ориентирована на высокую пропускную способность и низкую задержку для больших объемов данных.\n
    - RabbitMQ больше подходит для обработки меньших объемов сообщений с акцентом на гибкость и расширяемость.\n\n
6. Использование:\n
    - Kafka чаще используется для обработки потоковых данных, логирования, отслеживания событий.\n
    - RabbitMQ чаще используется для асинхронной обработки сообщений, интеграции приложений, реализации паттерна Publish-Subscribe.\n\n
7. Поддержка языков:\n
    - Kafka имеет широкую поддержку различных языков программирования.\n
    - RabbitMQ изначально ориентирован на работу с приложениями на языке Erlang, но также поддерживает множество других языков.\n\n
В целом, Kafka более ориентирована на обработку больших объемов данных в высоконагруженных системах, в то время как RabbitMQ лучше подходит для асинхронной маршрутизации и обработки сообщений в распределенных приложениях. Выбор между ними зависит от конкретных требований вашей системы.', 'FASHION_TECHNOLOGIES', false),
       ('', '', 'FASHION_TECHNOLOGIES', false),
       ('', '', 'FASHION_TECHNOLOGIES', false),
       ('', '', 'FASHION_TECHNOLOGIES', false),
       ('', '', 'FASHION_TECHNOLOGIES', false),
       ('', '', 'FASHION_TECHNOLOGIES', false),
       ('', '', 'FASHION_TECHNOLOGIES', false),
       ('', '', 'FASHION_TECHNOLOGIES', false),
       ('', '', 'FASHION_TECHNOLOGIES', false),
       ('', '', 'FASHION_TECHNOLOGIES', false),
       ('', '', 'FASHION_TECHNOLOGIES', false),
       ('', '', 'FASHION_TECHNOLOGIES', false),
       ('', '', 'FASHION_TECHNOLOGIES', false),
       ('', '', 'FASHION_TECHNOLOGIES', false),
       ('', '', 'FASHION_TECHNOLOGIES', false),