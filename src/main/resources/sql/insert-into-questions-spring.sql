INSERT INTO questions (question, answer, theme, is_impotent)
VALUES ('Что такое инверсия контроля (IoC) и внедрение зависимостей (DI)? Как эти принципы реализованы в Spring?', 'Inversion of Control - это принцип ООП или набор рекомендаций в разработке программы, при котором управление объектами или частями программы передается контейнеру или фреймворку.(с помощью рефлексии).\n Вместо ручного внедрения зависимостей, фреймворк забирает ответственность за это посредством IoC-контейнера. Задача - уменьшить связываемость между классами.\n\n
Dependency Injection — является одним из способов реализации принципа IoC в Spring. Это шаблон проектирования, в котором контейнер передает экземпляры объектов по их типу другим объектам с помощью конструктора или метода класса(setter), что позволяет писать слабосвязный код.\n\n (Конфигурации для внедрения - scope,factory method, Можно внедрить через XML или аннотации JAVA, процесс внедрения можно автоматизировать Autowiring)', 'SPRING', true),
       ('Что такое IoC контейнер?', 'В среде Spring IoC-контейнер представлен интерфейсом ApplicationContext, который является оберткой над BeanFactory, предоставляющей дополнительные возможности, например AOP и транзакции.\n Интерфейс BeanFactory предоставляет фабрику для бинов, которая в то же время и является IoC-контейнером приложения.\n Управление бинами основано на конфигурации(аннотации или xml). Контейнер создает бъекты на основе конфигураций и управляет их жизненным циклом от создания объекта до уничтожения."\n\n IoC Контейнер - это приложение, которое отвечает за управление жизненным циклом объекта: создание объектов, вызов методов инициализации и конфигурирование объектов путём связывания их между собой.Объекты, создаваемые контейнером, называются beans.\n Конфигурирование контейнера осуществляется путём внедрения аннотаций, но также, есть возможность, по старинке, загрузить XML-файлы, содержащие определение bean’ов и предоставляющие информацию, необходимую для создания bean’ов.', 'SPRING', true),
       ('Расскажите про ApplicationContext и BeanFactory, чем отличаются? В каких случаях что стоит использовать?', 'ApplicationContext является наследником BeanFactory и полностью реализует его функционал, добавляя больше специфических enterprise-функций. Может работать с бинами всех скоупов.\n\n
BeanFactory - это фактический контейнер, который создает, настраивает и управляет рядом bean-компонентов. Эти бины обычно взаимодействуют друг с другом и, таким образом, имеют зависимости между собой. Эти зависимости отражены в данных конфигурации, используемых BeanFactory. Может работать с бинами singleton и prototype.\n\n
BeanFactory обычно используется тогда, когда ресурсы ограничены (мобильные устройства), так как он легче по сравнению с ApplicationContext. Поэтому, если ресурсы не сильно ограничены, то лучше использовать ApplicationContext.\n\n
ApplicationContext загружает все бины при запуске, а BeanFactory по требованию. ', 'SPRING', false),
       ('Расскажите про аннотацию @Bean?', 'используется над !методом! для указания того, что данный метод создает, настраивает и инициализирует новый объект, управляемый Spring IoC контейнером. Такие методы можно использовать как в классах с аннотацией @Configuration, так и в классах с аннотацией @Component (или её наследниках).\n\n
Позволяет дополнительно определить у бина:\n
- name - имя (уникальный идентификатор) бина;\n
- initMethod - имя метода для вызова во время инициализации бина;\n
- destroyMethod - имя метода для вызова во время удаления бина из контекста;\n
- autowireCandidate - является ли этот бин кандидатом на автоматическое внедрение в другой бин.', 'SPRING', true),
       ('Расскажите про аннотацию @Component?', 'Аннотация @Component - помечаем ей класс чтобы Spring Framework создал бин из этого класса.Именно эту аннотацию ищет Spring.F когда сканирует наши классы. @Component имеет наследников: @Repository, @Service и @Controller, их также называют стереотипными аннотациями', 'SPRING', true),
       ('Чем отличаются аннотации @Bean и @Component?', 'Аннотация @Component (как и @Service и @Repository) используется для автоматического обнаружения и автоматической настройки бинов в ходе сканирования путей к классам.\n\n Аннотация @Bean используется для явного объявления бина, а не для того, чтобы Spring делал это автоматически в ходе сканирования путей к классам', 'SPRING', false),
       ('Расскажите про аннотации @Service и @Repository. Чем они отличаются?', ' @Repository - указывает, что класс используется для работы с поиском, получением и хранением данных. Аннотация может использоваться для реализации шаблона DАО.\n\n
 @Service - указывает, что класс является сервисом для реализации бизнес-логики.\n\n
Задача @Repository заключается в том, чтобы отлавливать определенные исключения персистентности и пробрасывать их как одно непроверенное исключение Spring Framework. Для этого в контекст должен быть добавлен класс PersistenceExceptionTranslationPostProcessor.', 'SPRING', false),
       ('Расскажите про аннотацию @Autowired', ' @Autowired – автоматическое внедрение подходящего бина(конструктор, поле, сеттер-метод или метод конфигурации):\n
1) Контейнер определяет тип объекта для внедрения\n
2) Контейнер ищет соответствующий тип бина в контексте(он же контейнер)\n
3) Если есть несколько кандидатов, и один из них помечен как @Primary, то внедряется он\n
4) Если используется @Qualifier, то контейнер будет использовать информацию из @Qualifier, чтобы понять, какой компонент внедрять\n
5) В противном случае контейнер внедрит бин, основываясь на его имени или ID\n
6) Если ни один из способов не сработал, то будет выброшено исключение\n\n
Контейнер обрабатывает DI с помощью AutowiredAnnotationBeanPostProcessor. В связи с этим, аннотация не может быть использована ни в одном BeanFactoryPP или BeanPP.\n
В аннотации есть один параметр required = true/false - указывает, обязательно ли делать DI. По умолчанию true. Либо можно не выбрасывать исключение, а оставить поле c null, если нужный бин не был найден - false.\n
При циклической зависимости, когда объекты ссылаются друг на друга, нельзя ставить над конструктором.\n
    Однако при внедрении прямо в поля вы не предоставляете прямого способа создания экземпляра класса со всеми необходимыми зависимостями. Это означает, что:\n
    Существует способ (путем вызова конструктора по-умолчанию) создать объект с использованием new в состоянии, когда ему не хватает некоторых из его обязательных зависимостей, и использование приведет к NullPointerException\n
    Такой класс не может быть использован вне DI-контейнеров (тесты, другие модули) и нет способа кроме рефлексии предоставить ему необходимые зависимости\n
    Неизменность\n
В отличие от способа с использованием конструктора, внедрение через поля не может использоваться для присвоения зависимостей final-полям, что приводит к тому, что ваши объекты становятся изменяемыми', 'SPRING', true),
       ('Расскажите про аннотацию @Resource', 'Аннотация @Resource пытается получить зависимость: по имени, по типу, затем по описанию (Qualifier). Имя извлекается из имени аннотируемого сеттера или поля, либо берется из параметра name.\n
    @Resource //По умолчанию поиск бина с именем "context"\n\n
    private ApplicationContext context;\n\
    @Resource(name="greetingService") //Поиск бина с именем "greetingService\n\n
    public void setGreetingService(GreetingService service) {\n
        this.greetingService = service;\n
    }\n\n
Разница с @Autowired:\n
❖ ищет бин сначала по имени, а потом по типу;\n
❖ не нужна дополнительная аннотация для указания имени конкретного бина;\n
❖ @Autowired позволяет отметить место вставки бина как необязательное @Autowired(required = false);\n
❖ при замене Spring Framework на другой фреймворк, менять аннотацию @Resource не нужно.', 'SPRING', false),
       ('Расскажите про аннотацию @Inject', 'Аннотация @Inject входит в пакет javax.inject и, чтобы её использовать, нужно добавить зависимость:\n\n
<dependency>\n
   <groupId>javax.inject</groupId>\n
   <artifactId>javax.inject</artifactId>\n
   <version>1</version>\n
</dependency>\n\n
@Inject (аннотация java) аналог @Autowired (аннотация spring) в первую очередь пытается подключить зависимость по типу, затем по описанию и только потом по имени. В ней нет параметров. Поэтому при использовании конкретного имени (Id) бина используем @Named:\n\n
@Inject\n
@Named("yetAnotherFieldInjectDependency")\n
private ArbitraryDependency yetAnotherFieldInjectDependency;', 'SPRING', false),
       ('Расскажите про аннотацию @Lookup', 'Обычно бины в приложении Spring являтся синглтонами, и для внедрения зависимостей мы используем конструктор или сеттер.\n\n
Но бывает и другая ситуация: имеется бин Car – синглтон (singleton bean), и ему требуется каждый раз новый экземпляр бина Passenger. То есть Car – синглтон, а Passenger – так называемый прототипный бин (prototype bean).\n Жизненные циклы бинов разные. Бин Car создается контейнером только раз, а бин Passenger создается каждый раз новый – допустим, это происходит каждый раз при вызове какого-то метода бина Car. Вот здесь то и пригодится внедрение бина с помощью Lookup метода. Оно происходит не при инициализации контейнера, а позднее: каждый раз, когда вызывается метод.\n Суть в том, что вы создаете метод-заглушку в бине Car и помечаете его специальным образом – аннотацией @Lookup. Этот метод должен возвращать бин Passenger, каждый раз новый.\n Контейнер Spring под капотом создаст прокси-подкласс и переопределит этот метод и будет нам выдавать новый экземпляр бина Passenger при каждом вызове аннотированного метода. Даже если в нашей заглушке он возвращает null (а так и надо делать - всё равно этот метод будет переопределен в прокси-подклассе)', 'SPRING', false),
       ('Можно ли вставить бин в статическое поле? Почему?', 'Spring не позволяет внедрять бины напрямую в статические поля. Это связано с тем, что когда загрузчик классов загружает статические значения, контекст Spring ещё не загружен.', 'SPRING', false),
       ('Расскажите про аннотации @Primary и @Qualifier', '@Qualifier применяется если кандидатов для автоматического связывания несколько, она позволяет указать в качестве аргумента имя конкретного бина, который следует внедрить. Она может быть применена к отдельному полю класса, к отдельному аргументу метода или конструктора\n\n
@Primary тоже используется, чтобы отдавать предпочтение бину, когда есть несколько бинов одного типа, но в ней нельзя задать имя бина, она определяет значение по умолчанию, в то время как @Qualifier более специфичен. Если присутствуют аннотации @Qualifier и @Primary, то аннотация @Qualifier будет иметь приоритет.', 'SPRING', false),
       ('Как заинжектить примитив?', 'Для этого можно использовать аннотацию @Value. Можно ставить над полем, конструктором, методом.\n
Такие значения можно получать из property файлов, из бинов, и т.п.\n\n
@Value("${some.key}")\n
public String stringWithDefaultValue;\n\n
В эту переменную будет внедрена строка, например из property или из view.\n
Кроме того, для внедрения значений мы можем использовать язык SpEL (Spring Expression Language)', 'SPRING', false),
       ('Как заинжектить коллекцию?', 'Если внедряемый объект массив, коллекция, или map с дженериком, то используя аннотацию @Autowired, Spring внедрит все бины подходящие по типу в этот массив(или другую структуру данных). В случае с map значениями будут сами бины, а ключами будут имена бинов:\n\n
Используя аннотацию @Qualifier можно настроить тип искомого бина.(Мы использовали параметр ''name'' у аннотации @Bean, чтобы указать конкретный классификатор для бина. Но элемент ''name'', на самом деле, является не столько именем, сколько идентификатором бина, который должен быть уникальным, потому что все бины хранятся в контейнере в Map. В случае с коллекцией мы хотим, чтобы несколько бинов имели одно и то же имя квалификатора, чтобы их можно было внедрить в одну коллекцию с одним и тем же квалификатором. В этом случае мы должны использовать аннотацию @Qualifier вместе с @Bean вместо элемента name.)\n\n
Бины могут быть упорядочены, когда они вставляются в списки (не Set или Map) или массивы. Поддерживаются как аннотация @Order, так и интерфейс Ordered.', 'SPRING', false),
       ('Расскажите про аннотацию @Conditional', 'Spring предоставляет возможность на основе вашего алгоритма включить или выключить определение бина или всей конфигурации через @Conditional, в качестве параметра которой указывается класс, реализующий интерфейс Condition, с единственным методом matches(ConditionContext var1, AnnotatedTypeMetadata var2), возвращающий boolean.\n
Для создания более сложных условий можно использовать классы AnyNestedCondition, AllNestedConditions и NoneNestedConditions.\n\n
Аннотация @Conditional указывает, что компонент имеет право на регистрацию в контексте только тогда, когда все условия соответствуют.\n\n
Если класс @Configuration помечен как @Conditional, то на все методы @Bean, аннотации @Import и аннотации @ComponentScan, связанные с этим классом, также будут распространяться указанные условия.', 'SPRING', false),
       ('Расскажите про аннотацию @Profile', 'Профили - это ключевая особенность Spring Framework, позволяющая нам относить наши бины к разным профилям (логическим группам), например, dev, test, prod.\n\n
Мы можем активировать разные профили в разных средах, чтобы загрузить только те бины, которые нам нужны.\n
Используя аннотацию @Profile, мы относим бин к конкретному профилю. Её можно применять на уровне класса или метода. Аннотация @Profile принимает в качестве аргумента имя одного или нескольких профилей. Она фактически реализована с помощью гораздо более гибкой аннотации @Conditional.\n
Ее можно ставить на @Configuration и Component классы. В Spring Boot есть возможность иметь один файл настроек application.properties, в котором будут основные настройки для всех профилей, и иметь по файлу настроек для каждого профиля application-dev.properties и application-prod.properties, содержащие свои собственные дополнительные настройки.', 'SPRING', false),
       ('Расскажите про жизненный цикл бина, аннотации @PostConstruct и @PreDestroy()', 'I) Парсирование конфигурации и создание BeanDefinition\n
1. Xml конфигурация — ClassPathXmlApplicationContext(“context.xml”)\n  2. Конфигурация через аннотации с указанием пакета для сканирования — AnnotationConfigApplicationContext(“package.name”)\n 3. Конфигурация через аннотации с указанием класса (или массива классов) помеченного аннотацией @Configuration -AnnotationConfigApplicationContext(JavaConfig.class). Этот способ конфигурации называется — JavaConfig.\n  4. Groovy конфигурация — GenericGroovyApplicationContext(“context.groovy”)\n Найденные классы парсируются и для них создаются BeanDefinition.\n Цель первого этапа — это создание всех BeanDefinition.\n BeanDefinition — это набор метаданных будущего бина, макет, по которому нужно будет создавать бин в случае необходимости. То есть для каждого бина создается свой объект BeanDefinition, в котором хранится описание того, как создавать и управлять этим конкретным бином. Проще говоря, сколько бинов в программе - столько и объектов BeanDefinition, их описывающих.\n\n
II) Настройка созданных BeanDefinition\n
Есть возможность повлиять на бины до их создания, иначе говоря мы имеем доступ к метаданным класса. Для этого существует специальный интерфейс BeanFactoryPostProcessor, реализовав который, мы получаем доступ к созданным BeanDefinition и можем их изменять. В нем один метод.  Метод postProcessBeanFactory принимает параметром ConfigurableListableBeanFactory. Данная фабрика содержит много полезных методов, в том числе getBeanDefinitionNames, через который мы можем получить все BeanDefinitionNames, а уже потом по конкретному имени получить BeanDefinition для дальнейшей обработки метаданных.\n\n
III) Создание кастомных FactoryBean (только для XML-конфигурации)
FactoryBean — это generic интерфейс, которому можно делегировать процесс создания бинов типа . В те времена, когда конфигурация была исключительно в xml, разработчикам был необходим механизм с помощью которого они бы могли управлять процессом создания бинов. Именно для этого и был сделан этот интерфейс.\n Для тех кто пользуется JavaConfig, этот интерфейс будет абсолютно бесполезен.\n\n
IV) Создание экземпляров бинов\n
Сначала BeanFactory из коллекции Map с объектами BeanDefinition достаёт те из них, из которых создаёт все BeanPostProcessor-ы (Инфраструктурные бины), необходимые для настройки обычных бинов. Создаются экземпляры бинов через BeanFactory на основе ранее созданных BeanDefinition. Созданием экземпляров бинов занимается BeanFactory на основе ранее созданных BeanDefinition. Из Map<BeanName, BeanDefinition> получаем Map<BeanName, Bean> Создание бинов может делегироваться кастомным FactoryBean.\n\n
V) Настройка созданных бинов\n
На данном этапе бины уже созданы, мы можем лишь их донастроить. Интерфейс BeanPostProcessor позволяет вклиниться в процесс настройки наших бинов до того, как они попадут в контейнер.\n Интерфейс несет в себе два метода: postProcessBeforeInitialization(Object bean, String beanName) и postProcessAfterInitialization(Object bean, String beanName). У обоих методов параметры абсолютно одинаковые. Разница только в порядке их вызова. Первый вызывается до init-метода, второй - после.\n Как правило, BeanPostProcessor-ы, которые заполняют бины через маркерные интерфейсы или тому подобное, реализовывают метод postProcessBeforeInitialization (Object bean, String beanName), тогда как BeanPostProcessor-ы, которые оборачивают бины в прокси, обычно реализуют postProcessAfterInitialization (Object bean, String beanName).\n Прокси — это класс-декорация над бином. Например, мы хотим добавить логику нашему бину, но джава-код уже скомпилирован, поэтому нам нужно на лету сгенерировать новый класс. Этим классом мы должны заменить оригинальный класс так, чтобы никто не заметил подмены.\n Есть два варианта создания этого класса:\n 1. либо он должен наследоваться от оригинального класса (CGLIB) и переопределять его методы, добавляя нужную логику;\n 2. либо он должен имплементировать те же самые интерфейсы, что и первый класс (Dynamic Proxy).\n По конвенции спринга, если какой-то из BeanPostProcessor-ов меняет что-то в классе, то он должен это делать на этапе postProcessAfterInitialization(). Таким образом мы уверены, что initMethod у данного бина, работает на оригинальный метод, до того, как на него накрутился прокси.\n\n
Хронология событий:\n 1. Сначала сработает метод postProcessBeforeInitialization() всех имеющихся BeanPostProcessor-ов.\n 2. Затем, при наличии, будет вызван метод, аннотированный @PostConstruct.\n 3. Если бин имплементирует InitializingBean, то Spring вызовет метод afterPropertiesSet() - не рекомендуется к использованию как устаревший.\n 4. При наличии, будет вызван метод, указанный в параметре initMethod аннотации @Bean.\n 5. В конце бины пройдут через postProcessAfterInitialization (Object bean, String beanName). Именно на данном этапе создаются прокси стандартными BeanPostProcessor-ами. Затем отработают наши кастомные BeanPostProcessor-ы и применят нашу логику к прокси-объектам. После чего все бины окажутся в контейнере, который будет обязательно обновлен методом refresh().\n 6. Но даже после этого мы можем донастроить наши бины ApplicationListener-ами.\n 7. Теперь всё.\n\n
VI) Бины созданы\n
Их можно получить с помощью метода ApplicationContext.getBean().\n\n
VII). Закрытие контекста\n
Когда контекст закрывается (метод close() из ApplicationContext), бин уничтожается. Если в бине есть метод, аннотированный @PreDestroy, то перед уничтожением вызовется этот метод. Если в аннотации @Bean определен метод destroyMethod, то будет вызван и он.\n\n
Аннотация PostConstruct\n
Spring вызывает методы, аннотированные @PostConstruct, только один раз, сразу после инициализации свойств компонента. За данную аннотацию отвечает один из BeanPostProcessorов. Метод, аннотированный @PostConstruct, может иметь любой уровень доступа, может иметь любой тип возвращаемого значения (хотя тип возвращаемого значения игнорируется Spring-ом), метод не должен принимать аргументы.\n Одним из примеров использования @PostConstruct является заполнение базы данных. Например, во время разработки нам может потребоваться создать пользователей по умолчанию.\n\n
Аннотация PreDestroy\n
Метод, аннотированный @PreDestroy, запускается только один раз, непосредственно перед тем, как Spring удаляет наш компонент из контекста приложения. Как и в случае с @PostConstruct, методы, аннотированные @PreDestroy, могут иметь любой уровень доступа, но не могут быть статическими. Целью этого метода может быть освобождение ресурсов или выполнение любых других задач очистки до уничтожения бина, например, закрытие соединения с базой данных.\n\n
Класс, имплементирующий BeanPostProcessor, обязательно должен быть бином, поэтому мы его помечаем аннотацией @Component.\n SCOPE_SINGLETON — инициализация произойдет один раз на этапе поднятия контекста.\n SCOPE_PROTOTYPE — инициализация будет выполняться каждый раз по запросу. Причем во втором случае ваш бин будет проходить через все BeanPostProcessor-ы что может значительно ударить по производительности.', 'SPRING', true),
       ('Расскажите про скоупы бинов? Какой скоуп используется по умолчанию? Что изменилось в Spring 5?', 'Существует 2 области видимости по умолчанию.\n
* Singleton - область видимости по умолчанию. В контейнере будет создан только один бин, и все запросы на него будут возвращать один и тот же бин.\n
* Prototype - приводит к созданию нового бина каждый раз, когда он запрашивается.\n
Для бинов со scope “prototype” Spring не вызывает метод destroy(), так как не берет на себя контроль полного жизненного цикла этого бина. Spring не хранит такие бины в своём контексте ( контейнере), а отдаёт их клиенту и больше о них не заботится (в отличие от синглтон-бинов).\n\n
И 4 области видимости в веб-приложении.\n
* Request - Область видимости — 1 HTTP запрос. На каждый запрос создается новый бин\n
* Session - Область видимости — 1 сессия. На каждую сессию создается новый бин\n
* Application - Область видимости — жизненный цикл ServletContext\n
* WebSocket - Область видимости — жизненный цикл WebSocket\n
Жизненный цикл web csope полный.\n\n
В пятой версии Spring Framework не стало Global session scope. И появились Application и WebSocket', 'SPRING', true),
       ('Расскажите про аннотацию @ComponentScan', 'Аннотация @ComponentScan используется вместе с аннотацией @Configuration для указания пакетов, которые мы хотим сканировать на наличие компонентов, из которых нужно сделать бины.\n
@ComponentScan без аргументов указывает Spring по умолчанию сканировать текущий пакет и все его подпакеты. Текущий пакет - тот, в котором находится файл конфигурации с этой самой аннотацией @ComponentScan. В данном случае в контейнер попадут:\n
- бин конфигурационного класса;\n
- бины, объявленные в конфигурационном классе с помощью @Bean;\n
- все бины из пакета и его подпакетов.\n\n
Если  указать  @ComponentScan  с  атрибутом  basePackages,  то  это  изменит  пакет  по умолчанию на указанный\n
Если указать @ComponentScan с атрибутом excludeFilters, то это позволит использовать фильтр и исключить ненужные классы из процесса сканирования', 'SPRING', false),
       ('Как спринг работает с транзакциями? Расскажите про аннотацию @Transactional.', 'Коротко:\n Spring создает прокси для всех классов, помеченных @Transactional (либо если любой из методов класса помечен этой аннотацией), что позволяет вводить транзакционную логику до и после вызываемого метода. При вызове такого метода происходит следующее:\n
- proxy, который создал Spring, создаёт persistence context (или соединение с базой),\n
- открывает в нём транзакцию и сохраняет всё это в контексте нити исполнения (натурально, в ThreadLocal).\n
- По мере надобности всё сохранённое достаётся и внедряется в бины.\n\n
Таким образом, если в вашем коде есть несколько параллельных нитей, у вас будет и несколько параллельных транзакций, которые будут взаимодействовать друг с другом согласно уровням изоляции.\n\n
Что произойдёт, если один метод с @Transactional вызовет другой метод с @Transactional?\n
Если это происходит в рамках одного сервиса, то второй транзакционный метод будет считаться частью первого, так как вызван у него изнутри, а так как спринг не знает о внутреннем вызове, то не создаст прокси для второго метода.(Обернуто в проски будет а вот транзакция создана не будет если из 2 класса вызван метод то транзакция будет)\n\n
Что произойдёт, если один метод БЕЗ @Transactional вызовет другой метод с @Transactional?\n
Так как spring не знает о внутреннем вызове, то не создаст прокси для второго метода.\n\n
Будет ли транзакция откачена, если будет брошено исключение, которое указано в контракте метода?\n
Если в контракте описано это исключение, то она не откатится. Unchecked исключения в транзакционном методе можно ловить, а можно и не ловить.\n\n
', 'SPRING', true),
       ('Какие есть атрибуты у @Transactional?', '1. propagation:\n
* REQUIRED — применяется по умолчанию. При входе в @Transactional метод будет использована уже существующая транзакция или создана новая транзакция, если никакой ещё нет\n
* REQUIRES_NEW — новая транзакция всегда создаётся при входе метод, ранее созданные транзакции приостанавливаются до момента возврата из метода.\n
* NESTED — корректно работает только с базами данных, которые умеют savepoints. При входе в метод в уже существующей транзакции создаётся savepoint, который по результатам выполнения метода будет либо сохранён, либо откачен. Все изменения, внесённые методом, подтвердятся только поздее, с подтверждением всей транзакции. Если текущей транзакции не существует, будет создана новая.\n
* MANDATORY — всегда используется существующая транзакция и кидается исключение, если текущей транзакции нет.\n
* SUPPORTS — метод с этим правилом будет использовать текущую транзакцию, если она есть, либо будет исполнятся без транзакции, если её нет.\n
* NOT_SUPPORTED — при входе в метод текущая транзакция, если она есть, будет приостановлена и метод будет выполняться без транзакции.\n
* NEVER — явно запрещает исполнение в контексте транзакции. Если при входе в метод будет существовать транзакция, будет выброшено исключение.\n\n
2. rollbackFor = Exception.class - если какой-либо метод выбрасывает указанное исключение, контейнер всегда откатывает текущую транзакцию. По умолчанию отлавливает RuntimeException\n\n
3. noRollbackFor = Exception.class - указание того, что любое исключение, кроме заданных, должно приводить к откату транзакции.\n
rollbackForClassName и noRollbackForClassName - для задания имен исключений в строковом виде.\n\n
4. readOnly - разрешает только операции чтения.\n
В свойстве transactionManager хранится ссылка на менеджер транзакций, определенный в конфигурации Spring.\n\n
5. timeOut - По умолчанию используется таймаут, установленный по умолчанию для базовой транзакционной системы. Сообщает менеджеру tx о продолжительности времени, чтобы дождаться простоя tx, прежде чем принять решение об откате не отвечающих транзакций.\n\n
6. isolation - уровень изолированности транзакций', 'SPRING', true),
       ('Как @Transactional работает под капотом?', 'В Spring Framework аннотация @Transactional работает с помощью AOP (Aspect-Oriented Programming) и управляет транзакциями путем создания прокси объектов вокруг методов, помеченных этой аннотацией. Под капотом происходит следующее:\n\n
1. Когда Spring создает бин, помеченный аннотацией @Transactional, он создает прокси-объект вокруг этого бина.\n
2. При вызове метода бина, который помечен @Transactional, прокси перехватывает вызов и запускает транзакцию до начала выполнения метода.\n
3. После выполнения метода, прокси обрабатывает результат метода и решает, нужно ли фиксировать изменения (COMMIT) или откатить транзакцию (ROLLBACK).\n
4. После завершения метода, транзакция завершается соответствующим образом в зависимости от результата метода.\n\n
Spring Framework использует менеджер транзакций для управления транзакциями и выполняет логику COMMIT или ROLLBACK в зависимости от конфигурации транзакций. Такой подход обеспечивает управление транзакциями в рамках бизнес-сервисов и методов, делая код более безопасным и надежным.', 'SPRING', true),
       ('Как решить проблему N+1 с использованием @Transactional?', 'Использование аннотации @Transactional может помочь решить проблему N+1, указывая, что несколько операций с базой данных должны выполняться в рамках одной транзакции. Это гарантирует, что все данные будут извлечены в одном запросе, повышая производительность.\n\n
Вот пример использования @Transactional для устранения проблемы N+1:\n
@Transactional(readOnly = true)\n
public List<Order> findAllOrders() {\n
    return orderRepository.findAll();\n
}\n
В этом примере метод findAllOrders() помечен как @Transactional, что означает, что все операции с базой данных в рамках этого метода будут выполняться в одной транзакции. Это гарантирует, что запрос findAll() будет единственным запросом, выполненным для выборки всех заказов, устраняя проблему N+1.', 'SPRING', true),
       ('Расскажите про аннотации @Controller и @RestController. Чем они отличаются?', '@Controller - специальный тип класса, обрабатывает HTTP-запросы и часто используется с аннотацией @RequestMapping.\n
@RestController ставится на класс-контроллер вместо @Controller. Она указывает, что этот класс оперирует не моделями, а данными. Она состоит из аннотаций @Controller и @ResponseBody. Была введена в Spring 4.0 для упрощения создания RESTful веб-сервисов.\n\n
@ResponseBody сообщает контроллеру, что возвращаемый объект автоматически сериализуется (используя Jackson message converter) в json или xml и передается обратно в объект HttpResponse.', 'SPRING', false),
       ('Что такое ResponseEntity?', 'ResponseEntity используется для формирования кастомизированного HTTP-ответа с пользовательскими параметрами (заголовки, код статуса и тело ответа). Во всех остальных случаях достаточно использовать @ResponseBody.\n
Если мы хотим использовать ResponseEntity, то просто должны вернуть его из метода, Spring позаботится обо всем остальном.\n
return ResponseEntity.status(213);', 'SPRING', false),
       ('Что такое ViewResolver?', 'ViewResolver  - распознаватель представлений - это способ работы с представлениями(html-файлы), который поддерживает их распознавание на основе имени, возвращаемого контроллером.\n\n
Spring Framework поставляется с большим количеством реализаций ViewResolver:\n- Например, класс UrlBasedViewResolver поддерживает прямое преобразование логических имен в URL.\n
- InternalResourceViewResolver — реализация ViewResolver по умолчанию, которая позволяет находить представления, которые возвращает контроллер для последующего перехода к ним. Ищет по заданному пути, префиксу, суффиксу и имени.\n\n
Любым реализациям ViewResolver желательно поддерживать интернационализацию, то есть множество языков.\n
Существует также несколько реализаций для интеграции с различными технологиями представлений, такими как FreeMarker (FreeMarkerViewResolver), Velocity (VelocityViewResolver) и JasperReports (JasperReportsViewResolver).', 'SPRING', false),
       ('Чем отличаются Model, ModelMap и ModelAndView?', '1. Model - интерфейс, представляет коллекцию пар ключ-значение Map<String, Object>. Содержимое модели используется для отображения данных во View. Например, если View выводит информацию об объекте Customer, то она может ссылаться к ключам модели, например customerName, customerPhone, и получать значения для этих ключей. Объекты-значения из модели также могут содержать бизнес-логику.\n\n
2. ModelMap - класс, наследуется от LinkedHashMap, тоже используется для передачи значений для визуализации представления. Преимущество ModelMap заключается в том, что он дает нам возможность передавать коллекцию значений и обрабатывать эти значения, как если бы они были внутри Map.\n\n
3. ModelAndView - это просто контейнер для ModelMap, объект View и HttpStatus. Это позволяет контроллеру возвращать все значения как одно. View используется для отображения данных приложения пользователю. Spring MVC поддерживает несколько поставщиков View(они называются шаблонизаторы) — JSP, JSF, Thymeleaf, и т.п. Интерфейс View преобразует объекты в обычные сервлеты.', 'SPRING', false),
       ('Расскажите про паттерн Front Controller, как он реализован в Spring?', 'Front controller - обеспечивает единую точку входа для всех входящих запросов. Все запросы обрабатываются одним обработчиком - DispatcherServlet с маппингом "/". Этот обработчик может выполнить аутентификацию, авторизацию, регистрацию или отслеживание запроса, а затем распределяет их между контроллерами, обрабатывающими разные URL. Это и есть реализация паттерна Front Controller. Веб-приложение может определять любое количество DispatcherServlet-ов. Каждый из них будет работать в своем собственном пространстве имен, загружая свой собственный дочерний WebApplicationContext с вьюшками, контроллерами и т.д.\n\n
❖ Один из контекстов будет корневым, а все остальные контексты будут дочерними.\n
❖ Все дочерние контексты могут получить доступ к бинам, определенным в корневом контексте, но не наоборот.\n
❖ Каждый дочерний контекст внутри себя может переопределить бины из корневого контекста.\n
WebApplicationContext расширяет ApplicationContext (создаёт и управляет бинами и т.д.), но помимо этого он имеет дополнительный метод getServletContext(), через который у него есть возможность получать доступ к ServletContext-у. ContextLoaderListener создает корневой контекст приложения и будет использоваться всеми дочерними контекстами, созданными всеми DispatcherServlet.', 'SPRING', false),
       ('Расскажите про паттерн MVC, как он реализован в Spring?', 'MVC - model view controller - шаблон проектирования из трех компонентов:\n
Model - отвечает за хранение данных\n
View - отвечает за вывод данных на фронте\n
Controller - оперирует моделями и отвечает за обмен данными model с view\n\n
Основная цель MVC отделить бизнес-логику от визуализации.\n
Spring MVC использует одновременно Front controller и MVC, разделение задач обеспечивается использованием независимых компонентов:\n
- Controller, Model, View\n
- DispatcherServlet - главный контроллер, распределяющий задачи\n
- ViewResolver - определяет на основании имени конкретный view\n\n

Порядок работы следующий:\n
1. HTTP запрос принимает DispetcherServlet и определяет контроллер с помощью HandlerMapping\n
2. HandlerAdapter отправляет в метод контроллера, затем контроллер формирует данные и в виде ModelAndView возвращает их диспетчеру\n
3. Дальше диспетчер с помощью ViewResolver определяет какой именно view нужен\n
- в случае с REST диспетчер сам отправит данные\n
- в случае обычного запроса данные будут отправлены в виде атрибутов в View где работают Thymeleaf и тд.', 'SPRING', true),
       ('Что такое АОП? Как реализовано в спринге?', 'Аспектно-ориентированное программирование (АОП) — это парадигма программирования, целью которой является разделениее основного и служебного функционала, служебный функционал записывается в Аспект-классы(в основе Аспект заключается сквозная логика) Примеры Аспекта - логирование, проверка прав, обработка транзакций, обработка исключений, кэширование и т.д. Это достигается путем добавления дополнительного поведения к существующему коду без изменения самого кода.\n\n
АОП предоставляет возможность реализации сквозной логики в одном месте - т.е. логики, которая применяется к множеству частей приложения - и обеспечения автоматического применения этой логики по всему приложению.\n\n
Аспект в АОП - это модуль или класс, реализующий сквозную функциональность. Аспект изменяет поведение остального кода, применяя совет в точках соединения, определённых некоторым срезом.\n
Совет (advice) – дополнительная логика — код, который должен быть вызван из точки соединения.\n
Точка соединения (join point) — место в выполняемой программе (вызов метода, создание объекта, обращение к переменной), где следует применить совет;\n
Срез (pointcut) — набор точек соединения.\n\n
Подход Spring к АОП заключается в создании "динамических прокси" для целевых объектов и "привязывании" объектов к конфигурированному совету для выполнения сквозной логики.\n\n
Есть два варианта создания прокси-класса:\n
1. либо он должен наследоваться от оригинального класса (CGLIB) и переопределять его методы, добавляя нужную логику;\n
2. либо он должен имплементировать те же самые интерфейсы, что и первый класс (Dynamic Proxy).', 'SPRING', true),
       ('В чем разница между Filters, Listeners and Interceptors?', 'Концептуально всё просто, фильтры сервлетов могут перехватывать только HTTPServlets. Listeners могут перехватывать специфические события. Как перехватить события которые относятся ни к тем не другим?\n
Фильтры и перехватчики делают по сути одно и тоже: они перехватывают какое-то событие, и делают что-то до или после.\n
Java EE использует термин Filter, Spring называет их Interceptors.\n
Именно здесь AOP используется в полную силу, благодаря чему возможно перехватывание вызовов любых объектов', 'SPRING', false),
       ('Можно ли передать в запросе один и тот же параметр несколько раз? Как?', 'Да, можно принять все значения, используя массив в методе контроллера:\n
public String method(@RequestParam(value="name") String[] names){...}\n
или\n
public String getFoos(@RequestParam List<String> id){...}', 'SPRING', false),
       ('Как работает Spring Security? Как сконфигурировать? Какие интерфейсы используются?', 'Основными блоками Spring Security являются:\n
- SecurityContextHolder, чтобы обеспечить доступ к SecurityContext.\n
- SecurityContext, содержит объект Authentication и в случае необходимости информацию системы безопасности, связанную с запросом.\n
- Authentication представляет принципала с точки зрения Spring Security\n
- GrantedAuthority отражает разрешения выданные доверителю в масштабе всего приложения.\n
- UserDetails предоставляет необходимую информацию для построения объекта Authentication из DAO объектов приложения или других источника данных системы безопасности.\n
- UserDetailsService, чтобы создать UserDetails, когда передано имя пользователя в виде String (или идентификатор сертификата или что-то подобное).', 'SPRING', false),
       ('Что такое SpringBoot? Какие у него преимущества? Как конфигурируется? Подробно.', 'Spring Boot - это модуль Spring-а, который предоставляет функцию RAD для среды Spring (Rapid Application Development - Быстрая разработка приложений). Он обеспечивает более простой и быстрый способ настройки и запуска как обычных, так и веб-приложений. Он просматривает наши пути к классам и настроенные нами бины, делает разумные предположения о том, чего нам не хватает, и добавляет эти элементы.\n\n  Ключевые особенности и преимущества Spring Boot:\n
1. Простота управления зависимостями (spring-boot-starter-* в pom.xml).\n
2. Автоматическая конфигурация. Включается аннотацией @EnableAutoConfiguration.\n
3. Встроенная поддержка сервера приложений/контейнера сервлетов (Tomcat, Jetty).\n
4. Готовые к работе функции, такие как метрики, проверки работоспособности, security и внешняя конфигурация.\n
5. Инструмент CLI (command-line interface) для разработки и тестирования приложения Spring Boot.\n\
6. Минимизация boilerplate кода (код, который должен быть включен во многих местах практически без изменений), конфигурации XML и аннотаций.\n\n
Как происходит автоконфигурация в Spring Boot:\n
1. Отмечаем main класс аннотацией @SpringBootApplication (аннотация инкапсулирует в себе: @SpringBootConfiguration, @ComponentScan, @EnableAutoConfiguration), таким образом наличие @SpringBootApplication включает сканирование компонентов, автоконфигурацию и показывает разным компонентам Spring (например, интеграционным тестам), что это Spring Boot приложение.\n
2. @EnableAutoConfiguration импортирует класс EnableAutoConfigurationImportSelector. Этот класс не объявляет бины сам, а использует фабрики.\n
3. Класс EnableAutoConfigurationImportSelector импортирует ВСЕ (более 150) перечисленные в META-INF/spring.factories конфигурации,  Каждая из этих конфигураций пытается сконфигурировать различные аспекты приложения (web, JPA, AMQP и т.д.), регистрируя нужные бины в контекст приложения.\n
4. Логика при регистрации бинов управляется набором @ConditionalOn* аннотаций. Можно указать, чтобы бин создавался при наличии класса в classpath (@ConditionalOnClass), наличии существующего бина (@ConditionalOnBean), отсуствии бина (@ConditionalOnMissingBean) и т.п. Таким образом наличие конфигурации не значит, что бин будет создан и зачастую конфигурация ничего делать и создавать не будет.\n
5. Созданный в итоге AnnotationConfigEmbeddedWebApplicationContext ищет в том же DI контейнере фабрику для запуска embedded servlet container.\n
6. Servlet container запускается, приложение готово к работе', 'SPRING', true),
       ('Что такое Spring Data JPA?', 'Spring Data JPA - это часть фреймворка Spring, которая упрощает разработку приложений с доступом к данным на Java с использованием JPA. Она предоставляет высокоуровневый API для определения сущностей, выполнения запросов и управления транзакциями, абстрагируясь от сложных деталей JPA.', 'SPRING', false),
       ('Как сделать подключение к разным БД?', 'Для подключения к разным базам данных в Spring можно использовать множественные источники данных. Создайте несколько объектов DataSource и свяжите их с именованными источниками данных в Spring. Затем используйте аннотацию @DataSource для указания источника данных для конкретного репозитория или метода.', 'SPRING', false),
       ('Расскажите про аннотацию @Query?', 'если в запросе более 1-2 параметров или несколько *join* ,то удобнее использовать аннотацию *@Query*.\n
Для этого в репозитории создаем метод, аннотированный *@Query*, и внутри аннотации прописываем запрос — можно как JPQL, так и native SQL.', 'SPRING', false),
       ('Что такое проекционный интерфейс (projection interface)?', 'В Java, проекционные интерфейсы обычно связаны с интерфейсами, которые применяются в функциональном программировании для проецирования (проекции) значений из коллекций или потоков данных.\n
Проекционные интерфейсы могут использоваться для обработки последовательностей, фильтрации, преобразования данных и других операций на элементах коллекции. Например, в Java 8 и более поздних версиях были представлены функциональные интерфейсы, такие как Function, Predicate, Consumer и другие, которые могут применяться при работе с проекционными интерфейсами.', 'SPRING', false),
       ('Как избавиться от циклической зависимости бинов?', '- Редактирование исходного кода некоторых классов, чтобы конфигурирование осуществлялось **с помощью сеттеров, а не конструкторов.\n
- Указать Spring лениво (@Lazy) инициализировать один из bean-компонентов. Таким образом, вместо полной инициализации bean-компонента будет создан прокси-сервер для его внедрения в другой bean-компонент. Внедренный bean-компонент будет полностью создан только тогда, когда он впервые понадобится.\n
- Внедрить зависимость с помощью @Autowired` в один из bean-компонентов**, а затем использовать метод, аннотированный с помощью @PostConstruct, для установки другой зависимости.', 'SPRING', false),
       ('Расскажите про нововведения Spring 5.', '● Используется JDK 8+ (Optional, CompletableFuture, Time API, java.util.function, default methods)\n
● Поддержка Java 9 (Automatic-Module-Name in 5.0, module-info in 6.0+, ASM 6)\n
● Поддержка HTTP/2 (TLS, Push), NIO/NIO.2\n
● Поддержка Kotlin\n
● Реактивность (веб-инфраструктура с реактивным стеком, «Spring WebFlux»)\n
● Null-safety аннотации(@Nullable), новая документация\n
● Совместимость с Java EE 8 (Servlet 4.0, Bean Validation 2.0, JPA 2.2, JSON Binding API 1.0)\n
● Поддержка JUnit 5 + Testing Improvements (conditional and concurrent)\n
● Удалена поддержка: Portlet, Velocity, JasperReports, XMLBeans, JDO, Guava', 'SPRING', false);