INSERT INTO answers (answer, question_id)
VALUES ('ООП - методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.\n
Согласно парадигмы ООП программа состоит из обьектов, обменивающихся сообщениями. Обьекты могут обладать состоянием, единственный способ изменить состояние обьекта - передать ему сообщение,  в ответ на которое, обьект может изменить собственное состояние.\n
Класс — это описание еще не созданного объекта, как бы общий шаблон, состоящий из полей, методов и конструктора, а объект – экземпляр класса, созданный на основе этого описания.',
        1),
       ('1. Легко читается - не нужно выискивать в коде функции и выяснять, за что они отвечают\n
2. Быстро пишется - можно быстро создать сущности, с которыми должна работать программа.\n
3. Простота реализации большого функционала - т.к. на написание кода уходит меньше времени, можно гораздо быстрее создать приложение с множеством возможностей\n
4. Меньше повторений кода - не нужно писать однотипные функции для разных сущностей', 2),
       ('1. Потребление памяти - обьекты потребляют больше оперативной памяти, чем примитивные типы данных\n
2. Снижает производительность - многие вещи технически реализованы иначе, поэтому они используют больше ресурсов.\n
3. Неэффективность и неэкономное распределения памяти на этапе выполнения (по причине издержек на динамическое связывание и проверки типов на этапе выполнения).\n
4. Излишняя универсальность. Часто содержится больше методов, чем это реально необходимо текущей программе. А поскольку лишние методы не могут быть удалены, они становятся мертвым грузом.\n
5. Сложно начать - парадигма ООП сложнее функционального программирования, поэтому на старт уходит больше времени', 3),
       ('Инкапсуляция, Наследование, Полиморфизм', 4),
       ('Инкапсуляция - Свойство системы, которое объединяет данные и методы, манипулирующие этими данными, а также защищает и то, и другое от внешнего вмешательства или неправильного использования.\n
Инкапсуляция - это объединение данных и методов работы с этими данными в одной упаковке («капсуле»).\n
Чтобы малейшее изменение в классе не влекло за собой изменение внешнего поведения класса.', 5),
       ('Наследование - Свойство системы, которое позволяет описать новый класс на основе уже существующего с частично или полностью заимствованной функциональностью.',
        6),
       ('Полиморфизм – предоставляет возможность единообразно обрабатывать объекты с различной реализацией при условии наличия у них общего интерфейса или класса. Полиморфизм – способность функции обрабатывать данные разных типов.\n
Есть три вида полиморфизма:\n
-ad hoc полиморфизм, основан на различении типов. Для различных типов аргументов используется разный код метода, пример статического - перегрузка метода. Пример динамического - перегрузка метода. (@Overload)\n
-параметрический полиморфизм - ситуация, когда один и тот же метод работает с аргументами различных типов одинаково, не зависимо от их точного типа. Пример — функция, работающая с объектом некоторого класса C, может без изменений работать с объектом порождённого от C класса (этот вид полиморфизма часто называют полиморфизм включения). (@Override)\n
-subtype полиморфизм - самый популярный - возможность объектов с одинаковой спецификацией(интерфейс\класс\abstract класс) иметь различную реализацию.\n
Пример:\n
Переопределение методов, интерфейсы.', 7),
       ('Ассоциация – это когда один класс включает в себя другой класс в качестве одного из полей. Ассоциация описывается словом «имеет». Автомобиль имеет двигатель. Вполне естественно, что он не будет являться наследником двигателя (хотя такая архитектура тоже возможна в некоторых ситуациях).\n
Выделяют два частных случая ассоциации: композицию и агрегацию.', 8),
       ('Композиция – это когда двигатель не существует отдельно от автомобиля. Он создается при создании автомобиля и полностью управляется автомобилем. В типичном примере, экземпляр двигателя будет создаваться в конструкторе автомобиля.',
        9),
       ('Агрегация – это когда экземпляр двигателя создается где-то в другом месте кода, и передается в конструктор автомобиля в качестве параметра.',
        10),
       ('Связывание означает наличие связи между ссылкой и кодом. Например, переменная, на которую вы ссылаетесь, привязана к коду, в котором она определена. Аналогично, вызываемый метод привязан к месту в коде, где он определен.\n
Раннее связывание - Если метод известен компилятору,  то происходит ранее связывание на этапе компиляции (early binding), также называют статическим связыванием. Используется для final, перегруженных, статических методов.\n
Позднее связывание (late binding) - вызов метода возможен только во время выполнения, т.к. у компилятора нет информации, чтобы проверить корректность такого вызова. В java это возможно при помощи рефлексии. Используется для переопределенных и абстрактных методов.\n
 Вот пример: Object a = ... // какое-то присваивание a.toString(); На этапе компиляции мы не знаем, какого типа объект a. Он может быть как собственно Object, так и любым его наследником, в котором метод toString() переопределён. Именно на этапе выполнения определяется тип a и вызывается toString() из того класса, какого типа объект a. Это и есть позднее связывание.\n
В случае статического связывания используются не конкретные объекты, а информация о типе, то есть используется тип ссылочной переменной. С другой стороны, при динамическом связывании для нахождения нужного метода используется конкретный объект.\n
Исходя из того, что раннее связывание выполняется на этапе компиляции, а позднее - в рантайме, первый вариант обладает лучшим быстродействием, однако второй необходим для реализации полиморфизма.',
        11),
       ('SOLID — это акроним, образованный из заглавных букв первых пяти принципов ООП и проектирования.\n
S(Single Responsibility Principle) - принцип единственной ответственности - каждый класс выполняет лишь одну задачу. Легкая модификация в будущем, простое тестирование, класс не имеет зависимостей на другие классы.\n
O(Open Closed Principle) - принцип открытости/закрытости - программные сущности открыты для расширения и закрыты для модификации. Чтобы не сломать логику в классе-родителе, мы унаследуемся от него и реализуем что-то своё, и используем свой класс.\n
L(Liskov’s Substitution Principle) - принцип подстановки барбары лисков -  объекты в программе можно заменить их наследниками без изменения свойств программы.\n
I(Interface Segregation Principle) - принцип разделения интерфейса - много специализированных интерфейсов лучше, чем один общий\n
D(Dependency Inversion Principle) - принцип инверсии зависимостей - зависимость на абстракциях. Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.',
        12),
       ('«Написано однажды - работает везде». Идея основывается в написании одного кода, который будет работать на любой платформе.',
        13),
       ('Кроссплатформенность была достигнута за счёт создания виртуальной машина Java. Java Virtual Machine или JVM - это программа, являющаяся прослойкой между операционной системой и Java программой. В среде виртуальной машины выполняются коды Java программ. Сама JVM реализована для разных ОС. Что байт код для JVM может исполняться везде где установлена JVM. Код не нужно перекомпилировать под каждую из платформ.',
        14),
       ('Объектно-ориентированное программирование - структура данных становится объектом, которым можно управлять для создания отношений между различными объектами.\n
Стандарт для корпоративных вычислительных систем - корпоративные приложения — главное преимущество Java с 90-х годов, когда организации начали искать надежные инструменты программирования не на C.\n
Безопасность - благодарю отсутсвию указателей и Security Manager (политика безопасности, в которой можно указать правила доступа, позволяет запускать приложения Java в "песочнице").\n
Независимость от платформы - Можно создать Java-приложение на Windows, скомпилировать его в байт-код и запустить его на любой другой платформе, поддерживающей виртуальную машину Java (JVM). Таким образом, JVM служит уровнем абстракции между кодом и оборудованием.\n
Язык для распределенного программирования и комфортной удаленной совместной работы - Специфическая для Java методология распределенных вычислений называется Remote Method Invocation (RMI). RMI позволяет использовать все преимущества Java: безопасность, независимость от платформы и объектно-ориентированное программирование для распределенных вычислений. Кроме того, Java также поддерживает программирование сокетов и методологию распределения CORBA для обмена объектами между программами, написанными на разных языках.\n
Автоматическое управление памятью - Разработчикам Java не нужно вручную писать код для управления памятью благодаря автоматическому управлению памятью (AMM).\n
Многопоточность - Поток — наименьшая единица обработки в программировании. Чтобы максимально эффективно использовать время процессора, Java позволяет запускать потоки одновременно, что называется многопоточностью.',
        15),
       ('Платное коммерческое использование (с 2019)\n
Низкая производительность - из-за компиляции и абстракции с помощью виртуальной машины, а также приложение очистки памяти.\n
Не развитые инструменты по созданию GUI приложений на чистой java.\n
Многословный код. Java — это более легкая версия неприступного C ++, которая вынуждает программистов прописывать свои действия словами из английского языка. Это делает язык более понятным для неспециалистов, но менее компактным.',
        16),
       ('JDK (Java Development Kit) - включает JRE и набор инструментов разработчика приложений на языке Java:\n
- компилятор Java (javac)\n
- стандартные библиотеки классов java\n
- примеры\n
- документацию\n
- различные утилиты', 17),
       ('JRE (java Runtime Environment) - минимально-необходимая реализация виртуальной машины для исполнения Java-приложений. Состоит из JVM, ClassLoader и стандартного набора библиотек и классов Java',
        18),
       ('JVM (Java Virtual Machine) - виртуальная машина Java исполняет байт-код Java, предварительно созданный из кода JIT компилятором, с помощью встроенного интерпретатора байткода.\n
HotSpot представляет собой реализацию концепции JVM.', 19),
       ('Байт-код Java — набор инструкций, скомпилированный компилятором, исполняемый JVM. ', 20),
       ('Используется для передачи в JVM скомпилированного байт-кода, хранится в файлах с расширением .class\n
При запуске JVM, используются три загрузчика классов:\n
- Bootstrap ClassLoader - базовый загрузчик - загружает платформенные классы JDK из архива rt.jar\n
- AppClassLoader - системный загрузчик (3) - загружает классы приложения, определенные в CLASSPATH\n
- Extension ClassLoader - загрузчик расширений (2) - загружает классы расширений, которые по умолчанию находятся в каталоге jre/lib/ext.\n
ClassLoader выполняет три основных действия в строгом порядке:\n
1. Загрузка: находит и импортирует двоичные данные для типа.\n
2. Связывание: выполняет проверку, подготовку и (необязательно) разрешение.\n
  - Проверка: обеспечивает правильность импортируемого типа.\n
  - Подготовка: выделяет память для переменных класса и инициализация памяти значениями по умолчанию.\n
  - Разрешение: преобразует символические ссылки из типа в прямые ссылки.\n
3. Инициализация: вызывает код Java, который инициализирует переменные класса их правильными начальными значениями.\n
Каждый загрузчик хранит указатель на родительский, чтобы суметь передать загрузку если сам будет не в состоянии этого сделать.',
        21),
       ('JIT (Just-In-Time) компилятор в Java - это компонент виртуальной машины Java (JVM), который переводит байт-код Java в машинный код во время выполнения программы. JIT-компиляция позволяет оптимизировать производительность приложения, поскольку ускоряет выполнение кода за счет компиляции только необходимых методов в машинный код на лету.',
        22),
       ('Сборщик мусора выполняет две задачи: - поиск мусора; - очистка мусора.\n
        Для обнаружения мусора есть два подхода:\n
Reference Counting - Суть подхода состоит в том, что каждый объект имеет некоторый счетчик. Этот счетчик хранит информацию о том, сколько ссылок указывает на объект. Kогда какая-либо ссылка уничтожается, то и значение счетчика уменьшается.Если значение счетчика равно нулю - объект можно считать мусором и память, которую он занимает, можно очищать. Tracing  Живые объекты - это те, до которых мы можем добраться от корня (GC Root), в то время как все остальные являются мусором. Существует 4 типа корневых точки:\n
         - Локальные переменные и параметры методов;\n
         - Потоки;\n
         - Статические переменные;\n
         - Ссылки из JNI.\n
         Самое простое java приложение будет иметь корневые точки:\n
         - Локальные переменные внутри main() метода и параметры main() метода;\n
         - Поток, который выполняет main();\n
         - Статические переменные класса, внутри которого находится main() метод\n
         Все что доступно с живого объекта - также живое.\n
- Трассировка (Tracing). (используется в HotSpot)6\n
Процессы сборки мусора разделяются несколько видов:\n
        minor GC (малая) - частый и быстрый, работает только с областью памяти "young generation";\n
         - приложение приостанавливается на начало сборки мусора (такие остановки называются stop-the-world);\n
         - «живые» объекты из Eden перемещаются в область памяти «To»;\n
         - «живые» объекты из «From» перемещаются в «To» или в «old generation», если они достаточно «старые»;\n
         - Eden и «From» очищаются от мусора;\n
         - «To» и «From» меняются местами;
         - приложение возобновляет работу.\n
        major GC (старшая) - редкий и более длительный, затрагивает объекты старшего поколения. В принцип работы «major GC» добавляется процедура «уплотнения», позволяющая более эффективно использовать память. В процедуре живые объекты перемещаются в начало. Таким образом, мусор остается в конце памяти.\n
        full GC (полная) -  полный сборщик мусора сначала запускает Minor, а затем Major (хотя порядок может быть изменен, если старое поколение заполнено, и в этом случае он освобождается первым, чтобы позволить ему получать объекты от молодого поколения).
', 23),
       ('1) StrongReference — это самые обычные ссылки которые мы создаем каждый день, любая переменная ссылочного типа.         StringBuilder builder = new StringBuilder(); - builder это и есть strong-ссылка на объект StringBuilder.Любой объект что имеет strong ссылку запрещен для удаления сборщиком мусора.\n
2) SoftReference —  GC гарантировано удалит с кучи все объекты, доступные только по soft-ссылке, перед тем как бросит OutOfMemoryError. SoftReference это наш механизм кэширования объектов в памяти, но в критической ситуации, когда закончится доступная память, GC удалит не использующиеся объекты из памяти и тем самым попробует спасти JVM от завершения работы.\n
   StringBuilder builder = new StringBuilder();\n
   SoftReference<StringBuilder> softBuilder = new SoftReference(builder);\n
   softBuilder.get() — вернет strong-ссылку на объект StringBuilder в случае если GC не удалил этот объект из памяти. В другом случае вернется null.\n
   softBuilder.clear() — удалит ссылку на объект StringBuilder То же самое работает для WeakReference.\n
3) WeakReference — если GC видит, что объект доступен только через цепочку weak-ссылок (исчезнули strong-ссылки), то он удалит его из памяти.',
        24),
       ('В Java, стек (stack) используется для хранения локальных переменных и вызовов методов. Каждый поток выполнения программы имеет свой собственный стек. Переменные на стеке имеют кратковременную жизнь и удаляются после выхода из метода.\n
Куча (heap) в Java используется для хранения объектов и доступна всем потокам. Память в куче выделяется для объектов и освобождается сборщиком мусора, когда объект больше не используется. Переменные ссылочного типа (например, объекты класса) хранятся в куче, а сами объекты на которые они ссылаются также лежат в куче.',
        25),
       ('В Java существует 8 примитивных типов данных:\n
1. byte: 8-битное целое число от -128 до 127.\n
2. short: 16-битное целое число от -32,768 до 32,767.\n
3. int: 32-битное целое число от -2,147,483,648 до 2,147,483,647.\n
4. long: 64-битное целое число от -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807.\n
5. float: 32-битное число с плавающей запятой от ~3.4e-38 до ~3.4e38.\n
6. double: 64-битное число с плавающей запятой от ~1.7e-308 до ~1.7e308.\n
7. boolean: логический тип данных, принимающий значение true или false.\n
8. char: 16-битный символ Unicode от 0 до 65,535.\n
Каждый примитивный тип данных имеет фиксированный размер и диапазон значений, который определяет, какие значения он может хранить.',
        26),
       ('16-разрядное беззнаковое целое, представляющее собой символ UTF-16 (буквы и цифры)', 27),
       ('Зависит от реализации JVM. В стандартной реализации Sun JVM и Oracle HotSpot JVM тип boolean занимает 4 байта (32 бита), как и тип int. Однако, в определенных версия JVM имеются реализации, где в массиве boolean каждое значение занимает по 1-му биту.',
        28),
       ('Обертка — это специальный класс, который хранит внутри себя значение примитива(объекты классов-оберток являются неизменяемыми (Immutable)). Нужны для реализации дженериков.',
        29),
       ('Автоупаковка - присвоение классу обертки значения примитивного типа;\n
Автораспаковка - присвоение переменной примитивного типа значение класса обертки.\n
для присваивания ссылок-примитивов объектам их классов-оберток (и наоборот) не требуется ничего делать, все происходит автоматически. Для того, чтобы иметь возможность оперировать с простыми числами (и boolean) как с объектами были придуманы классы-обёртки.',
        30),
       ('Неявное приведение – автоматическое расширение типа переменной от меньшего к большему.\n
Явное приведение -  явное сужение от большего к меньшему. Необходимо явно указать сужаемый тип.long l = (long)d; //explicit type casting int i = (int)l;\n
В случае с объектами мы можем делать неявное(автоматическое) приведение от наследника к родителю, но не наоборот, иначе получим ClassCastException.',
        31),
       ('В Java есть пул(pool) целых чисел в промежутке [-128;127], так как это самый часто вречающийся диапазон. Т.е. если мы создаем Integer в этом промежутке, то вместо того, чтобы каждый раз создавать новый объект, JVM берет их из пула.\n
Изменить размер кэша в HotSpot вы можете, указав ключ -XX:AutoBoxCacheMax=<размер>. ( внастройках JVM)', 32),
       ('Класс String в Java -  неизменяемый из-за модификатора final и отсутствия сеттера. Это нужно для реализации пула стрингов. При редактировании будет создаваться новая строка. При копировании новая строка не создается, а создается ссылка на существующую строку.',
        33),
       ('Область памяти где хранятся обьекты строк.\n
При создании в пуле идет поиск строки:\n
-если НЕ находит -  создается строка, возращается ссылка\n
-если находит - возращает ссылку найденной строки.\n
При этом использование оператора new заставляет класс String создать новый объект, даже если такая строка уже есть в пуле. После этого можем использовать метод intern(), чтобы поместить этот объект в пул строк.\n
Пул строк и Integer хранится в heap, но ссылки на объекты хранятся в stack.', 34),
       ('Т.к. строка неизменяемый класс, потребление ресурсов при редактировании, т.к. каждую итерацию при редактировании будет создаваться новый обьект строки. Рекомендуется использовать StringBuilder или StringBuffer.',
        35),
       ('1. Пул строк. Так как строки в Java хранятся в пуле строк, то ваш пароль в виде обычного текста будет доступен в памяти, пока сборщик мусора не очистит её. И поскольку String используются в String pool для повторного использования, существует довольно высокая вероятность того, что пароль останется в памяти надолго, что совсем не безопасно.\n
2. Рекомендации авторов. Java сама по себе рекомендует использовать метод getPassword () из класса JPasswordField, который возвращает char [].\n
3. Случайная печать в логах. С типом String всегда существует опасность того, что текст, хранящийся в строке будет напечатан в файле логов или в консоли. В то же время в случае использования Array, вы не будете печатать содержимое массива, а только его расположение в памяти.',
        36),
       ('1. Для возможности реализации строкового пула (String pool)\n
Виртуальная машина имеет возможность сохранить много места в памяти (heap space) т.к. разные строковые переменные указывают на одну переменную в пуле. При изменяемости строк было бы невозможно реализовать интернирование, поскольку если какая-либо переменная изменит значение, это отразится также и на остальных переменных, ссылающихся на эту строку.\n
2. Безопасность\n
Изменяемость строк несло бы в себе потенциальную угрозу безопасности приложения. Поскольку в Java строки используются для передачи параметров для авторизации, открытия файлов и т.д. — неизменяемость позволяет избежать проблем с доступом.\n
3. Для многопоточности. Неизменяемые строки потокобезопасны\n
Так как строка неизменяемая то, она безопасна для много поточности и один экземпляр строки может быть совместно использован различными потоками. Это позволяет избежать синхронизации для потокобезопасности. Таким образом, строки в Java полностью потокобезопасны.\n
4. Ключ для HashMap\n
Поскольку строка неизменная, её hashcode кэшируется в момент создания и нет никакой необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в Map и его обработка будет быстрее, чем других ключей HashMap. Поэтому строка наиболее часто используется в качестве ключа HashMap.\n
- можно передавать строку между потоками не опасаясь, что она будет изменена\n
- отсутствуют проблемы с синхронизацией потоков\n
- отсутствие проблем с  утечкой памяти\n
- отсутствие проблем с доступом и безопасностью при использовании строк для передачи параметров авторизации, открытия файлов и т.д.\n
- кэширование hashcode\n
- Экономия памяти при использовании пула строк для хранения повторяющихся строк.', 37),
       ('Поскольку строки неизменны, их хэшкод кэшируется в момент создания, и не требует повторного пересчета.', 38),
       ('Помещает строку в pool строк.', 39),
       ('Да, начиная с Java 7 в операторе switch можно использовать строки, ранние версии Java не поддерживают этого.\n
При этом:\n
- участвующие строки чувствительны к регистру;\n
- использование строк в конструкции switch делает код читабельнее, убирая множественные цепи условий if-else\n
- оператор switch использует метод String.equals() для сравнения полученного значения со значениями case, поэтому добавьте проверку на NULL во избежание NullPointerException.',
        40),
       ('String - неизменяемый, потокобезопасный;\n
StringBuffer - изменяемый, потокобезопасный;\n
StringBuilder - изменяемый, потоконебезопасный.', 41),
       ('Многомерные массивы в их классическом понимании в java не существуют.\n
Многомерный массив всегда прямоугольный и неразрывен в памяти. А то, что в java считается мнгомерным - в других языках ещё называют "зубчатым массивом" или массивом массивов.',
        42),
       ('byte 0\n
short 0\n
int 0\n
long 0L\n
float 0.0f\n
double 0.0d\n
char ''\u0000''\n
boolean false\n
Обьекты null\n
Локальные (в методе) переменные не имеют значений по умолчанию, их имеют поля класса.\n
Не static-поле класса будет инициализировано после того, как будет создан объект этого класса. А static-поле будет инициализировано тогда, когда класс будет загружен виртуальной Java машиной.',
        43),
       ('Это имя метода плюс параметры (порядок параметров имеет значение из-за множественной передачи данных через троеточие, которое должно располагаться последним). В сигнатуру метода не входит возвращаемое значение, а также бросаемые им исключения.\n
А сигнатура метода в сочетании с типом возвращаемого значения и бросаемыми исключениями называется контрактом метода.',
        44),
       ('Является, как правило, точкой входа в программу и вызывается JVM.\n
Как только заканчивается выполнение метода main(), так сразу же завершается работа самой программы.\n
static - чтобы JVM смогла загрузить его во время компиляции.\n
public static void и сигнатура - обязательное декларирование.\n
Мэйнов может быть много и может не быть вообще.\n
Может быть перегружен.', 45),
       ('Java передает параметры по значению. Всегда. С примитивами, мы получаем копию содержимого. Со ссылками мы тоже получаем копию ссылки.',
        46),
       ('1. Вложенные классы – нестатические классы внутри внешнего класса.\n
2. Вложенные статические классы – статические классы внутри внешнего класса.\n
3. Локальные классы Java – классы внутри методов. разница между локальным и внутреним\n
4. Анонимные Java классы – классы, которые создаются на ходу. Анонимные классы доступно\n
5. Final, abstract, enum - классы', 47),
       ('Нужны для обслуживания внешних классов\n
1. Статические вложенные классы (Static nested classes)\n
   - Есть возможность обращения к внутренним статическим полям и методам класса обертки.\n
2. Вложенные классы\n
   - Есть возможность обращения к внутренним полям и методам класса обертки.\n
   - Не может иметь статических объявлений.\n
   - Внутри такого класса нельзя объявить перечисления.\n
   - Если нужно явно получить this внешнего класса — OuterClass.this\n
3. Локальный класс\n
   - Видны только в пределах блока, в котором объявлены.\n
   - Не могут быть объявлены как private/public/protected или static (по этой причине интерфейсы нельзя объявить локально).\n
   - Не могут иметь внутри себя статических объявлений (полей, методов, классов), но могут иметь константы (static final)\n
   - Имеют доступ к полям и методам обрамляющего класса.\n
   - Можно обращаться к локальным переменным и параметрам метода, если они объявлены с модификатором final или являются effectively final.\n
   - Анонимные классы\n
   - Локальный класс без имени.', 48),
       ('Данные классы объявляются внутри других методов. Они обладают всеми свойствами нестатического вложенного класса, только создавать их экземпляры можно только в методе.\n
Особенности:
Локальные классы способны работать только с final переменными метода.\n
С 8+ версий Java можно использовать не final переменные в локальных классах, но только при условии, что они не будут изменяться.\n
Локальные классы нельзя объявлять с модификаторами доступа.\n
Локальные классы обладают доступом к переменным метода.\n
Может быть создан внутри блоков инициализации.', 49),
       ('Это вложенный локальный класс без имени, который разрешено декларировать в любом месте обрамляющего класса, разрешающем размещение выражений.\n
Создание экземпляра анонимного класса происходит одновременно с его объявлением. В зависимости от местоположения анонимный класс ведет себя как статический либо как нестатический вложенный класс - в нестатическом контексте появляется окружающий его экземпляр.\n
Анонимные классы имеют несколько ограничений:\n
Их использование разрешено только в одном месте программы - месте его создания;\n
Применение возможно только в том случае, если после порождения экземпляра нет необходимости на него ссылаться;\n
Реализует лишь методы своего интерфейса или суперкласса, т.е. не может объявлять каких-либо новых методов, так как для доступа к ним нет поименованного типа.\n
Анонимные классы обычно применяются для:\n
создания объекта функции (function object), например реализация интерфейса Comparator;\n
создания объекта процесса (process object), такого как экземпляры классов Thread, Runnable и подобных;\n
в статическом методе генерации;\n
инициализации открытого статического поля final, которое соответствует сложному перечислению типов, когда для каждого экземпляра в перечислении требуется отдельный подкласс.\n
Анонимные классы всегда являются конечными классами.\n
Каждое объявление анонимного класса уникально. Видны только внутри того метода, в котором определены. В документации Oracle приведена хорошая рекомендация: «Применяйте анонимные классы, если вам нужен локальный класс для одноразового использования». ',
        50),
       ('Статический вложенный класс имеет прямой доступ только к статическим полям обрамляющего класса.\n
Простой вложенный класс, может обратиться к любому полю внешнего класса напрямую.\n
В случае, если у вложенного класса уже существует поле с таким же литералом, то обращаться к внешнему полю следует через имя внешнего класса. Например: Outer.this.field.',
        51),
       ('Перечисления представляют набор логически связанных констант.\n
Перечисление фактически представляет новый класс, поэтому мы можем определить переменную данного типа и использовать ее.\n
Перечисления, как и обычные классы, могут определять конструкторы, поля и методы.\n
Следует отметить, что конструктор по умолчанию приватный. Также можно определять методы для отдельных констант.\n
Методы:\n
-ordinal() возвращает порядковый номер определенной константы (нумерация начинается с 0)\n
-values() возвращает массив всех констант перечисления\n
Еnum имеет ряд преимуществ при использовании в сравнении с static final int.\n
Главным отличием является то что используя enum вы можете проверить тип данных.\n
Недостатки\n
-  К ним не применимы операторы >, <, >=, <= \n
- enum также требует больше памяти для хранения чем обычная константа.\n
Нужны для ограничения области допустимых значений: например, времена года, дни недели', 52),
       ('В Java нет поддержки множественного наследования классов.\n
Предположим, что SuperClass — это абстрактный класс, описывающий некоторый метод, а классы ClassA и ClassB — обычные классы наследники SuperClass, а класс ClassC наследуется от ClassA и ClassB одновременно. Вызов метода родительского класса приведет к неопределенности, так как компилятор не знает о том, метод какого именно суперкласса должен быть вызван. Это и есть основная причина, почему в Java нет поддержки множественного наследования классов.\n
1. Классы всегда побеждают: Определенный в классе / суперклассе метод всегда имеет высший приоритет перед дефолтными методами интерфейсов.\n
2. Если не срабатывает правило 1, то побеждают саб-интерфейсы (more specific). Т.е. если интерфейс B наследует A, и у обоих есть методы с одинаковой сигнатурой, то побеждает B.\n
3. Если оба правила не работают, то класс, наследующий конфликтующие интерфейсы, должен явно через super определить, какой именно метод вызвать, иначе компилятор будет сильно материться.',
        53),
       ('Если у какого-либо класса не определить конструктор, то компилятор сгенерирует конструктор без аргументов - так называемый «конструктор по умолчанию».\n
Если у класса уже определен какой-либо конструктор, то конструктор по умолчанию создан не будет и, если он необходим, его нужно описывать явно.',
        54),
       ('Да, могут. Приватный конструктор запрещает создание экземпляра класса вне методов самого класса.\n
Нужен для реализации паттернов, например singleton.', 55),
       ('При запуске JVM, используются три загрузчика классов:\n
- Bootstrap ClassLoader - главный загрузчик - загружает платформенные классы JDK из архива rt.jar\n
- AppClassLoader - системный загрузчик - загружает классы приложения, определенные в CLASSPATH\n
- Extension ClassLoader - загрузчик расширений - загружает классы расширений, которые по умолчанию находятся в каталоге jre/lib/ext.\n
Динамическая загрузка происходит "на лету" в ходе выполнения программы с помощью статического метода класса Class.forName(имя класса). Для чего нужна динамическая загрузка? Например мы не знаем какой класс нам понадобится и принимаем решение в ходе выполнения программы передавая имя класса в статический метод forName().',
        56),
       ('-У конструктора по умолчанию отсутствуют какие-либо аргументы. \n
-Конструктор копирования принимает в качестве аргумента уже существующий объект класса для последующего создания его клона.\n
-Конструктор с параметрами имеет в своей сигнатуре аргументы (обычно необходимые для инициализации полей класса).', 57),
       ('Private – доступ к компоненту только из этого класса, в котором объявлен.\n
Default – Переменная или метод будут доступны для любого другого класса в том же пакете.\n
Protected – Поля protected доступны всем классам внутри пакета, а также всем классам-наследникам вне пакета.\n
Public – доступ к компоненту из экземпляра любого класса и любого пакета.\n
Класс может быть объявлен с модификатором public и default.', 58),
       ('Статическая переменная - это переменная, принадлежащая классу, а не объекту.\n
А статический класс- это вложенный класс, который может обращаться только к статическим полям обертывающего его класса.\n
Внутри static метода нельзя вызвать не статический метод по имени класса.', 59),
       ('Нельзя переопределять статические методы.\n
Если вы объявите такой же метод в классе-наследнике (subclass), т.е. метод с таким же именем и сигнатурой, вы лишь «спрячете» метод суперкласса  вместо переопределения. Это явление известно как сокрытие методов (hiding methods).\n
Перегружен - да. Всё работает точно так же как и с обычными методами - 2 статических метода могут иметь одинаковое имя, если количество их параметров или типов различается.',
        60),
       ('Да. Это будут просто два разных метода для программы. Статический будет доступен по имени класса.', 61),
       ('При переопределении метода нельзя сузить модификатор доступа к методу (например, с public до private), но можно расширить.\n
Изменить тип возвращаемого значения нельзя, но можно сузить возвращаемое значение, если они совместимы. Например, если метод возвращает объект класса, а переопределенный метод возвращает класс-наследник.',
        62),
       ('В сигнатуре(имя + параметры) менять ничего нельзя.\n
Возможно расширение уровня доступа.\n
Изменять тип возвращаемого значения при переопределении метода разрешено только в сторону сужения типа (вместо родительского класса - наследника).\n
Секцию throws метода можно не указывать, но стоит помнить, что она остаётся действительной, если уже определена у метода родительского класса. Так же, возможно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения RuntimeException. Порядок следования таких элементов при переопределении значения не имеет.',
        63),
       ('Класс можно объявить статическим за исключением классов верхнего уровня.\n
Такие классы известны как «вложенные статические классы» (nested static class). ', 64),
       ('Для класса это означает, что класс не сможет иметь подклассов, т.е. запрещено наследование. \n
Следует также отметить, что к abstract-классам нельзя применить модификатор final, т.к. это взаимоисключающие понятия.\n
Для переменных примитивного типа это означает, что однажды присвоенное значение не может быть изменено\n
Для ссылочных переменных это означает, что после присвоения объекта, нельзя изменить ссылку на данный объект. Важно: Ссылку изменить нельзя, но состояние объекта изменять можно.\n
Т.к. массив – это объект, то final означает, что после присвоения ссылки на объект, уже нельзя ее изменить, но можно изменять состояние объекта.',
        65),
       ('Абстрактным называется класс, на основе которого не могут создаваться объекты.\n
Как обычный класс, но с абстрактными методами.\n
Нельзя создать объект или экземпляр абстрактного класса.\n
Наследниками абстрактного класса могут быть другие абстрактные классы', 66),
       ('Класс может быть абстрактным без единого абстрактного метода, если у него указан модификатор abstract.', 67),
       ('Да. Необходимы для наследников.\n
В абстрактном классе в Java можно объявить и определить конструкторы. Даже если вы не объявили никакого конструктора, компилятор добавит в абстрактный класс конструктор по умолчанию без аргументов. Абстрактные конструкторы будут часто использоваться для обеспечения ограничений класса или инвариантов, таких как минимальные поля, необходимые для настройки класса.',
        68),
       ('Интерфейс — это план класса или, можно сказать, набор абстрактных методов и статических констант. В интерфейсе каждый метод является открытым и абстрактным, но не содержит конструктора. Таким образом, интерфейс в основном представляет собой группу связанных методов с пустыми телами. Другими словами, интерфейс определяет как элементы будут взаимодействовать между собой.\n
- методы интерфейса являются публичными (public) и абстрактными (abstract)\n
- поля — public static final.', 69),
       ('1. Интерфейс описывает только поведение (методы) объекта, а вот состояний (полей) у него нет (кроме public static final), в то время как у абстрактного класса они могут быть.\n
2. Мы можем наследовать только один класс, а реализовать интерфейсов — сколько угодно. Интерфейс может наследовать (extends) другой интерфейс/интерфейсы.\n
3. Абстрактные классы используются, когда есть отношение "is-a", то есть класс-наследник расширяет базовый абстрактный класс, а интерфейсы могут быть реализованы разными классами, вовсе не связанными друг с другом.\n
4. Абстрактный класс может реализовывать методы; интерфейс может реализовывать статические методы начиная с 8й версии.',
        70),
       ('Да, может. Используется ключевое слово extends', 71),
       ('В JDK 8 была добавлена такая функциональность как методы по умолчанию с модификатором default. И теперь интерфейсы могут иметь их реализацию по умолчанию, которая используется, если класс, реализующий данный интерфейс, не реализует метод. Это нужно для обратной совместимости.\n
(Если один или несколько методов добавляются к интерфейсу, все реализации также будут вынуждены их реализовывать. Методы интерфейса по умолчанию являются эффективным способом решения этой проблемы.) ',
        72),
       ('класс, наследующий конфликтующие интерфейсы, должен явно через super определить, какой именно метод вызвать:\n
InterfaceB.super.method();', 73),
       ('1. Статические блоки от первого до последнего предка(от предка до наследника)\n
2. Попарно динамической блок инициализации и конструктор от первого до последнего предка', 74),
       ('Инициализация - это когда мы впервые задаем переменной какое-либо значение.\n
Существуют статические и нестатические блоки инициализации.', 75),
       ('Статические блоки инициализация используются для выполнения кода, который должен выполняться один раз при инициализации класса загрузчиком классов, в момент предшествующий созданию объектов этого класса при помощи конструктора. Такой блок принадлежит только самому классу.',
        76),
       ('Для нестатических блоков инициализации, если выбрасывание исключения прописано явным образом, требуется, чтобы объявления этих исключений были перечислены в throws всех конструкторов класса. Иначе будет ошибка компиляции.\n
Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции.', 77),
       ('Если возникшее исключение - наследник RuntimeException:\n
-для статических блоков инициализации будет выброшено java.lang.ExceptionInInitializerError;\n
-для нестатических будет проброшено исключение-источник.\n
Если возникшее исключение - наследник Error, то в обоих случаях будет выброшено java.lang.Error.\n
Если исключение: java.lang.ThreadDeath - смерть потока. В этом случае никакое исключение выброшено не будет.', 78),
       ('Базовый класс для всех остальных объектов в Java. Любой класс наследуется от Object и, соответственно, наследуют его методы\n
Все классы являются наследниками суперкласса Object. Это не нужно указывать явно. В результате объект Object может ссылаться на объект любого другого класса.\n',
        79),
       ('- equals() - проверка на равенство двух обьектов\n
- hashCode() - изначально случайно число int\n
- toString() - представления данного объекта в виде строки.\n
- getClass() - получение типа данного обьекта\n
- clone() -  клонирует объект методом.\n
- finalize() - deprecated, вызывается GC перед удалением. (нет гарантии что будет вызван)\n
для многопоточки\n
- notify() - «размораживает» одну случайную нить\n
- notifyAll() - «размораживает» все нити данного монитора\n
- wait() - нить освобождает монитор и «становится на паузу»\n
- wait(long timeOut) - нить освобождает монитор и «становится на паузу»,принимает максимальное время ожидания в миллисекундах.\n
- wait(long timeOut, int nanos) - нить освобождает монитор и «становится на паузу»,принимает максимальное время ожидания в миллисекундах, дополнительное время, в диапазоне наносекунд 0-999999.',
        80),
       ('Хеш-код — это целочисленный результат работы метода, которому в качестве входного параметра передан объект.\n
Если более точно, то это битовая строка фиксированной длины, полученная из массива произвольной длины. \n
Equals - это метод, определенный в Object, который служит для сравнения объектов. При сравнении объектов при помощи == идет сравнение по ссылкам. При сравнении по equals() идет сравнение по состояниям объектов.\n
Свойства equals():\n
•        Симметричность: Для двух ссылок, a и b, a.equals(b) тогда и только тогда, когда b.equals(a)\n
•        Рефлексивность: для любого заданного значения x, выражение x.equals(x) должно возвращать true.\n
                                         Заданного — имеется в виду такого, что x != null
•        Постоянство: повторный вызов метода equals() должен возвращать одно и тоже значение до тех пор, пока какое-либо значение свойств объекта не будет изменено.\n
•        Транзитивность: Если a.equals(b) и b.equals(c), то тогда a.equals(c)\n
•        Совместимость с hashCode(): Два тождественно равных объекта должны иметь одно и то же значение hashCode()\n
При переопределении equals() обязательно нужно переопределить метод hashCode(). Равные объекты должны возвращать одинаковые хэш коды.',
        81),
       ('1 - Реализация метода Object.equals() сводится к проверке на равенство двух ссылок:\n
public boolean equals(Object obj) {\n
  return (this == obj);\n
}\n
2 - HashCode реализован таким образом, что для одного и того же входного объекта, хеш-код всегда будет одинаковым.\n
Реализация метода Object.hashCode() описана как native, т.е. написана не на Java. Непереопределенный hashCode возвращает идентификационный хеш, основанный на состоянии потока, объединённого с xorshift (в OpenJDK8). А вообще, функция предлагает шесть методов на базе значения переменной hashCode.\n
0. Случайно сгенерированное число.\n
1. Функция адреса объекта в памяти.\n
2. Жёстко запрограммированное значение 1 (используется при тестировании на чувствительность (sensitivity testing)).\n
3. Последовательность.\n
4. Адрес объекта в памяти, приведённый к целочисленному значению.\n
5. Состояние потока, объединённое с xorshift (https://en.wikipedia.org/wiki/Xorshift)\n
public native int hashCode();\n
Ситуация, когда у разных объектов одинаковые хеш-коды называется — коллизией. Вероятность возникновения коллизии зависит от используемого алгоритма генерации хеш-кода.',
        82),
       ('equals() -  сравнение по состоянию, == -  по ссылкам', 83),
       ('1. Проверить на равенство ссылки объектов this и параметра метода o.\n
if (this == o) return true;\n
2. Проверить, определена ли ссылка o, т. е. является ли она null.\n
Если в дальнейшем при сравнении типов объектов будет использоваться оператор instanceof, этот пункт можно пропустить, т. к. этот параметр возвращает false в данном случае null instanceof Object.\n
3. Сравнить типы объектов this и o с помощью оператора instanceof или метода getClass(), руководствуясь описанием выше и собственным чутьем.\n
4. Если метод equals переопределяется в подклассе, не забудьте сделать вызов super.equals(o)\n
5. Выполнить преобразование типа параметра o к требуемому классу.\n
6. Выполнить сравнение всех значимых полей объектов:\n
  - для примитивных типов (кроме float и double), используя оператор == \n
  - для ссылочных полей необходимо вызвать их метод equals\n
  - для массивов можно воспользоваться перебором по циклу, либо методом Arrays.equals()\n
  - для типов float и double необходимо использовать методы сравнения соответствующих оберточных классов Float.compare() и Double.compare()',
        84),
       ('Нарушится контракт. Классы и методы, которые использовали правила этого контракта могут некорректно работать. Так для объекта HashMap это может привести к тому, что пара, которая была помещена в Map возможно не будет найдена в ней при обращении к Map, если используется новый экземпляр ключа.',
        85),
       ('1) Если два объекта возвращают разные значения hashcode(), то они не могут быть равны\n
2) Если equals объектов true, то и хэшкоды должны быть равны. \n
3) Переопределив equals, всегда переопределять и hashcode.', 86),
       ('вычисляет целочисленное значение для конкретного элемента класса, чтобы использовать его для быстрого поиска и доступа к этому элементу в hash-структурах данных, например, HashMap, HashSet и прочих.',
        87),
       ('Если хеш-коды разные, то и входные объекты гарантированно разные.\n
Если хеш-коды равны, то входные объекты не всегда равны.\n
При вычислении хэш-кода следует использовать те же поля, которые сравниваются в equals и которые не вычисляются на основе других значений.\n
- вызов метода hashCode один и более раз над одним и тем же объектом должен возвращать одно и то же хэш-значение, при условии что поля объекта, участвующие в вычислении значения, не изменялись.\n
- вызов метода hashCode над двумя объектами должен всегда возвращать одно и то же число, если эти объекты равны (вызов метода equals для этих объектов возвращает true).\n
- вызов метода hashCode над двумя неравными между собой объектами должен возвращать разные хэш-значения. Хотя это требование и не является обязательным, следует учитывать, что его выполнение положительно повлияет на производительность работы хэш-таблиц.',
        88),
       ('Выбирать поля, которые с большой долью вероятности будут различаться. Для этого необходимо использовать уникальные, лучше всего примитивные поля, например такие как id, uuid. При этом нужно следовать правилу, если поля задействованы при вычислении hashCode(), то они должны быть задействованы и при выполнении equals().',
        89),
       ('Могут. Когда у разных объектов одинаковые хеш-коды называется — коллизией.', 90),
       ('В Java множество возможных хэш кодов ограничено типом int, а множество объектов ничем не ограничено.\n
Из-за этого, вполне возможна ситуация, что хэш коды разных объектов могут совпасть', 91),
       ('Множитель создает зависимость значения хэш-кода от очередности обработки полей, а это дает гораздо лучшую хэш-функцию.',
        92),
       ('getClass() получает только класс, а оператор instanceof проверяет является ли объект экземпляром класса или его потомком',
        93),
       ('Исключение — это ошибка (является объектом), возникающая во время выполнения программы. ', 94),
       ('1. класс Throwable (checked)\n
2. от Throwable  -> Error (ошибки JVM) и Exception (checked общие)\n
3. от Exception \n
    - > RuntimeException (unchecked)\n
    - > IOException, SQLException, ReflectiveOperationException (checked)\n
4.RuntimeException (unchecked):\n
  ClassCastExceptiuon\n
  IndexOutOfBoundException\n
  AritthmeticException\n
  NullPointerException\n', 95),
       ('1. Checked исключения, это те, которые должны обрабатываться блоком catch или описываться в сигнатуре метода. Unchecked могут не обрабатываться и не быть описанными.\n
2. Unchecked исключения в Java — наследованные от RuntimeException, checked — от Exception.\n
Checked исключения отличаются от Unchecked исключения в Java, тем что \n
наличие\обработка Checked исключения проверяются компилятором на этапе компиляции.\n
Наличие\обработка Unchecked исключения происходит на этапе выполнения.\n', 96),
       ('Можно, чтобы в некоторых случаях программа не прекратила работу', 97),
       ('Throw', 98),
       ('Метод потенциально может выбросить исключение с указанным типом. \n
Передаёт обработку исключения вышестоящему методу.', 99),
       ('Необходимо унаследоваться от базового класса требуемого типа исключений (например, от Exception или RuntimeException) и переопределить методы', 100),
       ('Try - блок в котором может появиться исключение;\n
Catch - блок в котором мы указываем исключение и логику его обработки;\n
Finally - блок который обязательно отработает', 101),
       ('try может быть в паре с finally, без catch. Работает это точно так же - после выхода из блока try выполняется блок finally', 102),
       ('Да', 103),
       ('Да, кроме случаев завершения работы программы или JVM:\n
1 - Finally может не выполниться в случае если в блоке try вызывает System.exit(0),\n
2 - Runtime.getRuntime().exit(0), Runtime.getRuntime().halt(0) и если во время исполнения блока try виртуальная машина выполнила недопустимую операцию и будет закрыта.\n
3 - В блоке try{} бесконечный цикл.', 104),
       ('Может и оно будет передано в виртуальную машину Java (JVM).\n
Для случая с методом main произойдет две вещи:\n
- будет завершен главный поток приложения;\n
- будет вызван ThreadGroup.uncaughtException.', 105),
       ('От наследника к предку', 106),
       ('Дает возможность объявлять один или несколько ресурсов в блоке try, которые будут закрыты автоматически без использования finally блока.\n
В качестве ресурса можно использовать любой объект, класс которого реализует интерфейс java.lang.AutoCloseable или java.io.Closeable.\n
Closeable extends AutoCloseable', 107),
       ('finally-секция может «перебить» throw/return при помощи другого throw/return', 108),
       ('В try-with-resources добавленна возможность хранения "подавленных" исключений, и брошенное try-блоком исключение имеет больший приоритет, чем исключения получившиеся во время закрытия.', 109),
       ('Сериализация это процесс сохранения состояния объекта в последовательность байт;\n
Реализована через интерфейс - маркер Serializable. ', 110),
       ('Для компактного сохранения состояния объекта и считывание этого состояния.', 111),
       ('1) Класс объекта должен реализовывать интерфейс Serializable\n
2) Создать поток ObjectOutputStream (oos), который записывает объект в переданный OutputStream.\n
3) Записать в поток: oos.writeObject(Object);\n
4) Сделать oos.flush() и oos.close()', 112),
       ('Использовать интерфейс Externalizable. \n
Переопределить методы\n
 writeExternal(ObjectOutput out) throws IOException\n
 readExternal(ObjectInput in) throws IOException, ClassNotFoundException', 113),
       ('1) Добавить к полю модификатор transient. В таком случае после восстановления его значение будет null.\n
2) Сделать поле static. Значения статических полей автоматически не сохраняются.\n
3) Поля с модификатором final сериализуются как и обычные. За одним исключением – их невозможно десериализовать при использовании Externalizable, поскольку final-поля должны быть инициализированы в конструкторе, а после этого в readExternal изменить значение этого поля будет невозможно. Соответственно, если необходимо сериализовать объект с final-полем неоходимо использовать только стандартную сериализацию.', 114),
       ('Для создания собственного протокола нужно просто переопределить writeExternal() и readExternal().\n
В отличие от двух других вариантов сериализации, здесь ничего не делается автоматически. Протокол полностью в ваших руках. ', 115),
       ('Поле private static final long serialVersionUID содержит уникальный идентификатор версии сериализованного класса. Оно вычисляется по содержимому класса - полям, их порядку объявления, методам, их порядку объявления. Соответственно, при любом изменении в классе это поле поменяет свое значение.\n
Если мы не объявляем его явно, Java делает это за нас.', 116),
       ('Вы должны изменить serialVersionUID только тогда, когда вы сознательно хотите нарушить совместимость со всеми существующими сериализациями , например, когда изменения в вашем классе сделают его настолько семантически отличным, что у вас не будет выбора - в этом случае вы действительно должны несколько раз подумать о том, что вы на самом деле делаете.', 117),
       ('- Проблема - в том что после десериализации мы получим другой объект.\n
Таким образом, сериализация дает возможность создать Singleton еще раз, что не совсем нужно.\n
- Решение - В классе определяется метод с сигнатурой "Object readResolve() throws ObjectStreamException"\n
- Назначение  - этого метода - возвращать замещающий объект вместо объекта, на котором он вызван.', 118),
       ('в Java, есть 3 способа клонирования объекта:\n
1. С использованием интерфейса Cloneable; \n
Первый способ подразумевает, что вы будете использовать механизм так называемого «поверхностного клонирования» и сами позаботитесь о клонировании полей-объектов. Метод clone() в родительском классе Object является protected, поэтому требуется переопределение его с объявлением как public. Он возвращает экземпляр объекта с копированными полями-примитивами и ссылками. И получается что у оригинала и его клона поля-ссылки указывают на одни и те же объекты.\n
2. С использованием конструктора клонирования объекта;\n
В классе описывается конструктор, который принимает объект этого же класса и инициализирует значениями его полей поля нового объекта.\n
3. С использованием сериализации.\n
Он заключается в сохранении объекта в поток байтов с последующей эксгумацией его от туда.', 119),
       ('Поверхностное копирование копирует настолько малую часть информации, насколько это возможно. По умолчанию, клонирование в Java является поверхностным, т.е. Object class не знает о структуре класса, которого он копирует.\n
Глубокое копирование дублирует все. Глубокое копирование — это две коллекции, в одну из которых дублируются все элементы оригинальной коллекции. ', 120),
       ('Наиболее безопасным и следовательно предпочтительным способом клонирования является использование специализированного конструктора копирования:\n
Отсутствие ошибок наследования (не нужно беспокоиться, что у наследников появятся новые поля, которые не будут склонированы через метод clone());\n
Поля для клонирования указываются явно;\n
Возможность клонировать даже final поля.', 121),
       ('Метод clone() объявлен в классе Object с сигнатурой native, чтобы обеспечить доступ к стандартному механизму "поверхностного копирования" объектов (копируются значения всех полей, включая ссылки на сторонние объекты); он объявлен, как protected, чтобы нельзя было вызвать этот метод у не переопределивших его объектов. ', 122),
       ('Глубокое клонирование требует выполнения следующих правил:\n
-Нет необходимости копировать отдельно примитивные данные;\n
-Все классы-члены в оригинальном классе должны поддерживать клонирование. Для каждого члена класса должен вызываться super.clone() при переопределении метода clone();\n
-Если какой-либо член класса не поддерживает клонирование, то в методе клонирования необходимо создать новый экземпляр этого класса и скопировать каждый его член со всеми атрибутами в новый объект класса, по одному.\n
1 Сериализация – это еще один способ глубокого копирования. Мы просто сериализуем нужный объект и десериализуем его. Очевидно, объект должен поддерживать интерфейс Serializable. Мы сохраняет объект в массив байт и потом прочитать из него.\n
2 При помощи библиотеки DeepCloneable\n
Глубокое клонирование с этой библиотекой сводится с двум строкам кода:\n
Cloner cloner = new Cloner();\n
DeepCloneable clone = cloner.deepClone(this);', 123);
