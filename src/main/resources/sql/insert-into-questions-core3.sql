INSERT INTO questions (question, answer, theme, is_impotent)
VALUES ('Чем отличается процесс от потока?', 'Процесс - это экземпляр выполняющейся программы, простыми словами при запуске любой программы на вашем компьютере, вы порождаете процесс. Он имеет свое собственное адресное пространство памяти и один или несколько потоков.\n\n Поток - это последовательность инструкций, выполняющаяся внутри процесса.', 'CORE3_MULTITHREADING', false),
       ('В чем разница между классом Thread и интерфейсом Runnable? В каких случаях предпочтительно использовать Thread, а в каких Runnable?', 'Thread - это класс, некоторая надстройка над физическим потоком.\n\n Runnable - это интерфейс, представляющий абстракцию над выполняемой задачей.\n\n Помимо того, что Runnable помогает разрешить проблему множественного наследования, несомненный плюс от его использования состоит в том, что он позволяет логически отделить логику выполнения задачи от непосредственного управления потоком.\n\n В классе Thread имеется несколько методов, которые можно переопределить в порожденном классе. Из них обязательному переопределению подлежит только метод run(). Этот же метод, безусловно, должен быть определен и при реализации интерфейса Runnable.\n\n Некоторые программисты считают, что создавать подкласс, порожденный от класса Thread, следует только в том случае, если нужно дополнить его новыми функциями.\n\n Так, если переопределять любые другие методы из класса Thread не нужно, то можно ограничиться только реализацией интерфейса Runnable.\n Кроме того, реализация интерфейса Runnable позволяет создаваемому потоку наследовать класс, отличающийся от Thread', 'CORE3_MULTITHREADING', false),
       ('Что представляет собой монитор? Как в Java реализован монитор?', '\tВ Java у каждого класса и объекта есть привязанный к нему монитор. Монитор - механизм синхронизации потоков, обеспечивающий доступ к неразделяемым ресурсам. Частью монитора является mutex, который встроен в класс Object и имеется у каждого объекта.\n
\tУдобно представлять mutex как id захватившего его объекта. Если этот id равен 0 – ресурс свободен. Если не 0 – ресурс занят. Можно встать в очередь и ждать его освобождения.\n
\tВ Java монитор реализован с помощью ключевого слова synchronized.', 'CORE3_MULTITHREADING', true),
       ('Что такое синхронизация? Какие методы синхронизации существуют в Java?', 'Синхронизация это процесс, который позволяет выполнять потоки параллельно.\n\n
В Java все объекты имеют блокировку, благодаря которой только один поток одновременно может получить доступ к критическому коду в объекте. Такая синхронизация помогает предотвратить повреждение состояния объекта.\n\n
Способы синхронизации в Java:\n\n
Системная синхронизация с использованием wait()/notify().\n
Поток, который ждет выполнения каких-либо условий, вызывает у этого объекта метод wait(), предварительно захватив его монитор. На этом его работа приостанавливается. Другой поток может вызвать на этом же самом объекте метод notify() (опять же, предварительно захватив монитор объекта), в результате чего, ждущий на объекте поток «просыпается» и продолжает свое выполнение. В обоих случаях монитор надо захватывать в явном виде, через synchronized-блок, потому как методы wait()/notify() не синхронизированы!\n\n
Системная синхронизация с использованием join().\n
Метод join(), вызванный у экземпляра класса Thread, позволяет текущему потоку остановиться до того момента, как поток, связанный с этим экземпляром, закончит работу.\n\n
Использование классов из пакета java.util.concurrent.Locks - механизмы синхронизации потоков, альтернативы базовым synchronized, wait, notify, notifyAll: Lock, Condition, ReadWriteLock.', 'CORE3_MULTITHREADING', true),
       ('Какое значение имеет ключевое слово synchronized? Где и для каких целей его следует использовать?', 'Зарезервированное слово позволяет добиваться синхронизации в помеченных им методах или блоках кода.\n\n Synchronized – лочит доступ к выполнению метода «условно» для всех потоков кроме 1, как 1 закончит работу может приступить 2 для этого метода. Переменные и конструкторы не могут быть Synchronized\n\n
Блокировка любая идет на классе или объекте а не на коде т.к синхронизируемся с помощью монитора на каком либо объекте или классе\n\n
Synchronized(this) – помогает пометить блок кода в методе чтобы не помечать весь метод\n\n
Synchronized блоки используем только тогда когда нужно избежать Data Race (гонка). Статик методы синхронизируются не по методу а по классу', 'CORE3_MULTITHREADING', false),
       ('Какой объект является монитором для статического synchronized-метода?', 'Объект типа Class, соответствующий классу, в котором определен метод.', 'CORE3_MULTITHREADING', false),
       ('Какой объект является монитором для нестатического synchronized-метода?', 'Объект this', 'CORE3_MULTITHREADING', false),
       ('Как действуют методы wait(), notify() и notifyAll() в контексте многопоточности?', 'wait(): освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не вызовет метод notify()/notifyAll();\n\n
notify(): Не освобождает монитор и будит поток у которого ранее был вызван метод waiit();\n\n
notifyAll(): Не освобождает монитор и будит все потоки у которых ранее был выван метод  waiit();\n\n
Когда вызван метод wait(), поток освобождает блокировку на объекте и переходит из состояния Работающий (Running) в состояние Ожидания (Waiting). Метод notify() подаёт сигнал одному из потоков, ожидающих на объекте, чтобы перейти в состояние Работоспособный (Runnable). При этом невозможно определить, какой из ожидающих потоков должен стать работоспособным. Метод notifyAll() заставляет все ожидающие потоки для объекта вернуться в состояние Работоспособный (Runnable). Если ни один поток не находится в ожидании на методе wait(), то при вызове notify() или notifyAll() ничего не происходит.\n\n
wait(), notify() и notifyAll() должны вызываться только из синхронизированного кода.', 'CORE3_MULTITHREADING', false),
       ('В каких состояниях может находиться поток?', 'New - объект класса Thread создан, но еще не запущен. Он еще не является потоком выполнения и естественно не выполняется.\n
Runnable - поток готов к выполнению, но планировщик еще не выбрал его.\n
Running – поток выполняется.\n
Waiting/blocked/sleeping - поток блокирован или поток ждет окончания работы другого потока.\n
Dead - поток завершен. Будет выброшено исключение при попытке вызвать метод start() для dead потока.\n
 public enum State (У класса Thread есть внутренний класс State - состояние, а также метод public State getState().)\n
{\n
 NEW, — поток создан, но еще не запущен;\n
 RUNNABLE, — поток выполняется;\n
 BLOCKED, — поток блокирован;\n
 WAITING, — поток ждет окончания работы другого потока;\n
 TIMED_WAITING, — поток некоторое время ждет окончания другого потока;\n
 TERMINATED; — поток завершен.\n
}', 'CORE3_MULTITHREADING', false),
       ('Что такое семафор? Как его можно реализовать в Java?', 'Semaphore – это синхронизатор позволяющий ограничить доступ к каждому ресурсу .В конструктор Симофор нужна передавать количество потоков, которым Симофор будет разрешать одновременно использовать этот ресурс. Доступ управляется с помощью счётчика: изначальное значение счетчика задается в конструкторе при создании синхронизатора, когда поток заходит в заданный блок кода, то значение счетчика уменьшается на единицу, когда поток его покидает, то увеличивается. Если значение счетчика равно нулю, то текущий поток блокируется, пока кто-нибудь не выйдет из защищаемого блока.\n\n Semaphore используется для защиты дорогих ресурсов, которые доступны в ограниченном количестве, например подключение к базе данных в пуле.', 'CORE3_MULTITHREADING', false),
       ('Какое значение имеет ключевое слово volatile? Почему операции с volatile переменными не являются атомарными?', 'Volatile - используется для пометки переменной как хранящейся только в основной памяти Main Memory(куча) !!!\n\n ИСПОЛЬЗУЕТСЯ ТОЛЬКО ТОГДА КОГДА ТОЛЬКО ОДИН ПОТОК МОЖЕТ ИЗМЕНЯТЬ ЗНАЧЕНИЕ ПЕРМЕННОЙ А ОСТАЛЬНЫЕ ПОТОКИ МОГУТ ЕЕ ТОЛЬКО ЧИТАТЬ!!!\n\n Переменная volatile является атомарной для чтения, но операции над переменной НЕ являются атомарными.\n\n Поля, для которых неприемлемо увидеть «несвежее» (stale) значение в результате кэширования или переупорядочения.\n\n
Если происходит какая-то операция, например, инкримент, то атомарность уже не обеспечивается, потому что сначала выполняется чтение(1), потом изменение(2) в локальной памяти, а затем запись(3).\n Такая операция не является атомарной и в неё может вклиниться поток по середине.\n\n
Атомарная операция выглядит единой и неделимой командой процессора.\n\n
Переменная volatile находится в хипе, а не в кэше стека . ', 'CORE3_MULTITHREADING', false),
       ('Зачем нужны атомарные (Atomic) типы данных? В чем отличие от переменных с ключевым словом volatile?', 'volatile не гарантирует атомарность.\n Например, операция count++ не станет атомарной просто потому что count объявлена volatile.\n C другой стороны class AtomicInteger предоставляет атомарный метод для выполнения таких комплексных операций атомарно над int,\n – Atomic - это семейство классов из java.util.concurrent.\n Они предоставляют набор атомарных операций для соответствующих типов.\n Например с помощью методов getAndIncrement/incrementAndGet класса AtomicInteger можно делать неатомарный в обычных условиях инкремент (i++).', 'CORE3_MULTITHREADING', true),
       ('Что представляют собой демон-потоки? Какова их роль и как создать демон-поток?', 'Потоки Демоны - потоки предназначены для выполнения фоновых задач и оказания различных сервисов USER потокам ( При завершении работы последнего USER потока программа завершает свое выполнеие не дожидаясь оконачание работы Демон потоков).\n\n Такой процесс может быть запущен как поток-демон с помощью метода setDaemon(boolean value), вызванного у потока до его запуска.\n Метод boolean isDaemon() позволяет определить, является ли указанный поток демоном или нет.\n Основной поток приложения может завершить выполнение потока-демона (в отличие от обычных потоков) с окончанием кода метода main(), не обращая внимания, что поток-демон еще работает.\n\n
Поток демон можно сделать только если он еще не запущен. Пример демона - GC.', 'CORE3_MULTITHREADING', false),
       ('Что такое приоритет потока? Как он влияет на выполнение потока? Какой приоритет у потоков по умолчанию?', 'Приоритеты потоков используются планировщиком потоков для принятия решений о том, когда какому из потоков будет разрешено работать. Теоретически высокоприоритетные потоки получают больше времени процессора, чем низкоприоритетные. Практически объем времени процессора, который получает поток, часто зависит от нескольких факторов помимо его приоритета(является ли поток демоном).\n\n
Чтобы установить приоритет потока, используется метод класса Thread: final void setPriority(int level). Значение level изменяется в пределах от Thread.MIN_PRIORITY = 1 до Thread.MAX_PRIORITY = 10. Приоритет по умолчанию - Thread.NORM_PRlORITY = 5.\n\n
Получить текущее значение приоритета потока можно вызвав метод: final int getPriority() у экземпляра класса Thread.\n\n
Метод yield() можно использовать для того чтобы принудить планировщик выполнить другой поток, который ожидает своей очереди.', 'CORE3_MULTITHREADING', false),
       ('Как работает метод Thread.join()? Для чего он используется?', 'Метод join() приостанавливает выполнение текущего потока до тех пор, пока не завершится другой поток.\n\n
Например, если есть 2 потока, t1 и t2, и написать — t1.join(), то t2 не начнёт работу, пока t1 не завершит свою.\n\n
Метод join() можно использовать, чтобы гарантировать последовательность выполнения потоков.', 'CORE3_MULTITHREADING', false),
       ('В чем разница между методами wait() и sleep()?', 'В отличие от метода wait(), при вызове sleep() текущий поток не освобождает монитор объекта, на котором он был вызван, и поэтому другой поток не может получить доступ к этому объекту, пока поток не вернется из режима сна.\n\n Таким образом,метод wait() используется для синхронизации потоков и координирования их работы, а метод sleep() используется для задержки выполнения потока на определенное время.', 'CORE3_MULTITHREADING', false),
       ('Можно ли вызвать start() для одного потока дважды?', 'Нельзя стартовать поток больше, чем единожды. В частности, поток не может быть перезапущен, если он уже завершил выполнение.', 'CORE3_MULTITHREADING', false),
       ('Как правильно остановить поток? Какие методы .stop(), .interrupt(), .interrupted(), .isInterrupted() используются и для каких целей?', 'Методом stop() пользоваться нельзя, метод помечен как deprecated. Такая жесткая остановка моментально возвращает все захваченные потоком  мониторы, и защищенные ими данные могут оказаться в неконсистентном состоянии.\n\n
Методы interrupt, interrupted, isInterrupted связаны с функцией прерывания потока:\n
- interrupt() — выставляет флаг прерывания на конкретном потоке, указывая, что ему следует остановиться. Ставит значение флага true\n\n.
- bool Thread.interrupted() — возвращает значение флага прерывания для текущего потока. После проверки всегда присваивает значение флага false и запускает поток.\n\n
- bool isInterrupted() — возвращает значение флага прерывания для того объекта, на котором вызван.Не запускает поток.\n\n
Как правильно остановить поток в Java?\n
Вместо принудительной остановки потока необходимо использовать метод оповещения о прекращении работы потока - interrupt(). Данный метод установит флаг прерывания потока (прекращения работы), который можно проверить методом isInterrupted() и указать логику его обработки и завершения работы потока.', 'CORE3_MULTITHREADING', false),
       ('В чем различия между интерфейсами Runnable и Callable?', 'Интерфейс Runnable появился в Java 1.0, а интерфейс Callable был введен в Java 5.0 в составе библиотеки java.util.concurrent;\n\n
Классы, реализующие интерфейс Runnable для выполнения задачи должны реализовывать метод run(). Классы, реализующие интерфейс Callable - метод call();\n\n
Метод Runnable.run() не возвращает никакого значения\n
Callable - это параметризованный функциональный интерфейс. Callable.call() возвращает Object, если он не параметризован, иначе указанный тип.\n
Метод run() НЕ может выбрасывать проверяемые исключения, в то время как метод call() может.', 'CORE3_MULTITHREADING', false),
       ('Что представляет собой FutureTask?', 'Интерфейс java.util.concurrent.Future описывает API для работы с задачами, результат которых мы планируем получить в будущем: методы получения результата, методы проверки статуса.\n\n FutureTask представляет собой отменяемое асинхронное вычисление в параллельном потоке.\n Этот класс предоставляет базовую реализацию Future, с методами для запуска и остановки вычисления, методами для запроса состояния вычисления и извлечения результатов.\n Результат может быть получен только когда вычисление завершено, метод получения будет заблокирован, если вычисление ещё не завершено.\n Объекты FutureTask могут быть использованы для обёртки объектов Callable и Runnable. Так как FutureTask помимо Future реализует Runnable, его можно передать в Executor на выполнение.', 'CORE3_MULTITHREADING', false),
       ('Что такое deadlock (взаимная блокировка)?', 'Взаимная блокировка (deadlock) - ситуация когда 2 и более потоков залочены навсегда, ожидают друг друга и ничего не делают.\n\n
Deadlock происходит, когда достигаются эти 4 состояния:\n\n
взаимного исключения: по крайней мере один ресурс занят в режиме неделимости и следовательно только один поток может использовать ресурс в данный момент времени.\n\n
удержания и ожидания: поток удерживает как минимум один ресурс и запрашивает дополнительные ресурсы, которые удерживаются другими потоками.\n\n
отсутствия предочистки: операционная система не переназначает ресурсы: если они уже заняты, они должны отдаваться удерживающим потокам сразу же.\n\n
цикличного ожидания: поток ждет освобождения ресурса другим потоком, который в свою очередь ждёт освобождения ресурса заблокированного первым потоком.\n\n
Простейший способ избежать взаимной блокировки – не допускать цикличного ожидания. Этого можно достичь, получая мониторы разделяемых ресурсов в определенном порядке и освобождая их в обратном порядке.', 'CORE3_MULTITHREADING', true),
       ('Что такое livelock? Как он отличается от deadlock?', 'livelock – ситуация когда 2 или более потоков залочены навсегда, ожидают друг друга, проделывают какую-то работу, но без какого-либо прогресса..\n\n При этом их состояния постоянно изменяются в зависимости друг от друга. Фактической ошибки не возникает, но КПД системы падает до 0. Часто возникает в результате попыток предотвращения deadlock.\n\n
Реальный пример livelock, – когда два человека встречаются в узком коридоре и каждый, пытаясь быть вежливым, отходит в сторону, и так они бесконечно двигаются из стороны в сторону, абсолютно не продвигаясь в нужном им направлении.', 'CORE3_MULTITHREADING', true),
       ('Что представляет собой race condition?', '\tВ контексте Java race condition возникает, когда два или более потоков одновременно обращаются к общему ресурсу (например, переменной, коллекции, объекту) и пытаются изменить его, что может привести к неожиданным или некорректным результатам.\n \t Методы для предотвращения Race Condition в Java:\n 1. Использование ключевого слова synchronized\n 2. Использование объекта ReentrantLock\n 3. Использование атомарных типов', 'CORE3_MULTITHREADING', true),
       ('Что такое фреймворк fork/join? Какова его роль и назначение?', 'Фреймворк Fork/Join, представленный в JDK 7, - это набор классов и интерфейсов позволяющих использовать преимущества многопроцессорной архитектуры современных компьютеров.\n Он разработан для выполнения задач, которые можно рекурсивно разбить на маленькие подзадачи, которые можно решать параллельно.\n\n
Этап Fork: большая задача разделяется на несколько меньших подзадач, которые в свою очередь также разбиваются на меньшие. И так до тех пор, пока задача не становится тривиальной и решаемой последовательным способом.\n\n
Этап Join: далее (опционально) идёт процесс «свёртки» - решения подзадач некоторым образом объединяются пока не получится решение всей задачи.\n\n
Решение всех подзадач (в т.ч. и само разбиение на подзадачи) происходит параллельно.\n
Для решения некоторых задач этап Join не требуется. Например, для параллельного QuickSort — массив рекурсивно делится на всё меньшие и меньшие диапазоны, пока не вырождается в тривиальный случай из 1 элемента. Хотя в некотором смысле Join будет необходим и тут, т.к. всё равно остаётся необходимость дождаться пока не закончится выполнение всех подзадач.\n\n
Ещё одно преимущество этого фреймворка заключается в том, что он использует work-stealing алгоритм: потоки, которые завершили выполнение собственных подзадач, могут «украсть» подзадачи у других потоков, которые всё ещё заняты.', 'CORE3_MULTITHREADING', false),
       ('Что входит в java.util.concurrent?', 'Классы и интерфейсы пакета java.util.concurrent объедининены в несколько групп по функциональному признаку:\n\n  collections - Набор эффективно работающих в многопоточной среде коллекций. CopyOnWriteArrayList(Set), ConcurrentHashMap. Итераторы классов данного пакета представляют данные на определенный момент времени. Все операции по изменению коллекции (add, set, remove) приводят к созданию новой копии внутреннего массива. Этим гарантируется, что при проходе итератором по коллекции не будет ConcurrentModificationException.\n\n
synchronizers - Объекты синхронизации, позволяющие разработчику управлять и/или ограничивать работу нескольких потоков. Cодержит пять объектов синхронизации: semaphore, countDownLatch, ciclycBarrier, exchanger, phaser.\n\n
atomic - Набор атомарных классов для выполнения атомарных операций. Операция является атомарной, если её можно безопасно выполнять при параллельных вычислениях в нескольких потоках, не используя при этом ни блокировок, ни синхронизацию synchronized. Queues - содержит классы формирования неблокирующих и блокирующих очередей для многопоточных приложений. Неблокирующие очереди «заточены» на скорость выполнения, блокирующие очереди приостанавливают потоки при работе с очередью. Locks - Механизмы синхронизации потоков, альтернативы базовым synchronized, wait, notify, notifyAll: Lock, Condition, ReadWriteLock.\n\n
Executors - включает средства, называемые сервисами исполнения, позволяющие управлять потоковыми задачами с возможностью получения результатов через интерфейсы Future и Callable.', 'CORE3_MULTITHREADING', true),
       ('Что такое Executor в контексте пакета java.util.concurrent?', 'В Java Executor - это интерфейс из пакета java.util.concurrent, который предоставляет абстракцию для выполнения асинхронных задач. Он представляет собой механизм для управления потоками и позволяет разделять задачи на более мелкие, выполняемые параллельно.\n\n
Executor обеспечивает разделение между задачей (что нужно выполнить) и механизмом выполнения (как это будет выполнено). Он определяет всего один метод:\n\n
   void execute(Runnable command);\n\n
Метод execute() принимает объект типа Runnable (или его подклассы) в качестве параметра и назначает его для выполнения. Исполнение самой задачи может происходить в отдельном потоке, пуле потоков или другой среде исполнения, управляемой конкретной реализацией Executor.\n\n
Некоторые распространенные реализации интерфейса Executor включают:\n\n
- ExecutorService: Расширяет интерфейс Executor и добавляет дополнительные возможности, такие как возвратные значения и завершение задач. Предоставляет методы для управления циклами выполнения и получения результатов задач.\n\n
- ThreadPoolExecutor: Реализация ExecutorService, которая создает и управляет пулом потоков для выполнения задач. Позволяет контролировать параметры пула потоков, такие как размер пула, очередь задач и политику отклонения задач.\n\n
- ScheduledExecutorService: Расширение ExecutorService, которое поддерживает планирование выполнения задач в определенное время или с определенной периодичностью. Позволяет создавать периодические задачи и запускать их с заданным интервалом.', 'CORE3_MULTITHREADING', false),
       ('Как создать и использовать пул потоков с помощью ExecutorService?', 'Для создания и использования пула потоков с помощью ExecutorService можно использовать следующие классы:\n\n
1. ThreadPoolExecutor — реализует интерфейс ExecutorService и обеспечивает поддержку управляемого пула потоков исполнения.\n\n
2. ScheduledThreadPoolExecutor — реализует интерфейс ScheduledExecutorService для поддержки планирования пула потоков исполнения.\n\n
3. ForkJoinPool — реализует интерфейс ExecutorService и применяется в каркасе Fork/Join Framework.\n\n
При запуске задач с помощью Executor пакета java.util.concurrent не требуется прибегать к низкоуровневой поточной функциональности класса Thread, достаточно создать объект типа ExecutorService с нужными свойствами и передать ему на исполнение задачу типа Callable.', 'CORE3_MULTITHREADING', false),
       ('Как использовать CountDownLatch для ожидания завершения определенного числа задач?', 'Принцип работы CountDownLatch заключается в том, что вы создаете объект CountDownLatch с определенным счетчиком, который инициализируется при создании. Затем один или несколько потоков могут уменьшать этот счетчик, вызывая метод countDown(). Другие потоки могут ждать, пока счетчик не станет равным нулю, вызывая метод await().', 'CORE3_MULTITHREADING', false),
       ('Что представляет собой CyclicBarrier и в каких сценариях он может быть полезен?', 'CyclicBarrier реализует шаблон синхронизации [Барьер]. Циклический барьер является точкой синхронизации, в которой указанное количество параллельных потоков встречается и блокируется. Как только все потоки прибыли, выполняется опционное действие (или не выполняется, если барьер был инициализирован без него), и, после того, как оно выполнено, барьер ломается и ожидающие потоки «освобождаются». В конструктор барьера (`CyclicBarrier(int parties)` и `CyclicBarrier(int parties, Runnable barrierAction)`) обязательно передается количество сторон, которые должны «встретиться», и, опционально, действие, которое должно произойти, когда стороны встретились, но перед тем когда они будут «отпущены».\n\n
Примеры сценариев, где может быть полезен CyclicBarrier:\n\n
1. Разделение задачи на подзадачи.\n
2. Распределённые вычисления.\n
3. Симуляция многократного выполнения задач.', 'CORE3_MULTITHREADING', false),
       ('Что представляют собой классы ReentrantLock и ReentrantReadWriteLock?', 'ReentrantLock:\n
* Реализует блокировку взаимного исключения (mutex) в Java.\n
* Позволяет потоку приобретать и освобождать один и тот же замок несколько раз.\n
* Обеспечивает исключительную блокировку, то есть только один поток может владеть замком в любой момент времени.\n\n
ReentrantReadWriteLock:\n
* Является более сложной версией ReentrantLock, которая поддерживает как исключительную, так и разделяемую блокировки.\n
* Предоставляет два типа блокировок:\n
    - Блокировка чтения: Позволяет нескольким потокам одновременно считывать данные, защищенные замком.\n
    - Блокировка записи: Предоставляет исключительную блокировку, как и ReentrantLock, позволяя только одному потоку записывать данные, защищенные замком.', 'CORE3_MULTITHREADING', false),
       ('Как работает Phaser и для чего может быть использован?', 'Phaser определяет объект синхронизации, который ждёт, пока не завершится определённая фаза. Затем Phaser переходит к следующей стадии или фазе и снова ожидает её завершения.\n\n
Основные методы класса Phaser:\n
- int register(): регистрирует участника, который выполняет фазы, и возвращает номер текущей фазы;\n
- int arrive(): сообщает, что участник завершил фазу, и возвращает номер текущей фазы;\n
- int arriveAndAwaitAdvance(): аналогичен методу arrive, только при этом заставляет Phaser ожидать завершения фазы всеми остальными участниками;\n
- int arriveAndDeregister(): сообщает о завершении всех фаз участником и снимает его с регистрации.', 'CORE3_MULTITHREADING', false),
       ('Что представляет собой ConcurrentHashMap и где используется?', '* Является реализацией Map в Java, которая обеспечивает безопасную для потоков одновременную модификацию.\n\n
* Использует сегментированную архитектуру для повышения параллелизма и масштабируемости.\n
* Подходит для приложений с высокой конкурентностью, где несколько потоков одновременно обращаются к данным Map.\n\n
    Где используется:\n
* Кэширование данных\n
* Общие структуры данных между потоками\n
* Многопоточные приложения с высокими требованиями к производительности\n
* Системы с большим количеством одновременных запросов\n\n
    Преимущества:n
* Безопасность для потоков\n
* Высокая производительность\n
* Масштабируемость\n
* Поддержка одновременных операций чтения и записи', 'CORE3_MULTITHREADING', false),
       ('Что представляет собой ThreadLocal и где используется?', 'ThreadLocal - это класс в Java, который предоставляет способ создания переменных, которые могут быть доступны только в контексте одного потока. Эти переменные хранятся внутри объекта ThreadLocal и не видны другим потокам.\n\n ThreadLocal может быть полезен, когда необходимо создать переменную, которая должна быть локальной для каждого потока, например, когда нужно сохранять состояние при обработке запросов от разных клиентов в многопоточном сервере.', 'CORE3_MULTITHREADING', false),
       ('Как связаны Stream API и ForkJoinPool? Что представляют из себя?', 'В Stream API есть простой способ распараллеливания потока метедом parallel() или parallelStream(), чтобы получить выигрыш в производительности на многоядерных машинах.\n\n
По-умолчанию parallel stream используют ForkJoinPool.commonPool. Этот пул создается статически и живет пока не будет вызван System::exit. Если задачам не указывать конкретный пул, то они будут исполняться в рамках commonPool.\n\n
По-умолчанию, размер пула равен на 1 меньше, чем количество доступных ядер.\n\n
Когда некий тред отправляет задачу в common pool, то пул может использовать вызывающий тред (caller-thread) в качестве воркера. ForkJoinPool пытается загрузить своими задачами и вызывающий тред.', 'CORE3_MULTITHREADING', false),
       ('Что такое Java Memory Model?', 'Java Memory Model (JMM) — это спецификация, определяющая правила взаимодействия потоков с памятью в языке программирования Java. JMM описывает, как изменения в памяти, сделанные одним потоком, становятся видимыми для других потоков и как должны упорядочиваться операции чтения и записи. Основные понятия включают:

1. Видимость: Как изменения в памяти становятся видимыми для других потоков.
2. Атомарность: Неделимые операции (например, чтение/запись переменных типа int).
3. Перестановка инструкций: Компилятор и процессор могут изменять порядок выполнения инструкций ради оптимизации.
4. Синхронизация: Использование synchronized, volatile и других механизмов для обеспечения корректного взаимодействия между потоками.

JMM помогает предотвратить проблемы многопоточности, такие как гонки данных (race conditions) и ошибки синхронизации, обеспечивая предсказуемость и корректную работу многопоточных программ.', 'CORE3_MULTITHREADING', true),
       ('Что такое reordering, happens-before и область видимости?', 'Reordering (переупорядочивание):\n\n
* В многопоточных программах компилятор и процессор могут переупорядочивать инструкции для повышения производительности.\n\
* Переупорядочивание может привести к тому, что порядок выполнения инструкций в исходном коде не будет совпадать с порядком их фактического выполнения.\n\n
Happens-before (происходит до):\n\n
* Отношение, которое определяет порядок выполнения инструкций в многопоточной программе.\n
* Если инструкция A происходит до инструкции B, то изменения, внесенные инструкцией A, будут видны инструкции B, даже если они выполняются в разных потоках.\n\n
Область видимости:\n\n
* Определяет, какой поток может видеть изменения, внесенные в переменную.\n
* В Java есть два типа областей видимости:\n
    - Локальная область видимости потока: Переменные, объявленные внутри метода, видны только в этом методе.\n
    - Область видимости потокобезопасности: Переменные, объявленные как volatile или защищенные синхронизацией, видны всем потокам.', 'CORE3_MULTITHREADING', true);